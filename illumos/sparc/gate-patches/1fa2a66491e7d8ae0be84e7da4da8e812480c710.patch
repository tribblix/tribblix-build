From 1fa2a66491e7d8ae0be84e7da4da8e812480c710 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <josh@sysmgr.org>
Date: Mon, 21 Feb 2022 22:48:06 -0800
Subject: [PATCH] 14249 pseudo-terminal nomenclature should reflect POSIX
 Reviewed by: Andy Fiddaman <andy@omnios.org> Reviewed by: Toomas Soome
 <tsoome@me.com> Reviewed by: Rich Lowe <richlowe@richlowe.net> Approved by:
 Robert Mustacchi <rm@fingolfin.org>

---
 usr/src/cmd/cmd-inet/usr.sbin/in.rlogind.c    |   28 +-
 usr/src/cmd/cmd-inet/usr.sbin/in.telnetd.c    |   52 +-
 usr/src/cmd/devfsadm/misc_link.c              |    8 +-
 usr/src/cmd/enhance/enhance.c                 |  136 +-
 usr/src/cmd/script/script.c                   |   70 +-
 usr/src/cmd/truss/codes.c                     |    4 +-
 usr/src/cmd/ttymon/parms.h                    |   17 +-
 usr/src/cmd/zoneadmd/zcons.c                  |  110 +-
 usr/src/man/man1m/in.rlogind.1m               |   10 +-
 usr/src/man/man1m/in.telnetd.1m               |   11 +-
 usr/src/man/man1m/pppd.1m                     |   38 +-
 usr/src/man/man2/close.2                      |  466 +++--
 usr/src/man/man2/open.2                       | 1770 ++++++++---------
 usr/src/man/man3c/grantpt.3c                  |  154 +-
 usr/src/man/man3c/posix_openpt.3c             |  286 ++-
 usr/src/man/man3c/ptsname.3c                  |  123 +-
 usr/src/man/man3c/unlockpt.3c                 |  139 +-
 .../utempter_add_record.3utempter             |    6 +-
 usr/src/man/man7d/Makefile                    |    6 +-
 usr/src/man/man7d/ptm.7d                      |  338 +++-
 usr/src/man/man7d/pts.7d                      |  107 -
 usr/src/man/man7d/pty.7d                      |  495 ++---
 usr/src/man/man7d/zcons.7d                    |  129 +-
 usr/src/man/man7m/pckt.7m                     |   13 +-
 usr/src/man/man7m/ptem.7m                     |  184 +-
 usr/src/pkg/manifests/SUNWcs.man7d.inc        |    2 +-
 usr/src/uts/common/fs/dev/sdev_ptsops.c       |   23 +-
 usr/src/uts/common/io/ptem.c                  |   19 +-
 usr/src/uts/common/io/ptm.c                   |  246 +--
 usr/src/uts/common/io/ptms_conf.c             |  139 +-
 usr/src/uts/common/io/pts.c                   |  232 ++-
 usr/src/uts/common/io/tty_pts.c               |   46 +-
 usr/src/uts/common/io/tty_pty.c               |   84 +-
 usr/src/uts/common/io/zcons.c                 |  401 ++--
 usr/src/uts/common/sys/ptms.h                 |   63 +-
 usr/src/uts/common/sys/ptyvar.h               |   12 +-
 usr/src/uts/common/sys/termios.h              |    2 +-
 usr/src/uts/common/sys/zcons.h                |   26 +-
 38 files changed, 3049 insertions(+), 2946 deletions(-)
 delete mode 100644 usr/src/man/man7d/pts.7d

diff --git a/usr/src/cmd/cmd-inet/usr.sbin/in.rlogind.c b/usr/src/cmd/cmd-inet/usr.sbin/in.rlogind.c
index 5d3bc60abf..1c495aff84 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/in.rlogind.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/in.rlogind.c
@@ -3,8 +3,8 @@
  * Use is subject to license terms.
  */
 
-/*	Copyright(c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*	Copyright(c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T */
+/*	  All Rights Reserved */
 
 /*
  * Copyright (c) 1983 The Regents of the University of California.
@@ -1057,13 +1057,13 @@ doit(int f,
 	if ((p = open("/dev/ptmx", O_RDWR)) == -1)
 		fatalperror(f, "cannot open /dev/ptmx");
 	if (grantpt(p) == -1)
-		fatal(f, "could not grant slave pty");
+		fatal(f, "could not grant subsidiary pty");
 	if (unlockpt(p) == -1)
-		fatal(f, "could not unlock slave pty");
+		fatal(f, "could not unlock subsidiary pty");
 	if ((line = ptsname(p)) == NULL)
-		fatal(f, "could not enable slave pty");
+		fatal(f, "could not enable subsidiary pty");
 	if ((t = open(line, O_RDWR)) == -1)
-		fatal(f, "could not open slave pty");
+		fatal(f, "could not open subsidiary pty");
 	if (ioctl(t, I_PUSH, "ptem") == -1)
 		fatalperror(f, "ioctl I_PUSH ptem");
 	if (ioctl(t, I_PUSH, "ldterm") == -1)
@@ -1128,9 +1128,9 @@ doit(int f,
 
 	/*
 	 * System V ptys allow the TIOC{SG}WINSZ ioctl to be
-	 * issued on the master side of the pty.  Luckily, that's
+	 * issued on the manager side of the pty.  Luckily, that's
 	 * the only tty ioctl we need to do do, so we can close the
-	 * slave side in the parent process after the fork.
+	 * subsidiary side in the parent process after the fork.
 	 */
 	(void) ioctl(p, TIOCSWINSZ, &win);
 
@@ -1161,12 +1161,12 @@ doit(int f,
 		if (setsid() == -1)
 			fatalperror(f, "setsid");
 		if ((tt = open(line, O_RDWR)) == -1)
-			fatalperror(f, "could not re-open slave pty");
+			fatalperror(f, "could not re-open subsidiary pty");
 
 		if (close(p) == -1)
-			fatalperror(f, "error closing pty master");
+			fatalperror(f, "error closing pty manager");
 		if (close(t) == -1)
-			fatalperror(f, "error closing pty slave"
+			fatalperror(f, "error closing pty subsidiary"
 				    " opened before session established");
 		/*
 		 * If this fails we may or may not be able to output an
@@ -1209,8 +1209,8 @@ doit(int f,
 
 	/*
 	 * Must ignore SIGTTOU, otherwise we'll stop
-	 * when we try and set slave pty's window shape
-	 * (our controlling tty is the master pty).
+	 * when we try and set subsidiary pty's window shape
+	 * (our controlling tty is the manager pty).
 	 * Likewise, we don't want any of the tty-generated
 	 * signals from chars passing through.
 	 */
@@ -1332,7 +1332,7 @@ static void
 protocol(int f, int p, int encr_flag)
 {
 	struct	stat	buf;
-	struct 	protocol_arg	rloginp;
+	struct	protocol_arg	rloginp;
 	struct	strioctl	rloginmod;
 	int	ptmfd;	/* fd of logindmux coneected to ptmx */
 	int	netfd;	/* fd of logindmux connected to netf */
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/in.telnetd.c b/usr/src/cmd/cmd-inet/usr.sbin/in.telnetd.c
index afeb5a5c55..bbd38a551c 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/in.telnetd.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/in.telnetd.c
@@ -242,7 +242,7 @@ static int cryptmod_fd = -1;
 #define	TS_DONT		8	/* dont " */
 
 static int	ncc;
-static int	master;		/* master side of pty */
+static int	manager;	/* manager side of pty */
 static int	pty;		/* side of pty that gets ioctls */
 static int	net;
 static int	inter;
@@ -2754,20 +2754,20 @@ doit(int f, struct sockaddr_storage *who)
 	char username[MAXUSERNAMELEN];
 	int len;
 	uchar_t passthru;
-	char *slavename;
+	char *subsidname;
 
 	if ((p = open("/dev/ptmx", O_RDWR | O_NOCTTY)) == -1) {
 		fatalperror(f, "open /dev/ptmx", errno);
 	}
 	if (grantpt(p) == -1)
-		fatal(f, "could not grant slave pty");
+		fatal(f, "could not grant subsidiary pty");
 	if (unlockpt(p) == -1)
-		fatal(f, "could not unlock slave pty");
-	if ((slavename = ptsname(p)) == NULL)
-		fatal(f, "could not enable slave pty");
+		fatal(f, "could not unlock subsidiary pty");
+	if ((subsidname = ptsname(p)) == NULL)
+		fatal(f, "could not enable subsidiary pty");
 	(void) dup2(f, 0);
-	if ((t = open(slavename, O_RDWR | O_NOCTTY)) == -1)
-		fatal(f, "could not open slave pty");
+	if ((t = open(subsidname, O_RDWR | O_NOCTTY)) == -1)
+		fatal(f, "could not open subsidiary pty");
 	if (ioctl(t, I_PUSH, "ptem") == -1)
 		fatalperror(f, "ioctl I_PUSH ptem", errno);
 	if (ioctl(t, I_PUSH, "ldterm") == -1)
@@ -2775,7 +2775,7 @@ doit(int f, struct sockaddr_storage *who)
 	if (ioctl(t, I_PUSH, "ttcompat") == -1)
 		fatalperror(f, "ioctl I_PUSH ttcompat", errno);
 
-	line = slavename;
+	line = subsidname;
 
 	pty = t;
 
@@ -3039,7 +3039,7 @@ doit(int f, struct sockaddr_storage *who)
 		fatal(netfd, "ioctl LOGDMX_IOC_QEXCHANGE of ptmfd failed\n");
 
 	net = netfd;
-	master = ptmfd;
+	manager = ptmfd;
 	cryptmod_fd = netfd;
 
 	/*
@@ -3100,11 +3100,11 @@ doit(int f, struct sockaddr_storage *who)
 	if ((pid = fork()) < 0)
 		fatalperror(netfd, "fork", errno);
 	if (pid)
-		telnet(net, master);
+		telnet(net, manager);
 	/*
 	 * The child process needs to be the session leader
 	 * and have the pty as its controlling tty.  Thus we need
-	 * to re-open the slave side of the pty no without
+	 * to re-open the subsidiary side of the pty no without
 	 * the O_NOCTTY flag that we have been careful to
 	 * use up to this point.
 	 */
@@ -3130,10 +3130,10 @@ doit(int f, struct sockaddr_storage *who)
 	if (terminaltype)
 		(void) local_setenv("TERM", terminaltype+5, 1);
 	/*
-	 * 	-h : pass on name of host.
+	 *	-h : pass on name of host.
 	 *		WARNING:  -h is accepted by login if and only if
 	 *			getuid() == 0.
-	 * 	-p : don't clobber the environment (so terminal type stays set).
+	 *	-p : don't clobber the environment (so terminal type stays set).
 	 */
 	{
 		/* System V login expects a utmp entry to already be there */
@@ -3192,7 +3192,7 @@ doit(int f, struct sockaddr_storage *who)
 	    ((AuthenticatingUser != NULL) && strlen(AuthenticatingUser))) {
 		(void) execl(LOGIN_PROGRAM, "login",
 			    "-p",
-			    "-d", slavename,
+			    "-d", subsidname,
 			    "-h", host,
 			    "-u", krb5_name,
 			    "-s", pam_svc_name,
@@ -3208,7 +3208,7 @@ doit(int f, struct sockaddr_storage *who)
 		 */
 		(void) execl(LOGIN_PROGRAM, "login",
 		    "-p",
-		    "-d", slavename,
+		    "-d", subsidname,
 		    "-h", host,
 		    "-s", pam_svc_name, "--",
 		    (AuthenticatingUser != NULL ? AuthenticatingUser :
@@ -3216,7 +3216,7 @@ doit(int f, struct sockaddr_storage *who)
 
 	} else /* default, no auth. info available, login does it all */ {
 		(void) execl(LOGIN_PROGRAM, "login",
-		    "-p", "-h", host, "-d", slavename, "--",
+		    "-p", "-h", host, "-d", subsidname, "--",
 		    getenv("USER"), 0);
 	}
 
@@ -3254,7 +3254,7 @@ fatalperror(int f, char *msg, int errnum)
  * inkernel telnet streams module (telmod).
  */
 static void
-telnet(int net, int master)
+telnet(int net, int manager)
 {
 	int on = 1;
 	char mode;
@@ -3265,7 +3265,7 @@ telnet(int net, int master)
 
 	if (ioctl(net, FIONBIO, &on) == -1)
 		syslog(LOG_INFO, "ioctl FIONBIO net: %m\n");
-	if (ioctl(master, FIONBIO, &on) == -1)
+	if (ioctl(manager, FIONBIO, &on) == -1)
 		syslog(LOG_INFO, "ioctl FIONBIO pty p: %m\n");
 	(void) signal(SIGTSTP, SIG_IGN);
 	(void) signal(SIGCHLD, (void (*)())cleanup);
@@ -3302,7 +3302,7 @@ telnet(int net, int master)
 		 * stuff in the corresponding output buffer
 		 */
 		if (pfrontp - pbackp) {
-			FD_SET(master, &obits);
+			FD_SET(manager, &obits);
 		} else {
 			FD_SET(net, &ibits);
 		}
@@ -3390,7 +3390,7 @@ telnet(int net, int master)
 				fatal(net, "ioctl TEL_IOC_GETBLK failed\n");
 		}
 
-		if ((c = select(max(net, master) + 1, &ibits, &obits, &xbits,
+		if ((c = select(max(net, manager) + 1, &ibits, &obits, &xbits,
 		    (struct timeval *)0)) < 1) {
 			if (c == -1) {
 				if (errno == EINTR) {
@@ -3427,7 +3427,7 @@ telnet(int net, int master)
 			netflush();
 		if (ncc > 0)
 			telrcv();
-		if (FD_ISSET(master, &obits) && (pfrontp - pbackp) > 0)
+		if (FD_ISSET(manager, &obits) && (pfrontp - pbackp) > 0)
 			ptyflush();
 	}
 	cleanup(0);
@@ -4279,7 +4279,7 @@ ptyflush(void)
 	int n;
 
 	if ((n = pfrontp - pbackp) > 0)
-		n = write(master, pbackp, n);
+		n = write(manager, pbackp, n);
 	if (n < 0)
 		return;
 	pbackp += n;
@@ -4447,9 +4447,9 @@ cleanup(int signum)
 	/*
 	 * If the TEL_IOC_ENABLE ioctl hasn't completed, then we need to
 	 * handle closing differently.  We close "net" first and then
-	 * "master" in that order.  We do close(net) first because
+	 * "manager" in that order.  We do close(net) first because
 	 * we have no other way to disconnect forwarding between the network
-	 * and master.  So by issuing the close()'s we ensure that no further
+	 * and manager.  So by issuing the close()'s we ensure that no further
 	 * data rises from TCP.  A more complex fix would be adding proper
 	 * support for throwing a "stop" switch for forwarding data between
 	 * logindmux peers.  It's possible to block in the close of the tty
@@ -4460,7 +4460,7 @@ cleanup(int signum)
 
 	if (!telmod_init_done) {
 		(void) close(net);
-		(void) close(master);
+		(void) close(manager);
 	}
 	rmut();
 
diff --git a/usr/src/cmd/devfsadm/misc_link.c b/usr/src/cmd/devfsadm/misc_link.c
index 5f241df296..30e3e1863e 100644
--- a/usr/src/cmd/devfsadm/misc_link.c
+++ b/usr/src/cmd/devfsadm/misc_link.c
@@ -224,8 +224,8 @@ static devfsadm_remove_t misc_remove_cbt[] = {
 	{ "pseudo", "^daplt$",
 	    RM_PRE | RM_ALWAYS, ILEVEL_0, devfsadm_rm_all
 	},
-	{ "pseudo", "^zcons/" ZONENAME_REGEXP "/(" ZCONS_MASTER_NAME "|"
-		ZCONS_SLAVE_NAME ")$",
+	{ "pseudo", "^zcons/" ZONENAME_REGEXP "/(" ZCONS_MANAGER_NAME "|"
+		ZCONS_SUBSIDIARY_NAME ")$",
 	    RM_PRE | RM_HOT | RM_ALWAYS, ILEVEL_0, devfsadm_rm_all
 	},
 	{ "pseudo", "^" CPUID_SELF_NAME "$", RM_ALWAYS | RM_PRE | RM_HOT,
@@ -474,7 +474,7 @@ fc_port(di_minor_t minor, di_node_t node)
 /*
  * Handles:
  *	minor node type "ddi_printer".
- * 	rules of the form: type=ddi_printer;name=bpp  \M0
+ *	rules of the form: type=ddi_printer;name=bpp  \M0
  */
 static int
 printer_create(di_minor_t minor, di_node_t node)
@@ -676,7 +676,7 @@ zcons_create(di_minor_t minor, di_node_t node)
 }
 
 /*
- *	/dev/cpu/self/cpuid 	->	/devices/pseudo/cpuid@0:self
+ *	/dev/cpu/self/cpuid	->	/devices/pseudo/cpuid@0:self
  */
 static int
 cpuid(di_minor_t minor, di_node_t node)
diff --git a/usr/src/cmd/enhance/enhance.c b/usr/src/cmd/enhance/enhance.c
index 25650e378e..3fb004fbd0 100644
--- a/usr/src/cmd/enhance/enhance.c
+++ b/usr/src/cmd/enhance/enhance.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -69,24 +67,24 @@ int unlockpt(int fd);
 #define PTY_CNTRL "pty"
 
 /*
- * Pseudo-terminal slave device file names start with the following
+ * Pseudo-terminal subsidiary device file names start with the following
  * prefix.
  */
-#define PTY_SLAVE "tty"
+#define PTY_SUBSID "tty"
 
 /*
- * Specify the maximum suffix length for the control and slave device
+ * Specify the maximum suffix length for the control and subsidiary device
  * names.
  */
 #define PTY_MAX_SUFFIX 10
 
 /*
- * Set the maximum length of the master and slave terminal device filenames,
- * including space for a terminating '\0'.
+ * Set the maximum length of the manager and subsidiary terminal device
+ * filenames, including space for a terminating '\0'.
  */
 #define PTY_MAX_NAME (sizeof(PTY_DEV_DIR)-1 + \
-		      (sizeof(PTY_SLAVE) > sizeof(PTY_CNTRL) ? \
-		       sizeof(PTY_SLAVE) : sizeof(PTY_CNTRL))-1 \
+		      (sizeof(PTY_SUBSID) > sizeof(PTY_CNTRL) ? \
+		       sizeof(PTY_SUBSID) : sizeof(PTY_CNTRL))-1 \
 		      + PTY_MAX_SUFFIX + 1)
 /*
  * Set the maximum length of an input line.
@@ -110,15 +108,15 @@ int unlockpt(int fd);
  */
 #define PTY_READ_TIMEOUT 100000    /* micro-seconds */
 
-static int pty_open_master(const char *prog, int *cntrl, char *slave_name);
-static int pty_open_slave(const char *prog, char *slave_name);
-static int pty_child(const char *prog, int slave, char *argv[]);
+static int pty_open_manager(const char *prog, int *cntrl, char *subsid_name);
+static int pty_open_subsid(const char *prog, char *subsid_name);
+static int pty_child(const char *prog, int subsid, char *argv[]);
 static int pty_parent(const char *prog, int cntrl);
 static int pty_stop_parent(int waserr, int cntrl, GetLine *gl, char *rbuff);
 static GL_FD_EVENT_FN(pty_read_from_program);
 static int pty_write_to_fd(int fd, const char *string, int n);
 static void pty_child_exited(int sig);
-static int pty_master_readable(int fd, long usec);
+static int pty_manager_readable(int fd, long usec);
 
 /*.......................................................................
  * Run a program with enhanced terminal editing facilities.
@@ -129,11 +127,11 @@ static int pty_master_readable(int fd, long usec);
 int main(int argc, char *argv[])
 {
   int cntrl = -1;  /* The fd of the pseudo-terminal controller device */
-  int slave = -1;  /* The fd of the pseudo-terminal slave device */
+  int subsid = -1;  /* The fd of the pseudo-terminal subsidiary device */
   pid_t pid;       /* The return value of fork() */
   int status;      /* The return statuses of the parent and child functions */
-  char slave_name[PTY_MAX_NAME]; /* The filename of the slave end of the */
-                                 /*  pseudo-terminal. */
+  char subsid_name[PTY_MAX_NAME]; /* The filename of the subsidiary end of */
+				 /*  the pseudo-terminal. */
   char *prog;      /* The name of the program (ie. argv[0]) */
 /*
  * Check the arguments.
@@ -165,11 +163,11 @@ int main(int argc, char *argv[])
     };
   };
 /*
- * Open the master side of a pseudo-terminal pair, and return
+ * Open the manager side of a pseudo-terminal pair, and return
  * the corresponding file descriptor and the filename of the
- * slave end of the pseudo-terminal.
+ * subsidiary end of the pseudo-terminal.
  */
-  if(pty_open_master(prog, &cntrl, slave_name))
+  if(pty_open_manager(prog, &cntrl, subsid_name))
     return 1;
 /*
  * Set up a signal handler to watch for the child process exiting.
@@ -201,11 +199,11 @@ int main(int argc, char *argv[])
     status = pty_parent(prog, cntrl);
     close(cntrl);
   } else {
-    close(cntrl); /* The child doesn't use the slave device */
+    close(cntrl); /* The child doesn't use the subsidiary device */
     signal(SIGCHLD, pty_child_exited);
-    if((slave = pty_open_slave(prog, slave_name)) >= 0) {
-      status = pty_child(prog, slave, argv + 1);
-      close(slave);
+    if((subsid = pty_open_subsid(prog, subsid_name)) >= 0) {
+      status = pty_child(prog, subsid, argv + 1);
+      close(subsid);
     } else {
       status = 1;
     };
@@ -214,24 +212,24 @@ int main(int argc, char *argv[])
 }
 
 /*.......................................................................
- * Open the master side of a pseudo-terminal pair, and return
+ * Open the manager side of a pseudo-terminal pair, and return
  * the corresponding file descriptor and the filename of the
- * slave end of the pseudo-terminal.
+ * subsidiary end of the pseudo-terminal.
  *
  * Input/Output:
  *  prog  const char *  The name of this program.
  *  cntrl        int *  The file descriptor of the pseudo-terminal
  *                      controller device will be assigned tp *cntrl.
- *  slave_name  char *  The file-name of the pseudo-terminal slave device
- *                      will be recorded in slave_name[], which must have
+ *  subsid_name  char *  The file-name of the pseudo-terminal subsidiary device
+ *                      will be recorded in subsid_name[], which must have
  *                      at least PTY_MAX_NAME elements.
  * Output:
  *  return       int    0 - OK.
  *                      1 - Error.
  */
-static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
+static int pty_open_manager(const char *prog, int *cntrl, char *subsid_name)
 {
-  char master_name[PTY_MAX_NAME]; /* The filename of the master device */
+  char manager_name[PTY_MAX_NAME]; /* The filename of the manager device */
   DIR *dir;                       /* The directory iterator */
   struct dirent *file;            /* A file in "/dev" */
 /*
@@ -240,26 +238,26 @@ static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
   *cntrl = -1;
 /*
  * On systems with the Sys-V pseudo-terminal interface, we don't
- * have to search for a free master terminal. We just open /dev/ptmx,
- * and if there is a free master terminal device, we are given a file
+ * have to search for a free manager terminal. We just open /dev/ptmx,
+ * and if there is a free manager terminal device, we are given a file
  * descriptor connected to it.
  */
 #if HAVE_SYSV_PTY
   *cntrl = open("/dev/ptmx", O_RDWR);
   if(*cntrl >= 0) {
 /*
- * Get the filename of the slave side of the pseudo-terminal.
+ * Get the filename of the subsidiary side of the pseudo-terminal.
  */
     char *name = ptsname(*cntrl);
     if(name) {
       if(strlen(name)+1 > PTY_MAX_NAME) {
-	fprintf(stderr, "%s: Slave pty filename too long.\n", prog);
+	fprintf(stderr, "%s: Subsidiary pty filename too long.\n", prog);
 	return 1;
       };
-      strlcpy(slave_name, name, PTY_MAX_NAME);
+      strlcpy(subsid_name, name, PTY_MAX_NAME);
 /*
- * If unable to get the slave name, discard the controller file descriptor,
- * ready to try a search instead.
+ * If unable to get the subsidiary name, discard the controller file
+ * descriptor, ready to try a search instead.
  */
     } else {
       close(*cntrl);
@@ -269,7 +267,7 @@ static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
 #endif
 /*
  * On systems without /dev/ptmx, or if opening /dev/ptmx failed,
- * we open one master terminal after another, until one that isn't
+ * we open one manager terminal after another, until one that isn't
  * in use by another program is found.
  *
  * Open the devices directory.
@@ -287,7 +285,7 @@ static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
     while(*cntrl < 0 && (file = readdir(dir))) {
       if(strncmp(file->d_name, PTY_CNTRL, sizeof(PTY_CNTRL)-1) == 0) {
 /*
- * Get the common extension of the control and slave filenames.
+ * Get the common extension of the control and subsidiary filenames.
  */
 	const char *ext = file->d_name + sizeof(PTY_CNTRL)-1;
 	if(strlen(ext) > PTY_MAX_SUFFIX)
@@ -295,18 +293,18 @@ static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
 /*
  * Attempt to open the control file.
  */
-	strlcpy(master_name, PTY_DEV_DIR, sizeof(master_name));
-	strlcat(master_name, PTY_CNTRL, sizeof(master_name));
-	strlcat(master_name, ext, sizeof(master_name));
-	*cntrl = open(master_name, O_RDWR);
+	strlcpy(manager_name, PTY_DEV_DIR, sizeof(manager_name));
+	strlcat(manager_name, PTY_CNTRL, sizeof(manager_name));
+	strlcat(manager_name, ext, sizeof(manager_name));
+	*cntrl = open(manager_name, O_RDWR);
 	if(*cntrl < 0)
 	  continue;
 /*
- * Attempt to open the matching slave file.
+ * Attempt to open the matching subsidiary file.
  */
-	strlcpy(slave_name, PTY_DEV_DIR, PTY_MAX_NAME);
-	strlcat(slave_name, PTY_SLAVE, PTY_MAX_NAME);
-	strlcat(slave_name, ext, PTY_MAX_NAME);
+	strlcpy(subsid_name, PTY_DEV_DIR, PTY_MAX_NAME);
+	strlcat(subsid_name, PTY_SUBSID, PTY_MAX_NAME);
+	strlcat(subsid_name, ext, PTY_MAX_NAME);
       };
     };
     closedir(dir);
@@ -321,8 +319,8 @@ static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
     return 1;
   };
 /*
- * System V systems require the program that opens the master to
- * grant access to the slave side of the pseudo-terminal.
+ * System V systems require the program that opens the manager to
+ * grant access to the subsidiary side of the pseudo-terminal.
  */
 #ifdef HAVE_SYSV_PTY
   if(grantpt(*cntrl) < 0 ||
@@ -339,18 +337,18 @@ static int pty_open_master(const char *prog, int *cntrl, char *slave_name)
 }
 
 /*.......................................................................
- * Open the slave end of a pseudo-terminal.
+ * Open the subsidiary end of a pseudo-terminal.
  *
  * Input:
  *  prog   const char *  The name of this program.
- *  slave_name   char *  The filename of the slave device.
+ *  subsid_name   char *  The filename of the subsidiary device.
  * Output:
  *  return        int    The file descriptor of the successfully opened
- *                       slave device, or < 0 on error.
+ *                       subsidiary device, or < 0 on error.
  */
-static int pty_open_slave(const char *prog, char *slave_name)
+static int pty_open_subsid(const char *prog, char *subsid_name)
 {
-  int fd;  /* The file descriptor of the slave device */
+  int fd;  /* The file descriptor of the subsidiary device */
 /*
  * Place the process in its own process group. In system-V based
  * OS's, this ensures that when the pseudo-terminal is opened, it
@@ -364,16 +362,16 @@ static int pty_open_slave(const char *prog, char *slave_name)
 /*
  * Attempt to open the specified device.
  */
-  fd = open(slave_name, O_RDWR);
+  fd = open(subsid_name, O_RDWR);
   if(fd < 0) {
-    fprintf(stderr, "%s: Unable to open pseudo-terminal slave device (%s).\n",
+    fprintf(stderr, "%s: Unable to open pty subsidiary device (%s).\n",
 	    prog, strerror(errno));
     return -1;
   };
 /*
  * On system-V streams based systems, we need to push the stream modules
  * that implement pseudo-terminal and termio interfaces. At least on
- * Solaris, which pushes these automatically when a slave is opened,
+ * Solaris, which pushes these automatically when a subsidiary is opened,
  * this is redundant, so ignore errors when pushing the modules.
  */
 #if HAVE_SYSV_PTY
@@ -498,11 +496,11 @@ static int pty_stop_parent(int waserr, int cntrl, GetLine *gl, char *rbuff)
 
 /*.......................................................................
  * Run the user's program, with its stdin and stdout connected to the
- * slave end of the psuedo-terminal.
+ * subsidiary end of the psuedo-terminal.
  *
  * Input:
  *  prog  const char *   The name of this program.
- *  slave        int     The file descriptor of the slave end of the
+ *  subsid        int     The file descriptor of the subsidiary end of the
  *                       pseudo terminal.
  *  argv        char *[] The argument vector to pass to the user's program,
  *                       where argv[0] is the name of the user's program,
@@ -514,33 +512,33 @@ static int pty_stop_parent(int waserr, int cntrl, GetLine *gl, char *rbuff)
  *                       with the user's program. In this case 1 is
  *                       returned.
  */
-static int pty_child(const char *prog, int slave, char *argv[])
+static int pty_child(const char *prog, int subsid, char *argv[])
 {
   struct termios attr; /* The terminal attributes */
 /*
  * We need to stop the pseudo-terminal from echoing everything that we send it.
  */
-  if(tcgetattr(slave, &attr)) {
+  if(tcgetattr(subsid, &attr)) {
     fprintf(stderr, "%s: Can't get pseudo-terminal attributes (%s).\n", prog,
 	    strerror(errno));
     return 1;
   };
   attr.c_lflag &= ~(ECHO);
-  while(tcsetattr(slave, TCSADRAIN, &attr)) {
+  while(tcsetattr(subsid, TCSADRAIN, &attr)) {
     if(errno != EINTR) {
       fprintf(stderr, "%s: tcsetattr error: %s\n", prog, strerror(errno));
       return 1;
     };
   };
 /*
- * Arrange for stdin, stdout and stderr to be connected to the slave device,
- * ignoring errors that imply that either stdin or stdout is closed.
+ * Arrange for stdin, stdout and stderr to be connected to the subsidiary
+ * device, ignoring errors that imply that either stdin or stdout is closed.
  */
-  while(dup2(slave, STDIN_FILENO) < 0 && errno==EINTR)
+  while(dup2(subsid, STDIN_FILENO) < 0 && errno==EINTR)
     ;
-  while(dup2(slave, STDOUT_FILENO) < 0 && errno==EINTR)
+  while(dup2(subsid, STDOUT_FILENO) < 0 && errno==EINTR)
     ;
-  while(dup2(slave, STDERR_FILENO) < 0 && errno==EINTR)
+  while(dup2(subsid, STDERR_FILENO) < 0 && errno==EINTR)
     ;
 /*
  * Run the user's program.
@@ -648,7 +646,7 @@ static GL_FD_EVENT_FN(pty_read_from_program)
  */
       memmove(rbuff, nextp, len - (nextp - rbuff) + 1);
     };
-  } while(pty_master_readable(fd, PTY_READ_TIMEOUT));
+  } while(pty_manager_readable(fd, PTY_READ_TIMEOUT));
 /*
  * Make the incomplete line in the output buffer the current prompt.
  */
@@ -686,7 +684,7 @@ static int pty_write_to_fd(int fd, const char *string, int n)
 /*.......................................................................
  * This is the signal handler that is called when the child process
  * that is running the user's program exits for any reason. It closes
- * the slave end of the terminal, so that gl_get_line() in the parent
+ * the subsidiary end of the terminal, so that gl_get_line() in the parent
  * process sees an end of file.
  */
 static void pty_child_exited(int sig)
@@ -707,7 +705,7 @@ static void pty_child_exited(int sig)
  *                     available).
  *                 1 - Data is waiting to be read.
  */
-static int pty_master_readable(int fd, long usec)
+static int pty_manager_readable(int fd, long usec)
 {
 #if HAVE_SELECT
   fd_set rfds;             /* The set of file descriptors to check */
diff --git a/usr/src/cmd/script/script.c b/usr/src/cmd/script/script.c
index 313a35df8a..0e73a9fd9b 100644
--- a/usr/src/cmd/script/script.c
+++ b/usr/src/cmd/script/script.c
@@ -3,8 +3,8 @@
  * Use is subject to license terms.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
+/*	  All Rights Reserved */
 
 
 /*
@@ -33,8 +33,8 @@
 #include <sys/file.h>
 #include <errno.h>
 
-int 	grantpt();
-int 	unlockpt();
+int	grantpt();
+int	unlockpt();
 char	*ptsname();
 void	doinput() __NORETURN;
 void	dooutput();
@@ -42,13 +42,13 @@ void	doshell();
 void	fixtty();
 void	fail();
 void	done() __NORETURN;
-void	getmaster();
-void	getslave();
+void	getmanager();
+void	getsubsid();
 
 char	*shell;
 FILE	*fscript;
-int	master;			/* file descriptor for master pseudo-tty */
-int	slave;			/* file descriptor for slave pseudo-tty */
+int	manager;	/* file descriptor for manager pseudo-tty */
+int	subsid;		/* file descriptor for subsidiary pseudo-tty */
 int	child;
 int	subchild;
 char	*fname = "typescript";
@@ -59,7 +59,7 @@ struct	termios b;
 struct	winsize size;
 int	lb;
 int	l;
-char	*mptname = "/dev/ptmx";	/* master pseudo-tty device */
+char	*mptname = "/dev/ptmx";	/* manager pseudo-tty device */
 
 int	aflg;
 
@@ -103,7 +103,7 @@ main(int argc, char *argv[])
 	}
 	setbuf(fscript, NULL);
 	chown(fname, ruidt, gidt);
-	getmaster();
+	getmanager();
 	printf(gettext("Script started, file is %s\n"), fname);
 	fixtty();
 
@@ -146,7 +146,7 @@ doinput()
 				break;
 			}
 		}
-		(void) write(master, ibuf, cc);
+		(void) write(manager, ibuf, cc);
 	}
 	done();
 }
@@ -157,7 +157,7 @@ sigwinch()
 	struct winsize ws;
 
 	if (ioctl(0, TIOCGWINSZ, &ws) == 0)
-		(void) ioctl(master, TIOCSWINSZ, &ws);
+		(void) ioctl(manager, TIOCSWINSZ, &ws);
 }
 
 #include <sys/wait.h>
@@ -190,7 +190,7 @@ dooutput()
 	strftime(tbuf, BUFSIZ, "%c", localtime(&tvec));
 	fprintf(fscript, gettext("Script started on %s\n"), tbuf);
 	for (;;) {
-		cc = read(master, obuf, sizeof (obuf));
+		cc = read(manager, obuf, sizeof (obuf));
 		if (cc <= 0)
 			break;
 		(void) write(1, obuf, cc);
@@ -204,13 +204,13 @@ doshell()
 {
 
 	setpgrp();	/* relinquish control terminal */
-	getslave();
-	(void) close(master);
+	getsubsid();
+	(void) close(manager);
 	(void) fclose(fscript);
-	(void) dup2(slave, 0);
-	(void) dup2(slave, 1);
-	(void) dup2(slave, 2);
-	(void) close(slave);
+	(void) dup2(subsid, 0);
+	(void) dup2(subsid, 1);
+	(void) dup2(subsid, 2);
+	(void) close(subsid);
 	execl(shell, shell, "-i", (char *)0);
 	perror(shell);
 	fail();
@@ -249,7 +249,7 @@ done()
 		strftime(tbuf, BUFSIZ, "%c", localtime(&tvec));
 		fprintf(fscript, gettext("\nscript done on %s\n"), tbuf);
 		(void) fclose(fscript);
-		(void) close(master);
+		(void) close(manager);
 	} else {
 		(void) ioctl(0, TCSETSW, (char *)&b);
 		printf(gettext("Script done, file is %s\n"), fname);
@@ -258,11 +258,11 @@ done()
 }
 
 void
-getmaster()
+getmanager()
 {
 	struct stat stb;
 
-	if ((master = open(mptname, O_RDWR)) >= 0) { /* a pseudo-tty is free */
+	if ((manager = open(mptname, O_RDWR)) >= 0) { /* a pseudo-tty is free */
 		(void) ioctl(0, TCGETS, (char *)&b);
 		(void) ioctl(0, TIOCGWINSZ, (char *)&size);
 		return;
@@ -274,21 +274,21 @@ getmaster()
 }
 
 void
-getslave()
+getsubsid()
 {
-	char *slavename;	/* name of slave pseudo-tty */
-
-	grantpt(master);		/* change permissions of slave */
-	unlockpt(master);			/* unlock slave */
-	slavename = ptsname(master);		/* get name of slave */
-	slave = open(slavename, O_RDWR);	/* open slave */
-	if (slave < 0) {			/* error on opening slave */
-		perror(slavename);
+	char *subsidname;	/* name of subsidiary pseudo-tty */
+
+	grantpt(manager);		/* change permissions of subsidiary */
+	unlockpt(manager);			/* unlock subsidiary */
+	subsidname = ptsname(manager);		/* get name of subsidiary */
+	subsid = open(subsidname, O_RDWR);	/* open subsidiary */
+	if (subsid < 0) {			/* error opening subsidiary */
+		perror(subsidname);
 		fail();
 	}
-	ioctl(slave, I_PUSH, "ptem");	/* push pt hw emulation module */
-	ioctl(slave, I_PUSH, "ldterm");		/* push line discipline */
+	ioctl(subsid, I_PUSH, "ptem");	/* push pt hw emulation module */
+	ioctl(subsid, I_PUSH, "ldterm");	/* push line discipline */
 
-	(void) ioctl(slave, TCSETSF, (char *)&b);
-	(void) ioctl(slave, TIOCSWINSZ, (char *)&size);
+	(void) ioctl(subsid, TCSETSF, (char *)&b);
+	(void) ioctl(subsid, TIOCSWINSZ, (char *)&size);
 }
diff --git a/usr/src/cmd/truss/codes.c b/usr/src/cmd/truss/codes.c
index fd6e02bad6..21460008d4 100644
--- a/usr/src/cmd/truss/codes.c
+++ b/usr/src/cmd/truss/codes.c
@@ -1502,8 +1502,8 @@ const struct ioc {
 	{ (uint_t)IPTUN_GET_6TO4RELAY, "IPTUN_GET_6TO4RELAY",	NULL},
 
 	/* zcons ioctls */
-	{ (uint_t)ZC_HOLDSLAVE,		"ZC_HOLDSLAVE",		NULL },
-	{ (uint_t)ZC_RELEASESLAVE,	"ZC_RELEASESLAVE",	NULL },
+	{ (uint_t)ZC_HOLDSUBSID,	"ZC_HOLDSUBSID",	NULL },
+	{ (uint_t)ZC_RELEASESUBSID,	"ZC_RELEASESUBSID",	NULL },
 
 	/* hid ioctls - ('h' << 8) - hid.h */
 	{ (uint_t)HIDIOCKMGDIRECT,	"HIDIOCKMGDIRECT",	NULL },
diff --git a/usr/src/cmd/ttymon/parms.h b/usr/src/cmd/ttymon/parms.h
index b293eb45a2..9299147f7c 100644
--- a/usr/src/cmd/ttymon/parms.h
+++ b/usr/src/cmd/ttymon/parms.h
@@ -19,13 +19,12 @@
  *
  * CDDL HEADER END
  */
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
-
-#ident	"%Z%%M%	%I%	%E% SMI"	/* SVr4.0 1.3	*/
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
+/*	  All Rights Reserved */
 
 
+#ifndef _PARMS_H
+#define _PARMS_H
 
 /* If running SVR3, #define both ATTSVR3 and ATTSV */
 #define ATTSVR3	/* System V Release 3 */
@@ -155,8 +154,8 @@
 #define DEFAULT_BAUDRATE "9600"	/* */
 
 /*define permission modes for the device */
-#define M_DEVICEMODE (mode_t) 0600	/* MASTER device mode */
-#define S_DEVICEMODE (mode_t) 0600	/* SLAVE device mode */
+#define M_DEVICEMODE (mode_t) 0600	/* manager device mode */
+#define S_DEVICEMODE (mode_t) 0600	/* subsidiary device mode */
 #define R_DEVICEMODE (mode_t) 0600	/* default mode to restore */
 
 /* NO_MODEM_CTRL - define this if you have very old hardware
@@ -232,7 +231,7 @@
 /* define USRSPOOLLOCKS if you like your lock files in /var/spool/locks
  * be sure other programs such as 'cu' and 'ct' know about this
  *
- * WARNING: if you do not define USRSPOOLLOCKS, then $LOCK in 
+ * WARNING: if you do not define USRSPOOLLOCKS, then $LOCK in
  * uudemon.cleanup must be changed.
  */
 #define USRSPOOLLOCKS  /* define to use /var/spool/locks for LCK files */
@@ -241,3 +240,5 @@
  * this entails sleeping between reads at low baud rates.
  */
 #define PKSPEEDUP	/* */
+
+#endif /* !_PARMS_H */
diff --git a/usr/src/cmd/zoneadmd/zcons.c b/usr/src/cmd/zoneadmd/zcons.c
index 5f6fc4973c..5e49310655 100644
--- a/usr/src/cmd/zoneadmd/zcons.c
+++ b/usr/src/cmd/zoneadmd/zcons.c
@@ -57,7 +57,7 @@
  *                                  |     +-[Anchor]--+
  *                                  |     |   ptem    |
  *                                  V     +-----------+
- *                           +---master---+---slave---+
+ *                           +---manager--+-subsidiary+
  *                           |                        |
  *                           |      zcons driver      |
  *                           |    zonename="myzone"   |
@@ -71,7 +71,7 @@
  *   to online new instances of zcons as needed.  Care is taken to
  *   prune and manage these appropriately; see init_console_dev() and
  *   destroy_console_dev().  The end result is the creation of the
- *   zcons(7D) instance and an open file descriptor to the master side.
+ *   zcons(7D) instance and an open file descriptor to the manager side.
  *   zcons instances are associated with zones via their zonename device
  *   property.  This the console instance to persist across reboots,
  *   and while the zone is halted.
@@ -79,7 +79,7 @@
  * - Acting as a server for 'zlogin -C' instances.  When zlogin -C is
  *   run, zlogin connects to zoneadmd via unix domain socket.  zoneadmd
  *   functions as a two-way proxy for console I/O, relaying user input
- *   to the master side of the console, and relaying output from the
+ *   to the manager side of the console, and relaying output from the
  *   zone to the user.
  */
 
@@ -265,34 +265,35 @@ destroy_console_devs(zlog_t *zlogp)
 	char conspath[MAXPATHLEN];
 	di_node_t root;
 	struct cb_data cb;
-	int masterfd;
-	int slavefd;
+	int managerfd;
+	int subfd;
 
 	/*
-	 * Signal the master side to release its handle on the slave side by
-	 * issuing a ZC_RELEASESLAVE ioctl.
+	 * Signal the manager side to release its handle on the subsidiary side
+	 * by issuing a ZC_RELEASESUBSID ioctl.
 	 */
 	(void) snprintf(conspath, sizeof (conspath), "/dev/zcons/%s/%s",
-	    zone_name, ZCONS_MASTER_NAME);
-	if ((masterfd = open(conspath, O_RDWR | O_NOCTTY)) != -1) {
+	    zone_name, ZCONS_MANAGER_NAME);
+	if ((managerfd = open(conspath, O_RDWR | O_NOCTTY)) != -1) {
 		(void) snprintf(conspath, sizeof (conspath), "/dev/zcons/%s/%s",
-		    zone_name, ZCONS_SLAVE_NAME);
-		if ((slavefd = open(conspath, O_RDWR | O_NOCTTY)) != -1) {
-			if (ioctl(masterfd, ZC_RELEASESLAVE,
-			    (caddr_t)(intptr_t)slavefd) != 0)
+		    zone_name, ZCONS_SUBSIDIARY_NAME);
+		if ((subfd = open(conspath, O_RDWR | O_NOCTTY)) != -1) {
+			if (ioctl(managerfd, ZC_RELEASESUBSID,
+			    (caddr_t)(intptr_t)subfd) != 0)
 				zerror(zlogp, B_TRUE, "WARNING: error while "
-				    "releasing slave handle of zone console for"
-				    " %s", zone_name);
-			(void) close(slavefd);
+				    "releasing subsidiary handle of zone "
+				    "console for %s", zone_name);
+			(void) close(subfd);
 		} else {
-			zerror(zlogp, B_TRUE, "WARNING: could not open slave "
-			    "side of zone console for %s to release slave "
-			    "handle", zone_name);
+			zerror(zlogp, B_TRUE, "WARNING: could not open "
+			    "subsidiary side of zone console for %s to "
+			    "release subsidiary handle", zone_name);
 		}
-		(void) close(masterfd);
+		(void) close(managerfd);
 	} else {
-		zerror(zlogp, B_TRUE, "WARNING: could not open master side of "
-		    "zone console for %s to release slave handle", zone_name);
+		zerror(zlogp, B_TRUE, "WARNING: could not open manager side of "
+		    "zone console for %s to release subsidiary handle",
+		    zone_name);
 	}
 
 	bzero(&cb, sizeof (cb));
@@ -323,8 +324,8 @@ destroy_console_devs(zlog_t *zlogp)
  * sanity checking, and are careful to reuse a console if one exists.
  *
  * Once the device is in the device tree, we kick devfsadm via di_init_devs()
- * to ensure that the appropriate symlinks (to the master and slave console
- * devices) are placed in /dev in the global zone.
+ * to ensure that the appropriate symlinks (to the manager and subsidiary
+ * console devices) are placed in /dev in the global zone.
  */
 static int
 init_console_dev(zlog_t *zlogp)
@@ -336,8 +337,8 @@ init_console_dev(zlog_t *zlogp)
 	di_devlink_handle_t dl = NULL;
 	int rv = -1;
 	int ndevs;
-	int masterfd;
-	int slavefd;
+	int managerfd;
+	int subfd;
 	int i;
 
 	/*
@@ -405,23 +406,26 @@ devlinks:
 	}
 
 	/*
-	 * Open the master side of the console and issue the ZC_HOLDSLAVE ioctl,
-	 * which will cause the master to retain a reference to the slave.
-	 * This prevents ttymon from blowing through the slave's STREAMS anchor.
+	 * Open the manager side of the console and issue the ZC_HOLDSUBSID
+	 * ioctl, which will cause the manager to retain a reference to the
+	 * subsidiary.  This prevents ttymon from blowing through the
+	 * subsidiary's STREAMS anchor.
 	 */
 	(void) snprintf(conspath, sizeof (conspath), "/dev/zcons/%s/%s",
-	    zone_name, ZCONS_MASTER_NAME);
-	if ((masterfd = open(conspath, O_RDWR | O_NOCTTY)) == -1) {
-		zerror(zlogp, B_TRUE, "ERROR: could not open master side of "
-		    "zone console for %s to acquire slave handle", zone_name);
+	    zone_name, ZCONS_MANAGER_NAME);
+	if ((managerfd = open(conspath, O_RDWR | O_NOCTTY)) == -1) {
+		zerror(zlogp, B_TRUE, "ERROR: could not open manager side of "
+		    "zone console for %s to acquire subsidiary handle",
+		    zone_name);
 		goto error;
 	}
 	(void) snprintf(conspath, sizeof (conspath), "/dev/zcons/%s/%s",
-	    zone_name, ZCONS_SLAVE_NAME);
-	if ((slavefd = open(conspath, O_RDWR | O_NOCTTY)) == -1) {
-		zerror(zlogp, B_TRUE, "ERROR: could not open slave side of zone"
-		    " console for %s to acquire slave handle", zone_name);
-		(void) close(masterfd);
+	    zone_name, ZCONS_SUBSIDIARY_NAME);
+	if ((subfd = open(conspath, O_RDWR | O_NOCTTY)) == -1) {
+		zerror(zlogp, B_TRUE, "ERROR: could not open subsidiary side "
+		    "of zone console for %s to acquire subsidiary handle",
+		    zone_name);
+		(void) close(managerfd);
 		goto error;
 	}
 	/*
@@ -430,7 +434,7 @@ devlinks:
 	 * 1 sec. and retry a few times before we fail to boot the zone.
 	 */
 	for (i = 0; i < 5; i++) {
-		if (ioctl(masterfd, ZC_HOLDSLAVE, (caddr_t)(intptr_t)slavefd)
+		if (ioctl(managerfd, ZC_HOLDSUBSID, (caddr_t)(intptr_t)subfd)
 		    == 0) {
 			rv = 0;
 			break;
@@ -440,11 +444,11 @@ devlinks:
 		(void) sleep(1);
 	}
 	if (rv != 0)
-		zerror(zlogp, B_TRUE, "ERROR: error while acquiring slave "
-		    "handle of zone console for %s", zone_name);
+		zerror(zlogp, B_TRUE, "ERROR: error while acquiring "
+		    "subsidiary handle of zone console for %s", zone_name);
 
-	(void) close(slavefd);
-	(void) close(masterfd);
+	(void) close(subfd);
+	(void) close(managerfd);
 
 error:
 	if (ddef_hdl)
@@ -700,7 +704,7 @@ test_client(int clifd)
 
 /*
  * This routine drives the console I/O loop.  It polls for input from the
- * master side of the console (output to the console), and from the client
+ * manager side of the console (output to the console), and from the client
  * (input from the console user).  Additionally, it polls on the server fd,
  * and disconnects any clients that might try to hook up with the zone while
  * the console is in use.
@@ -904,17 +908,17 @@ init_console(zlog_t *zlogp)
 void
 serve_console(zlog_t *zlogp)
 {
-	int masterfd;
+	int managerfd;
 	zone_state_t zstate;
 	char conspath[MAXPATHLEN];
 
 	(void) snprintf(conspath, sizeof (conspath),
-	    "/dev/zcons/%s/%s", zone_name, ZCONS_MASTER_NAME);
+	    "/dev/zcons/%s/%s", zone_name, ZCONS_MANAGER_NAME);
 
 	for (;;) {
-		masterfd = open(conspath, O_RDWR|O_NONBLOCK|O_NOCTTY);
-		if (masterfd == -1) {
-			zerror(zlogp, B_TRUE, "failed to open console master");
+		managerfd = open(conspath, O_RDWR|O_NONBLOCK|O_NOCTTY);
+		if (managerfd == -1) {
+			zerror(zlogp, B_TRUE, "failed to open console manager");
 			(void) mutex_lock(&lock);
 			goto death;
 		}
@@ -926,14 +930,14 @@ serve_console(zlog_t *zlogp)
 		 * messages, we wouldn't be able to use read(2), as it fails
 		 * (EBADMSG) when a message with a control element is received.
 		 */
-		if (ioctl(masterfd, I_SRDOPT, RNORM|RPROTDIS) == -1) {
+		if (ioctl(managerfd, I_SRDOPT, RNORM|RPROTDIS) == -1) {
 			zerror(zlogp, B_TRUE, "failed to set options on "
-			    "console master");
+			    "console manager");
 			(void) mutex_lock(&lock);
 			goto death;
 		}
 
-		do_console_io(zlogp, masterfd, serverfd);
+		do_console_io(zlogp, managerfd, serverfd);
 
 		/*
 		 * We would prefer not to do this, but hostile zone processes
@@ -942,7 +946,7 @@ serve_console(zlog_t *zlogp)
 		 * we dismantle the stream and reopen the console when we
 		 * take another lap.
 		 */
-		(void) close(masterfd);
+		(void) close(managerfd);
 
 		(void) mutex_lock(&lock);
 		/*
diff --git a/usr/src/man/man1m/in.rlogind.1m b/usr/src/man/man1m/in.rlogind.1m
index fdddcee08d..4504cd5c8a 100644
--- a/usr/src/man/man1m/in.rlogind.1m
+++ b/usr/src/man/man1m/in.rlogind.1m
@@ -4,7 +4,7 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH IN.RLOGIND 1M "June 20, 2021"
+.TH IN.RLOGIND 1M "February 5, 2022"
 .SH NAME
 in.rlogind, rlogind \- remote login server
 .SH SYNOPSIS
@@ -82,9 +82,9 @@ client is present in  \fB/etc/hosts.equiv\fR. See \fBhosts\fR(4) and
 .sp
 .LP
 Once the source port and address have been checked, \fBin.rlogind\fR allocates
-a pseudo-terminal and manipulates file descriptors so that the slave half of
-the pseudo-terminal becomes the \fBstdin\fR, \fBstdout\fR, and \fBstderr\fR for
-a login process. The login process is an instance of the \fBlogin\fR(1)
+a pseudo-terminal and manipulates file descriptors so that the subsidiary half
+of the pseudo-terminal becomes the \fBstdin\fR, \fBstdout\fR, and \fBstderr\fR
+for a login process.  The login process is an instance of the \fBlogin\fR(1)
 program, invoked with the \fB-r\fR.
 .sp
 .LP
@@ -93,7 +93,7 @@ process. See \fBSECURITY\fR below.  If automatic authentication fails, it
 reprompts the user to login.
 .sp
 .LP
-The parent of the login process manipulates the master side of the
+The parent of the login process manipulates the manager side of the
 pseudo-terminal, operating as an intermediary between the login process and the
 client instance of the \fBrlogin\fR program.  In normal operation, a packet
 protocol is invoked to provide Ctrl-S and Ctrl-Q type facilities and propagate
diff --git a/usr/src/man/man1m/in.telnetd.1m b/usr/src/man/man1m/in.telnetd.1m
index c233dccf49..b736fa082a 100644
--- a/usr/src/man/man1m/in.telnetd.1m
+++ b/usr/src/man/man1m/in.telnetd.1m
@@ -4,7 +4,7 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH IN.TELNETD 1M "June 20, 2021"
+.TH IN.TELNETD 1M "February 5, 2022"
 .SH NAME
 in.telnetd, telnetd \- DARPA TELNET protocol server
 .SH SYNOPSIS
@@ -22,10 +22,11 @@ the internet server (see \fBinetd\fR(1M)), for requests to connect to the
 .sp
 .LP
 \fBin.telnetd\fR operates by allocating a pseudo-terminal device for a client,
-then creating a login process which has the slave side of the pseudo-terminal
-as its standard input, output, and error. \fBin.telnetd\fR manipulates the
-master side of the pseudo-terminal, implementing the \fBTELNET\fR protocol and
-passing characters between the remote client and the login process.
+then creating a login process which has the subsidiary side of the
+pseudo-terminal as its standard input, output, and error. \fBin.telnetd\fR
+manipulates the manager side of the pseudo-terminal, implementing the
+\fBTELNET\fR protocol and passing characters between the remote client and the
+login process.
 .sp
 .LP
 When a \fBTELNET\fR session starts up, \fBin.telnetd\fR sends \fBTELNET\fR
diff --git a/usr/src/man/man1m/pppd.1m b/usr/src/man/man1m/pppd.1m
index 8862ee9b94..4a2bdb360d 100644
--- a/usr/src/man/man1m/pppd.1m
+++ b/usr/src/man/man1m/pppd.1m
@@ -3,7 +3,7 @@
 .\" Redistribution and use in source and binary forms are permitted provided that the above copyright notice and this paragraph are duplicated in all such forms and that any documentation, advertising materials, and other materials related to such distribution and use acknowledge that the software was developed by Carnegie Mellon University.  The name of the University may not be used to endorse or promote products derived from this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 .\" WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\" Portions Copyright (c) 2008, Sun Microsystems, Inc. All Right Reserved.
-.TH PPPD 1M "November 22, 2021"
+.TH PPPD 1M "February 5, 2022"
 .SH NAME
 pppd \- point to point protocol daemon
 .SH SYNOPSIS
@@ -1301,11 +1301,11 @@ proxy ARP entries with \fBpppd\fR, place this option in the
 .sp .6
 .RS 4n
 Normally, \fBpppd\fR requires a terminal device. With this option, \fBpppd\fR
-allocates itself a pseudo-tty master/slave pair and uses the slave as its
+allocates itself a pseudo-terminal pair and uses the subsidiary as its
 terminal device. \fBpppd\fR creates a child process to act as a character shunt
-to transfer characters between the pseudo-tty master and its standard input and
-output. Thus, \fBpppd\fR transmits characters on its standard output and
-receives characters on its standard input even if they are not terminal
+to transfer characters between the pseudo-terminal manager and its standard
+input and output. Thus, \fBpppd\fR transmits characters on its standard output
+and receives characters on its standard input even if they are not terminal
 devices. This option increases the latency and CPU overhead of transferring
 data over the ppp interface as all of the characters sent and received must
 flow through the character shunt process. An explicit device name may not be
@@ -1506,12 +1506,12 @@ Ethernet interface.
 .sp .6
 .RS 4n
 Specifies that the command \fIscript\fR, and not a specific terminal device is
-used for serial communication. \fBpppd\fR allocates itself a pseudo-tty
-master/slave pair and uses the slave as its terminal device. \fIscript\fR runs
-in a child process with the pseudo-tty master as its standard input and output.
-An explicit device name may not be given if this option is used. (Note: if the
-\fBrecord\fR option is used in conjunction with the \fBpty\fR option, the child
-process will have pipes on its standard input and output.)
+used for serial communication. \fBpppd\fR allocates itself a pseudo-terminal
+pair and uses the subsidiary as its terminal device. \fIscript\fR runs
+in a child process with the pseudo-terminal manager as its standard input and
+output.  An explicit device name may not be given if this option is used.
+(Note: if the \fBrecord\fR option is used in conjunction with the \fBpty\fR
+option, the child process will have pipes on its standard input and output.)
 .RE
 
 .sp
@@ -1537,14 +1537,14 @@ dial-back implementations.
 .RS 4n
 Directs \fBpppd\fR to record all characters sent and received to a file named
 \fIfilename\fR. \fIfilename\fR is opened in append mode, using the user's
-user-ID and permissions. Because this option uses a pseudo-tty and a process to
-transfer characters between the pseudo-tty and the real serial device, it
-increases the latency and CPU overhead of transferring data over the PPP
-interface. Characters are stored in a tagged format with timestamps that can be
-displayed in readable form using the \fBpppdump\fR(1M) program. This option is
-generally used when debugging the kernel portion of \fBpppd\fR (especially CCP
-compression algorithms) and not for debugging link configuration problems. See
-the \fBdebug\fR option.
+user-ID and permissions. Because this option uses a pseudo-terminal and a
+process to transfer characters between the pseudo-terminal and the real serial
+device, it increases the latency and CPU overhead of transferring data over the
+PPP interface. Characters are stored in a tagged format with timestamps that
+can be displayed in readable form using the \fBpppdump\fR(1M) program. This
+option is generally used when debugging the kernel portion of \fBpppd\fR
+(especially CCP compression algorithms) and not for debugging link
+configuration problems. See the \fBdebug\fR option.
 .RE
 
 .sp
diff --git a/usr/src/man/man2/close.2 b/usr/src/man/man2/close.2
index ad1ff95b8f..281a3f8956 100644
--- a/usr/src/man/man2/close.2
+++ b/usr/src/man/man2/close.2
@@ -43,173 +43,193 @@
 .\" Copyright 1989 AT&T
 .\" Portions Copyright (c) 1992, X/Open Company Limited.  All Rights Reserved.
 .\" Copyright (c) 2005, Sun Microsystems, Inc.  All Rights Reserved.
+.\" Copyright 2022 Oxide Computer Company
 .\"
-.TH CLOSE 2 "Oct 18, 2005"
-.SH NAME
-close \- close a file descriptor
-.SH SYNOPSIS
-.LP
-.nf
-#include <unistd.h>
-
-\fBint\fR \fBclose\fR(\fBint\fR \fIfildes\fR);
-.fi
-
-.SH DESCRIPTION
-.sp
-.LP
-The \fBclose()\fR function deallocates the file descriptor indicated by
-\fIfildes\fR. To deallocate means to make the file descriptor available for
-return by subsequent calls to \fBopen\fR(2) or other functions that allocate
-file descriptors. All outstanding record locks owned by the process on the file
-associated with the file descriptor will be removed (that is, unlocked).
-.sp
-.LP
-If \fBclose()\fR is interrupted by a signal that is to be caught, it will
-return \fB\(mi1\fR with \fBerrno\fR set to \fBEINTR\fR and the state of
-\fIfildes\fR is unspecified. If an I/O error occurred while reading from or
-writing to the file system during \fBclose()\fR, it returns -1, sets
-\fBerrno\fR to \fBEIO\fR, and the state of \fIfildes\fR is unspecified.
-.sp
-.LP
-When all file descriptors associated with a pipe or \fBFIFO\fR special file are
-closed, any data remaining in the pipe or \fBFIFO\fR will be discarded.
-.sp
-.LP
+.Dd February 5, 2022
+.Dt CLOSE 2
+.Os
+.Sh NAME
+.Nm close
+.Nd close a file descriptor
+.Sh SYNOPSIS
+.In unistd.h
+.Ft int
+.Fo close
+.Fa "int fildes"
+.Fc
+.Sh DESCRIPTION
+The
+.Fn close
+function deallocates the file descriptor indicated by
+.Fa fildes .
+To deallocate means to make the file descriptor available for return by
+subsequent calls to
+.Xr open 2
+or other functions that allocate file descriptors.
+All outstanding record locks owned by the process on the file associated with
+the file descriptor will be removed
+.Pq "that is, unlocked" .
+.Pp
+If
+.Fn close
+is interrupted by a signal that is to be caught, it will return
+.Sy -1
+with
+.Va errno
+set to
+.Er EINTR
+and the state of
+.Fa fildes
+is unspecified.
+If an I/O error occurred while reading from or writing to the file system during
+.Fn close ,
+it returns
+.Sy -1 ,
+sets
+.Va errno
+to
+.Er EIO ,
+and the state of
+.Fa fildes
+is unspecified.
+.Pp
+When all file descriptors associated with a pipe or FIFO special file are
+closed, any data remaining in the pipe or FIFO will be discarded.
+.Pp
 When all file descriptors associated with an open file description have been
 closed the open file description will be freed.
-.sp
-.LP
-If the link count of the file is 0, when all file descriptors associated with
-the file are closed, the space occupied by the file will be freed and the file
-will no longer be accessible.
-.sp
-.LP
-If a streams-based (see \fBIntro\fR(2)) \fIfildes\fR is closed and the calling
-process was previously registered to receive a \fBSIGPOLL\fR signal (see
-\fBsignal\fR(3C)) for events associated with that stream (see \fBI_SETSIG\fR in
-\fBstreamio\fR(7I)), the calling process will be unregistered for events
-associated with the stream.  The last \fBclose()\fR for a stream causes the
-stream associated with \fIfildes\fR to be dismantled. If \fBO_NONBLOCK\fR and
-\fBO_NDELAY\fR are not set and there have been no signals posted for the
-stream, and if there is data on the module's write queue, \fBclose()\fR waits
-up to 15 seconds (for each module and driver) for any output to drain before
-dismantling the stream. The time delay can be changed via an \fBI_SETCLTIME\fR
-\fBioctl\fR(2) request (see \fBstreamio\fR(7I)). If the \fBO_NONBLOCK\fR or
-\fBO_NDELAY\fR flag is set, or if there are any pending signals, \fBclose()\fR
+.Pp
+If the link count of the file is
+.Sy 0 ,
+when all file descriptors associated with the file are closed, the space
+occupied by the file will be freed and the file will no longer be accessible.
+.Pp
+If a streams-based
+.Po
+see
+.Xr Intro 2
+.Pc
+.Fa fildes
+is closed and the calling process was previously registered to receive a
+.Dv SIGPOLL
+signal
+.Po
+see
+.Xr signal 3C
+.Pc
+for events associated with that stream
+.Po
+see
+.Dv I_SETSIG
+in
+.Xr streamio 7I
+.Pc ,
+the calling process will be unregistered for events associated with the stream.
+The last
+.Fn close
+for a stream causes the stream associated with
+.Fa fildes
+to be dismantled.
+If
+.Dv O_NONBLOCK
+and
+.Dv O_NDELAY
+are not set and there have been no signals posted for the stream, and if there
+is data on the module's write queue,
+.Fn close
+waits up to 15 seconds
+.Pq for each module and driver
+for any output to drain
+before dismantling the stream.
+The time delay can be changed via an
+.Dv I_SETCLTIME
+.Xr ioctl 2
+request
+.Po
+see
+.Xr streamio 7I
+.Pc .
+If the
+.Dv O_NONBLOCK
+or
+.Dv O_NDELAY
+flag is set, or if there are any pending signals,
+.Fn close
 does not wait for output to drain, and dismantles the stream immediately.
-.sp
-.LP
-If \fIfildes\fR is associated with one end of a pipe, the last \fBclose()\fR
-causes a hangup to occur on the other end of the pipe.  In addition, if the
-other end of the pipe has been named by \fBfattach\fR(3C), then the last
-\fBclose()\fR forces the named end to be detached by \fBfdetach\fR(3C). If the
-named end has no open file descriptors associated with it and gets detached,
-the stream associated with that end is also dismantled.
-.sp
-.LP
-If \fIfildes\fR refers to the master side of a pseudo-terminal, a \fBSIGHUP\fR
-signal is sent to the session leader, if any, for which the slave side of the
-pseudo-terminal is the controlling terminal. It is unspecified whether closing
-the master side of the pseudo-terminal flushes all queued input and output.
-.sp
-.LP
-If \fIfildes\fR refers to the slave side of a streams-based pseudo-terminal, a
-zero-length message may be sent to the master.
-.sp
-.LP
+.Pp
+If
+.Fa fildes
+is associated with one end of a pipe, the last
+.Fn close
+causes a hangup to occur on the other end of the pipe.
+In addition, if the other end of the pipe has been named by
+.Xr fattach 3C ,
+then the last
+.Fn close
+forces the named end to be detached by
+.Xr fdetach 3C .
+If the named end has no open file descriptors associated with it and gets
+detached, the stream associated with that end is also dismantled.
+.Pp
+If
+.Fa fildes
+refers to the manager side of a pseudo-terminal, a
+.Dv SIGHUP
+signal is sent to the session leader, if any, for which the subsidiary side of
+the pseudo-terminal is the controlling terminal.
+It is unspecified whether closing the manager side of the pseudo-terminal
+flushes all queued input and output.
+.Pp
+If
+.Fa fildes
+refers to the subsidiary side of a streams-based pseudo-terminal, a zero-length
+message may be sent to the manager.
+.Pp
 When there is an outstanding cancelable asynchronous I/O operation against
-\fIfildes\fR when \fBclose()\fR is called, that I/O operation is canceled. An
-I/O operation that is not canceled completes as if the \fBclose()\fR operation
-had not yet occurred. All operations that are not canceled will complete as if
-the \fBclose()\fR blocked until the operations completed.
-.sp
-.LP
+.Fa fildes
+when
+.Fn close
+is called, that I/O operation is canceled.
+An I/O operation that is not canceled completes as if the
+.Fn close
+operation had not yet occurred.
+All operations that are not canceled will complete as if the
+.Fn close
+blocked until the operations completed.
+.Pp
 If a shared memory object or a memory mapped file remains referenced at the
-last close (that is, a process has it mapped), then the entire contents of the
-memory object will persist until the memory object becomes unreferenced. If
-this is the last close of a shared memory object or a memory mapped file and
+last close
+.Pq "that is, a process has it mapped" ,
+then the entire contents of the memory object will persist until the memory
+object becomes unreferenced.
+If this is the last close of a shared memory object or a memory mapped file and
 the close results in the memory object becoming unreferenced, and the memory
 object has been unlinked, then the memory object will be removed.
-.sp
-.LP
-If \fIfildes\fR refers to a socket, \fBclose()\fR causes the socket to be
-destroyed.  If the socket is connection-mode, and the \fBSO_LINGER\fR option is
-set for the socket with non-zero linger time, and the socket has untransmitted
-data, then \fBclose()\fR will block for up to the current linger interval until
-all data is transmitted.
-.SH RETURN VALUES
-.sp
-.LP
-Upon successful completion, \fB0\fR is returned. Otherwise, \fB\(mi1\fR is
-returned and \fBerrno\fR is set to indicate the error.
-.SH ERRORS
-.sp
-.LP
-The \fBclose()\fR function will fail if:
-.sp
-.ne 2
-.na
-\fB\fBEBADF\fR\fR
-.ad
-.RS 11n
-The \fIfildes\fR argument is not a valid file descriptor.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEINTR\fR\fR
-.ad
-.RS 11n
-The \fBclose()\fR function was interrupted by a signal.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOLINK\fR\fR
-.ad
-.RS 11n
-The \fIfildes\fR argument is on a remote machine and the link to that machine
-is no longer active.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOSPC\fR\fR
-.ad
-.RS 11n
-There was no free space remaining on the device containing the file.
-.RE
-
-.sp
-.LP
-The \fBclose()\fR function may fail if:
-.sp
-.ne 2
-.na
-\fB\fBEIO\fR\fR
-.ad
-.RS 7n
-An I/O error occurred while reading from or writing to the file system.
-.RE
-
-.SH EXAMPLES
-.LP
-\fBExample 1 \fRReassign a file descriptor.
-.sp
-.LP
+.Pp
+If
+.Fa fildes
+refers to a socket,
+.Fn close
+causes the socket to be destroyed.
+If the socket is connection-mode, and the
+.Dv SO_LINGER
+option is set for the socket with non-zero linger time, and the socket has
+untransmitted data, then
+.Fn close
+will block for up to the current linger interval until all data is transmitted.
+.Sh RETURN VALUES
+.Rv -std close
+.Sh EXAMPLES
+.Sy Example 1
+Reassign a file descriptor.
+.Pp
 The following example closes the file descriptor associated with standard
 output for the current process, re-assigns standard output to a new file
-descriptor, and closes the original file descriptor to clean up. This example
-assumes that the file descriptor 0, which is the descriptor for standard input,
-is not closed.
-
-.sp
-.in +2
-.nf
+descriptor, and closes the original file descriptor to clean up.
+This example assumes that the file descriptor
+.Sy 0 ,
+which is the descriptor for standard input, is not closed.
+.Bd -literal -offset Ds
 #include <unistd.h>
 \&...
 int pfd;
@@ -218,32 +238,22 @@ close(1);
 dup(pfd);
 close(pfd);
 \&...
-.fi
-.in -2
-
-.sp
-.LP
+.Ed
+.Pp
 Incidentally, this is exactly what could be achieved using:
-
-.sp
-.in +2
-.nf
+.Bd -literal -offset Ds
 dup2(pfd, 1);
 close(pfd);
-.fi
-.in -2
-
-.LP
-\fBExample 2 \fRClose a file descriptor.
-.sp
-.LP
-In the following example, \fBclose()\fR is used to close a file descriptor
-after an unsuccessful attempt is made to associate that file descriptor with a
-stream.
-
-.sp
-.in +2
-.nf
+.Ed
+.Pp
+.Sy Example 2
+Close a file descriptor.
+.Pp
+In the following example,
+.Fn close
+is used to close a file descriptor after an unsuccessful attempt is made to
+associate that file descriptor with a stream.
+.Bd -literal -offset Ds
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
@@ -259,38 +269,64 @@ if ((fpfd = fdopen (pfd, "w")) == NULL) {
         exit(1);
 }
 \&...
-.fi
-.in -2
-
-.SH USAGE
-.sp
-.LP
-An application that used the \fBstdio\fR function \fBfopen\fR(3C) to open a
-file should use the corresponding \fBfclose\fR(3C) function rather than
-\fBclose()\fR.
-.SH ATTRIBUTES
-.sp
-.LP
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
-Interface Stability	Standard
-_
-MT-Level	Async-Signal-Safe
-.TE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBIntro\fR(2), \fBcreat\fR(2), \fBdup\fR(2), \fBexec\fR(2), \fBfcntl\fR(2),
-\fBioctl\fR(2), \fBopen\fR(2) \fBpipe\fR(2), \fBfattach\fR(3C),
-\fBfclose\fR(3C), \fBfdetach\fR(3C), \fBfopen\fR(3C), \fBsignal\fR(3C),
-\fBsignal.h\fR(3HEAD), \fBattributes\fR(5), \fBstandards\fR(5),
-\fBstreamio\fR(7I)
+.Ed
+.Sh ERRORS
+The
+.Fn close
+function will fail if:
+.Bl -tag -width Er
+.It Er EBADF
+The
+.Fa fildes
+argument is not a valid file descriptor.
+.It Er EINTR
+The
+.Fn close
+function was interrupted by a signal.
+.It Er ENOLINK
+The
+.Fa fildes
+argument is on a remote machine and the link to that machine is no longer
+active.
+.It Er ENOSPC
+There was no free space remaining on the device containing the file.
+.El
+.Pp
+The
+.Fn close
+function may fail if:
+.Bl -tag -width Er
+.It Er EIO
+An I/O error occurred while reading from or writing to the file system.
+.El
+.Sh USAGE
+An application that used the
+.Xr stdio 3C
+function
+.Xr fopen 3C
+to open a file should use the corresponding
+.Xr fclose 3C
+function rather than
+.Fn close .
+.Sh INTERFACE STABILITY
+.Sy Committed
+.Sh MT-LEVEL
+.Sy Async-Signal-Safe
+.Sh SEE ALSO
+.Xr creat 2 ,
+.Xr dup 2 ,
+.Xr exec 2 ,
+.Xr fcntl 2 ,
+.Xr Intro 2 ,
+.Xr ioctl 2 ,
+.Xr open 2 ,
+.Xr pipe 2 ,
+.Xr fattach 3C ,
+.Xr fclose 3C ,
+.Xr fdetach 3C ,
+.Xr fopen 3C ,
+.Xr signal 3C ,
+.Xr signal.h 3HEAD ,
+.Xr attributes 5 ,
+.Xr standards 5 ,
+.Xr streamio 7I
diff --git a/usr/src/man/man2/open.2 b/usr/src/man/man2/open.2
index aa9048c660..ce23eac084 100644
--- a/usr/src/man/man2/open.2
+++ b/usr/src/man/man2/open.2
@@ -47,879 +47,586 @@
 .\" All Rights Reserved.
 .\" Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
 .\" Copyright 2020 Joyent, Inc.
+.\" Copyright 2022 Oxide Computer Company
 .\"
-.TH OPEN 2 "Mar 10, 2020"
-.SH NAME
-open, openat \- open a file
-.SH SYNOPSIS
-.nf
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
-\fBint\fR \fBopen\fR(\fBconst char *\fR\fIpath\fR, \fBint\fR \fIoflag\fR, \fB/* mode_t\fR \fImode\fR */);
-.fi
-
-.LP
-.nf
-\fBint\fR \fBopenat\fR(\fBint\fR \fIfildes\fR, \fBconst char *\fR\fIpath\fR, \fBint\fR \fIoflag\fR,
-     \fB/* mode_t\fR \fImode\fR */);
-.fi
-
-.SH DESCRIPTION
-The \fBopen()\fR function establishes the connection between a file and a file
-descriptor. It creates an open file description that refers to a file and a
-file descriptor that refers to that open file description. The file descriptor
-is used by other I/O functions to refer to that file. The \fIpath\fR argument
-points to a pathname naming the file.
-.sp
-.LP
-The \fBopenat()\fR function is identical to the \fBopen()\fR function except
-that the \fIpath\fR argument is interpreted relative to the starting point
-implied by the \fIfildes\fR argument. If the \fIfildes\fR argument has the
-special value \fBAT_FDCWD\fR, a relative path argument will be resolved
-relative to the current working directory. If the \fIpath\fR argument is
-absolute, the \fIfildes\fR argument is ignored.
-.sp
-.LP
-The \fBopen()\fR function returns a file descriptor for the named file that is
-the lowest file descriptor not currently open for that process. The open file
-description is new, and therefore the file descriptor does not share it with
-any other process in the system. The \fBFD_CLOEXEC\fR file descriptor flag
-associated with the new file descriptor is cleared.
-.sp
-.LP
+.Dd February 5, 2022
+.Dt OPEN 2
+.Os
+.Sh NAME
+.Nm open ,
+.Nm openat
+.Nd open a file
+.Sh SYNOPSIS
+.In sys/types.h
+.In sys/stat.h
+.In fcntl.h
+.Ft int
+.Fo open
+.Fa "const char *path"
+.Fa "int oflag"
+.Op , Fa "mode_t mode"
+.Fc
+.Ft int
+.Fo openat
+.Fa "int fildes"
+.Fa "const char *path"
+.Fa "int oflag"
+.Op , Fa "mode_t mode"
+.Fc
+.Sh DESCRIPTION
+The
+.Fn open
+function establishes the connection between a file and a file descriptor.
+It creates an open file description that refers to a file and a file descriptor
+that refers to that open file description.
+The file descriptor is used by other I/O functions to refer to that file.
+The
+.Fa path
+argument points to a pathname naming the file.
+.Pp
+The
+.Fn openat
+function is identical to the
+.Fn open
+function except
+that the
+.Fa path
+argument is interpreted relative to the starting point
+implied by the
+.Fa fildes
+argument.
+If the
+.Fa fildes
+argument has the special value
+.Dv AT_FDCWD ,
+a relative path argument will be resolved relative to the current working
+directory.
+If the
+.Fa path
+argument is absolute, the
+.Fa fildes
+argument is ignored.
+.Pp
+The
+.Fn open
+function returns a file descriptor for the named file that is the lowest file
+descriptor not currently open for that process.
+The open file description is new, and therefore the file descriptor does not
+share it with any other process in the system.
+The
+.Dv FD_CLOEXEC
+file descriptor flag associated with the new file descriptor is cleared.
+.Pp
 The file offset used to mark the current position within the file is set to the
 beginning of the file.
-.sp
-.LP
+.Pp
 The file status flags and file access modes of the open file description are
-set according to the value of \fIoflag\fR. The \fImode\fR argument is used only
-when \fBO_CREAT\fR is specified (see below.)
-.sp
-.LP
-Values for \fIoflag\fR are constructed by a bitwise-inclusive-OR of flags from
-the following list, defined in <\fBfcntl.h\fR>. Applications must specify
-exactly one of the first three values (file access modes) below in the value of
-\fIoflag\fR:
-.sp
-.ne 2
-.na
-\fB\fBO_RDONLY\fR\fR
-.ad
-.RS 12n
+set according to the value of
+.Fa oflag .
+The
+.Fa mode
+argument is used only
+when
+.Dv O_CREAT
+is specified
+.Pq "see below" .
+.Pp
+Values for
+.Fa oflag
+are constructed by a bitwise-inclusive-OR of flags from
+the following list, defined in
+.Xr fcntl.h 3HEAD .
+Applications must specify exactly one of the first three values (file access
+modes) below in the value of
+.Fa oflag :
+.Bl -tag -width Ds
+.It Dv O_RDONLY
 Open for reading only.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_WRONLY\fR\fR
-.ad
-.RS 12n
+.It Dv O_WRONLY
 Open for writing only.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_RDWR\fR\fR
-.ad
-.RS 12n
-Open for reading and writing. The result is undefined if this flag is applied
-to a FIFO.
-.RE
-
-.sp
-.LP
+.It Dv O_RDWR
+Open for reading and writing.
+The result is undefined if this flag is applied to a FIFO.
+.El
+.Pp
 Any combination of the following may be used:
-.sp
-.ne 2
-.na
-\fB\fBO_APPEND\fR\fR
-.ad
-.sp .6
-.RS 4n
+.Bl -tag -width Ds
+.It Dv O_APPEND
 If set, the file offset is set to the end of the file prior to each write.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_CREAT\fR\fR
-.ad
-.sp .6
-.RS 4n
-Create the file if it does not exist. This flag requires that the \fImode\fR
+.It Dv O_CREAT
+Create the file if it does not exist.
+This flag requires that the
+.Fa mode
 argument be specified.
-.sp
-If the file exists, this flag has no effect except as noted under \fBO_EXCL\fR
-below.  Otherwise, the file is created with the user \fBID\fR of the file set
-to the effective user \fBID\fR of the process. The group \fBID\fR of the file
-is set to the effective group \fBIDs\fR of the process, or if the \fBS_ISGID\fR
+.Pp
+If the file exists, this flag has no effect except as noted under
+.Dv O_EXCL
+below.
+Otherwise, the file is created with the user ID of the file set to the
+effective user ID of the process.
+The group ID of the file is set to the effective group IDs of the process, or
+if the
+.Dv S_ISGID
 bit is set in the directory in which the file is being created, the file's
-group \fBID\fR is set to the group \fBID\fR of its parent directory.  If the
-group \fBID\fR of the new file does not match the effective group \fBID\fR or
-one of the supplementary groups IDs, the \fBS_ISGID\fR bit is cleared. The
-access permission bits (see \fB<sys/stat.h>\fR) of the file mode are set to the
-value of \fImode\fR, modified as follows (see \fBcreat\fR(2)): a bitwise-AND is
-performed on the file-mode bits and the corresponding bits in the complement of
-the process's file mode creation mask. Thus, all bits set in the process's file
-mode creation mask (see \fBumask\fR(2)) are correspondingly cleared in the
-file's permission mask. The "save text image after execution bit" of the mode
-is cleared (see \fBchmod\fR(2)). When bits other than the file permission bits
-are set, the effect is unspecified. The \fImode\fR argument does not affect
-whether the file is open for reading, writing or for both.
-.RE
-
-.sp
-.ne 2
-.na
-.B O_DIRECT
-.ad
-.sp .6
-.RS 4n
+group ID is set to the group ID of its parent directory.
+If the group ID of the new file does not match the effective group
+ID or one of the supplementary groups IDs, the
+.Dv S_ISGID bit is cleared.
+.Pp
+The access permission bits
+.Po
+see
+.Xr stat.h 3HEAD
+.Pc
+of the file mode are set to the value of
+.Fa mode ,
+modified as follows
+.Po
+see
+.Xr creat 2
+.Pc :
+a bitwise-AND is performed on the file-mode bits and the corresponding bits in
+the complement of the process's file mode creation mask.
+Thus, all bits set in the process's file mode creation mask
+.Po
+see
+.Xr umask 2
+.Pc
+are correspondingly cleared in the file's permission mask.
+The
+.Dq save text image after execution bit
+of the mode is cleared
+.Po
+see
+.Xr chmod 2
+.Pc .
+When bits other than the file permission bits are set, the effect is
+unspecified.
+The
+.Fa mode
+argument does not affect whether the file is open for reading, writing or for
+both.
+.It Dv O_DIRECT
 Indicates that the file data is not going to be reused in the near future.
 When possible, data is read or written directly between the application's
-memory and the device when the data is accessed with \fBread\fR(2) and
-\fBwrite\fR(2) operations. See \fBdirectio\fR(3C) for more details.
-.RE
-
-.sp
-.ne 2
-.na
-.B O_DIRECTORY
-.ad
-.sp .6
-.RS 4n
+memory and the device when the data is accessed with
+.Xr read 2
+and
+.Xr write 2
+operations.
+See
+.Xr directio 3C
+for more details.
+.It Dv O_DIRECTORY
 Indicates that attempts to open
-.I path
+.Fa path
 should fail unless
-.I path
+.Fa path
 is a directory.
 If both
-.B O_CREAT
+.Dv O_CREAT
 and
-.B O_DIRECTORY
+.Dv O_DIRECTORY
 are specified then the call will fail if it would result in a file being
 created.
 If a directory already exists at
-.I path
+.Fa path
 then it will behave as if the
-.B O_DIRECTORY
+.Dv O_DIRECTORY
 flag had not been present.
 If the
-.B O_EXCL
+.Dv O_EXCL
 and
-.B O_CREAT
-flags are specified, then the call will always fail as they imply a file
-should always be created.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_DSYNC\fR\fR
-.ad
-.sp .6
-.RS 4n
+.Dv O_CREAT
+flags are specified, then the call will always fail as they imply a file should
+always be created.
+.It Dv O_DSYNC
 Write I/O operations on the file descriptor complete as defined by synchronized
 I/O data integrity completion.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_EXCL\fR\fR
-.ad
-.sp .6
-.RS 4n
-If \fBO_CREAT\fR and \fBO_EXCL\fR are set, \fBopen()\fR fails if the file
-exists. The check for the existence of the file and the creation of the file if
+.It Dv O_EXCL
+If
+.Dv O_CREAT
+and
+.Dv O_EXCL
+are set,
+.Fn open
+fails if the file exists.
+The check for the existence of the file and the creation of the file if
 it does not exist is atomic with respect to other threads executing
-\fBopen()\fR naming the same filename in the same directory with \fBO_EXCL\fR
-and \fBO_CREAT\fR set. If \fBO_EXCL\fR and \fBO_CREAT\fR are set, and path
-names a symbolic link, \fBopen()\fR fails and sets \fBerrno\fR to \fBEEXIST\fR,
-regardless of the contents of the symbolic link. If \fBO_EXCL\fR is set and
-\fBO_CREAT\fR is not set, the result is undefined.
-.RE
-
-.sp
-.ne 2
-.na
-.B O_EXEC
-.na
-.ad
-.sp .6
-.RS 4n
+.Fn open
+naming the same filename in the same directory with
+.Dv O_EXCL
+and
+.Dv O_CREAT
+set.
+If
+.Dv O_EXCL
+and
+.Dv O_CREAT
+are set, and
+.Fa path
+names a symbolic link,
+.Fn open
+fails and sets
+.Va errno
+to
+.Er EEXIST ,
+regardless of the contents of the symbolic link.
+If
+.Dv O_EXCL
+is set and
+.Dv O_CREAT
+is not set, the result is undefined.
+.It Dv O_EXEC
 If set, indicates that the file should be opened for execute permission.
-This option is only valid for regular files, an error will be returned
-if it is not.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_LARGEFILE\fR\fR
-.ad
-.sp .6
-.RS 4n
+This option is only valid for regular files; an error will be returned if the
+target is not a regular file.
+.It Dv O_LARGEFILE
 If set, the offset maximum in the open file description is the largest value
-that can be represented correctly in an object of type \fBoff64_t\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_NOCTTY\fR\fR
-.ad
-.sp .6
-.RS 4n
-If set and \fIpath\fR identifies a terminal device, \fBopen()\fR does not cause
-the terminal device to become the controlling terminal for the process.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_NOFOLLOW\fR\fR
-.ad
-.sp .6
-.RS 4n
-If the path names a symbolic link, \fBopen()\fR fails and sets \fBerrno\fR to
-\fBELOOP\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_NOLINKS\fR\fR
-.ad
-.sp .6
-.RS 4n
-If the link count of the named file is greater than 1, \fBopen()\fR fails and
-sets \fBerrno\fR to \fBEMLINK\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_CLOEXEC\fR\fR
-.ad
-.sp .6
-.RS 4n
+that can be represented correctly in an object of type
+.Vt off64_t .
+.It Dv O_NOCTTY
+If set and
+.Fa path
+identifies a terminal device,
+.Fn open
+does not cause the terminal device to become the controlling terminal for the
+process.
+.It Dv O_NOFOLLOW
+If the path names a symbolic link,
+.Fn open
+fails and sets
+.Va errno
+to
+.Er ELOOP .
+.It Dv O_NOLINKS
+If the link count of the named file is greater than
+.Sy 1 ,
+.Fn open
+fails and sets
+.Va errno
+to
+.Er EMLINK .
+.It Dv O_CLOEXEC
 If set, the file descriptor returned will be closed prior to any future
-\fBexec()\fR calls.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_NONBLOCK\fR or \fBO_NDELAY\fR\fR
-.ad
-.sp .6
-.RS 4n
-These flags can affect subsequent reads and writes (see \fBread\fR(2) and
-\fBwrite\fR(2)). If both \fBO_NDELAY\fR and \fBO_NONBLOCK\fR are set,
-\fBO_NONBLOCK\fR takes precedence.
-.sp
-When opening a \fBFIFO\fR with \fBO_RDONLY\fR or \fBO_WRONLY\fR set:
-.RS +4
-.TP
-.ie t \(bu
-.el o
-If \fBO_NONBLOCK\fR or \fBO_NDELAY\fR is set, an \fBopen()\fR for reading only
-returns without delay.  An \fBopen()\fR for writing only returns an error if no
-process currently has the file open for reading.
-.RE
-.RS +4
-.TP
-.ie t \(bu
-.el o
-If \fBO_NONBLOCK\fR and \fBO_NDELAY\fR are clear, an \fBopen()\fR for reading
-only blocks until a thread opens the file for writing. An \fBopen()\fR for
-writing only blocks the calling thread until a thread opens the file for
+.Xr exec 2
+calls.
+.It Dv O_NONBLOCK O_NDELAY
+These flags can affect subsequent reads and writes
+.Po
+see
+.Xr read 2
+and
+.Xr write 2
+.Pc .
+If both
+.Dv O_NDELAY
+and
+.Dv O_NONBLOCK
+are set,
+.Dv O_NONBLOCK
+takes precedence.
+.Pp
+When opening a FIFO with
+.Dv O_RDONLY
+or
+.Dv O_WRONLY
+set:
+.Bl -bullet
+.It
+If
+.Dv O_NONBLOCK
+or
+.Dv O_NDELAY
+is set, an
+.Fn open
+for reading only returns without delay.
+An
+.Fn open
+for writing only returns an error if no process currently has the file open for
 reading.
-.RE
-After both ends of a \fBFIFO\fR have been opened, there is no guarantee that
-further calls to \fBopen()\fR \fBO_RDONLY\fR (\fBO_WRONLY\fR) will synchronize
-with later calls to \fBopen()\fR \fBO_WRONLY\fR (\fBO_RDONLY\fR) until both
-ends of the \fBFIFO\fR have been closed by all readers and writers.  Any data
-written into a \fBFIFO\fR will be lost if both ends of the \fBFIFO\fR are
-closed before the data is read.
-.sp
+.It
+If
+.Dv O_NONBLOCK
+and
+.Dv O_NDELAY
+are clear, an
+.Fn open
+for reading only blocks until a thread opens the file for writing.
+An
+.Fn open
+for writing only blocks the calling thread until a thread opens the file for
+reading.
+.El
+.Pp
+After both ends of a FIFO have been opened once, there is no guarantee that
+further calls to
+.Fn open
+.Dv O_RDONLY
+.Pq Dv O_WRONLY
+will synchronize with later calls to
+.Fn open
+.Dv O_WRONLY
+.Pq Dv O_RDONLY
+until both ends of the FIFO have been closed by all readers and writers.
+Any data written into a FIFO will be lost if both ends of the FIFO are closed
+before the data is read.
+.Pp
 When opening a block special or character special file that supports
 non-blocking opens:
-.RS +4
-.TP
-.ie t \(bu
-.el o
-If \fBO_NONBLOCK\fR or \fBO_NDELAY\fR is set, the \fBopen()\fR function returns
-without blocking for the device to be ready or available. Subsequent behavior
-of the device is device-specific.
-.RE
-.RS +4
-.TP
-.ie t \(bu
-.el o
-If \fBO_NONBLOCK\fR and \fBO_NDELAY\fR are clear, the \fBopen()\fR function
-blocks the calling thread until the device is ready or available before
-returning.
-.RE
-Otherwise, the behavior of \fBO_NONBLOCK\fR and \fBO_NDELAY\fR is unspecified.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_RSYNC\fR\fR
-.ad
-.sp .6
-.RS 4n
+.Bl -bullet
+.It
+If
+.Dv O_NONBLOCK
+or
+.Dv O_NDELAY
+is set, the
+.Fn open
+function returns without blocking for the device to be ready or available.
+Subsequent behavior of the device is device-specific.
+.It
+If
+.Dv O_NONBLOCK
+and
+.Dv O_NDELAY
+are clear, the
+.Fn open
+function blocks the calling thread until the device is ready or available
+before returning.
+.El
+.Pp
+Otherwise, the behavior of
+.Dv O_NONBLOCK
+and
+.Dv O_NDELAY
+is unspecified.
+.It Dv O_RSYNC
 Read I/O operations on the file descriptor complete at the same level of
-integrity as specified by the \fBO_DSYNC\fR and \fBO_SYNC\fR flags. If both
-\fBO_DSYNC\fR and \fBO_RSYNC\fR are set in \fIoflag\fR, all I/O operations on
-the file descriptor complete as defined by synchronized I/O data integrity
-completion.  If both \fBO_SYNC\fR and \fBO_RSYNC\fR are set in \fIoflag\fR, all
-I/O operations on the file descriptor complete as defined by synchronized I/O
-file integrity completion.
-.RE
-
-.sp
-.ne 2
-.na
-.B O_SEARCH
-.ad
-.sp .6
-.RS 4n
+integrity as specified by the
+.Dv O_DSYNC
+and
+.Dv O_SYNC
+flags.
+If both
+.Dv O_DSYNC
+and
+.Dv O_RSYNC
+are set in
+.Fa oflag ,
+all I/O operations on the file descriptor complete as defined by synchronized
+I/O data integrity completion.
+If both
+.Dv O_SYNC
+and
+.Dv O_RSYNC
+are set in
+.Fa oflag ,
+all I/O operations on the file descriptor complete as defined by synchronized
+I/O file integrity completion.
+.It Dv O_SEARCH
 If set, indicates that the directory should be opened for searching.
-This option is only valid for a directory, an error will be returned if
-it is not.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_SYNC\fR\fR
-.ad
-.sp .6
-.RS 4n
+This option is only valid for a directory; an error will be returned if the
+target is not a directory.
+.It Dv O_SYNC
 Write I/O operations on the file descriptor complete as defined by synchronized
-I/O file integrity completion (see \fBfcntl.h\fR(3HEAD) definition of
-\fBO_SYNC\fR).
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_TRUNC\fR\fR
-.ad
-.sp .6
-.RS 4n
+I/O file integrity completion
+.Po
+see
+.Xr fcntl.h 3HEAD
+.Pc
+definition of
+.Dv O_SYNC .
+.It Dv O_TRUNC
 If the file exists and is a regular file, and the file is successfully opened
-\fBO_RDWR\fR or \fBO_WRONLY\fR, its length is truncated to 0 and the mode and
-owner are unchanged. It has no effect on \fBFIFO\fR special files or terminal
-device files. Its effect on other file types is implementation-dependent. The
-result of using \fBO_TRUNC\fR with \fBO_RDONLY\fR is undefined.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_XATTR\fR\fR
-.ad
-.sp .6
-.RS 4n
-If set in \fBopenat()\fR, a relative path argument is interpreted as a
-reference to an extended attribute of the file associated with the supplied
-file descriptor.  This flag therefore requires the presence of a legal
-\fIfildes\fR argument. If set in \fBopen()\fR, the implied file descriptor is
-that for the current working directory. Extended attributes must be referenced
-with a relative path; providing an absolute path results in a normal file
-reference.
-.RE
-
-.sp
-.LP
-If \fBO_CREAT\fR is set and the file did not previously exist, upon successful
-completion, \fBopen()\fR marks for update the \fBst_atime\fR, \fBst_ctime\fR,
-and \fBst_mtime\fR fields of the file and the \fBst_ctime\fR and \fBst_mtime\fR
+.Dv O_RDWR
+or
+.Dv O_WRONLY ,
+its length is truncated to
+.Sy 0
+and the mode and owner are unchanged.
+It has no effect on FIFO special files or terminal device files.
+Its effect on other file types is implementation-dependent.
+The result of using
+.Dv O_TRUNC
+with
+.Dv O_RDONLY
+is undefined.
+.It Dv O_XATTR
+If set in
+.Fn openat ,
+a relative path argument is interpreted as a reference to an extended attribute
+of the file associated with the supplied file descriptor.
+This flag therefore requires the presence of a legal
+.Fa fildes
+argument.
+If set in
+.Fn open ,
+the implied file descriptor is that for the current working directory.
+Extended attributes must be referenced with a relative path; providing an
+absolute path results in a normal file reference.
+.El
+.Pp
+If
+.Dv O_CREAT
+is set and the file did not previously exist, upon successful completion,
+.Fn open
+marks for update the
+.Fa st_atime ,
+.Fa st_ctime ,
+and
+.Fa st_mtime
+fields of the file and the
+.Fa st_ctime
+and
+.Fa st_mtime
 fields of the parent directory.
-.sp
-.LP
-If \fBO_TRUNC\fR is set and the file did previously exist, upon successful
-completion, \fBopen()\fR marks for update the \fBst_ctime\fR and \fBst_mtime\fR
+.Pp
+If
+.Dv O_TRUNC
+is set and the file did previously exist, upon successful completion,
+.Fn open
+marks for update the
+.Fa st_ctime
+and
+.Fa st_mtime
 fields of the file.
-.sp
-.LP
-If both the \fBO_SYNC\fR and \fBO_DSYNC\fR flags are set, the effect is as if
-only the \fBO_SYNC\fR flag was set.
-.sp
-.LP
-If \fIpath\fR refers to a \fBSTREAMS\fR file, \fIoflag\fR may be constructed
-from \fBO_NONBLOCK\fR or \fBO_NODELAY\fR OR-ed with either \fBO_RDONLY\fR,
-\fBO_WRONLY\fR, or \fBO_RDWR\fR. Other flag values are not applicable to
-\fBSTREAMS\fR devices and have no effect on them.  The values \fBO_NONBLOCK\fR
-and \fBO_NODELAY\fR affect the operation of \fBSTREAMS\fR drivers and certain
-functions (see \fBread\fR(2), \fBgetmsg\fR(2), \fBputmsg\fR(2), and
-\fBwrite\fR(2)) applied to file descriptors associated with \fBSTREAMS\fR
-files.  For \fBSTREAMS\fR drivers, the implementation of \fBO_NONBLOCK\fR and
-\fBO_NODELAY\fR is device-specific.
-.sp
-.LP
-When \fBopen()\fR is invoked to open a named stream, and the \fBconnld\fR
-module (see \fBconnld\fR(7M)) has been pushed on the pipe, \fBopen()\fR blocks
-until the server process has issued an \fBI_RECVFD\fR \fBioctl()\fR (see
-\fBstreamio\fR(7I)) to receive the file descriptor.
-.sp
-.LP
-If \fIpath\fR names the master side of a pseudo-terminal device, then it is
-unspecified whether \fBopen()\fR locks the slave side so that it cannot be
-opened.  Portable applications must call \fBunlockpt\fR(3C) before opening the
-slave side.
-.sp
-.LP
+.Pp
+If both the
+.Dv O_SYNC
+and
+.Dv O_DSYNC
+flags are set, the effect is as if only the
+.Dv O_SYNC
+flag was set.
+.Pp
+If
+.Fa path
+refers to a STREAMS file,
+.Fa oflag
+may be constructed from
+.Dv O_NONBLOCK
+or
+.Dv O_NODELAY
+OR-ed with either
+.Dv O_RDONLY ,
+.Dv O_WRONLY ,
+or
+.Dv O_RDWR .
+Other flag values are not applicable to STREAMS devices and have no effect on
+them.
+The values
+.Dv O_NONBLOCK
+and
+.Dv O_NODELAY
+affect the operation of STREAMS drivers and certain functions
+.Po
+see
+.Xr read 2 ,
+.Xr getmsg 2 ,
+.Xr putmsg 2 ,
+and
+.Xr write 2
+.Pc
+applied to file descriptors associated with STREAMS files.
+For STREAMS drivers, the implementation of
+.Dv O_NONBLOCK
+and
+.Dv O_NODELAY
+is device-specific.
+.Pp
+When
+.Fn open
+is invoked to open a named stream, and the
+.Xr connld 7M
+module has been pushed on the pipe,
+.Fn open
+blocks until the server process has issued an
+.Dv I_RECVFD
+.Xr ioctl 2
+.Po
+see
+.Xr streamio 7I
+.Pc
+to receive the file descriptor.
+.Pp
+If
+.Fa path
+names the manager side of a pseudo-terminal device, then it is unspecified
+whether
+.Fn open
+locks the subsidiary side so that it cannot be opened.
+Portable applications must call
+.Xr unlockpt 3C
+before opening the subsidiary side.
+.Pp
 If the file is a regular file and the local file system is mounted with the
-\fBnbmand\fR mount option, then a mandatory share reservation is automatically
-obtained on the file. The share reservation is obtained as if \fBfcntl\fR(2)
-were called with \fIcmd\fR \fBF_SHARE_NBMAND\fR and the \fBfshare_t\fR values
-set as follows:
-.sp
-.ne 2
-.na
-\fB\fBf_access\fR\fR
-.ad
-.RS 12n
+.Cm nbmand
+mount option, then a mandatory share reservation is automatically obtained on
+the file.
+The share reservation is obtained as if
+.Xr fcntl 2
+were called with
+.Fa cmd
+.Dv F_SHARE_NBMAND
+and the
+.Vt fshare_t
+values set as follows:
+.Bl -tag -width Ds -offset Ds
+.It Fa f_access
 Set to the type of read/write access for which the file is opened.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBf_deny\fR\fR
-.ad
-.RS 12n
-\fBF_NODNY\fR
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBf_id\fR\fR
-.ad
-.RS 12n
-The file descriptor value returned from \fBopen()\fR.
-.RE
-
-.sp
-.LP
-If \fIpath\fR is a symbolic link and \fBO_CREAT\fR and \fBO_EXCL\fR are set,
-the link is not followed.
-.sp
-.LP
-Certain flag values can be set following \fBopen()\fR as described in
-\fBfcntl\fR(2).
-.sp
-.LP
+.It Fa f_deny
+.Dv F_NODNY
+.It Fa f_id
+The file descriptor value returned from
+.Fn open .
+.El
+.Pp
+If
+.Fa path
+is a symbolic link and
+.Dv O_CREAT
+and
+.Dv O_EXCL
+are set, the link is not followed.
+.Pp
+Certain flag values can be set following
+.Fn open
+as described in
+.Xr fcntl 2 .
+.Pp
 The largest value that can be represented correctly in an object of type
-\fBoff_t\fR is established as the offset maximum in the open file description.
-.SH RETURN VALUES
-Upon successful completion, both \fBopen()\fR and \fBopenat()\fR functions open
-the file and return a non-negative integer representing the lowest numbered
-unused file descriptor.  Otherwise, \fB\(mi1\fR is returned, \fBerrno\fR is set
-to indicate the error, and no files are created or modified.
-.SH ERRORS
-The \fBopen()\fR and \fBopenat()\fR functions will fail if:
-.sp
-.ne 2
-.na
-\fB\fBEACCES\fR\fR
-.ad
-.RS 16n
-Search permission is denied on a component of the path prefix.
-.sp
-The file exists and the permissions specified by \fIoflag\fR are denied.
-.sp
-The file does not exist and write permission is denied for the parent directory
-of the file to be created.
-.sp
-\fBO_TRUNC\fR is specified and write permission is denied.
-.sp
-The {\fBPRIV_FILE_DAC_SEARCH\fR} privilege allows processes to search
-directories regardless of permission bits. The {\fBPRIV_FILE_DAC_WRITE\fR}
-privilege allows processes to open files for writing regardless of permission
-bits. See \fBprivileges\fR(5) for special considerations when opening files
-owned by UID 0 for writing. The {\fBPRIV_FILE_DAC_READ\fR} privilege allows
-processes to open files for reading regardless of permission bits.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEAGAIN\fR\fR
-.ad
-.RS 16n
-A mandatory share reservation could not be obtained because the desired access
-conflicts with an existing \fBf_deny\fR share reservation.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEDQUOT\fR\fR
-.ad
-.RS 16n
-The file does not exist, \fBO_CREAT\fR is specified, and either the directory
-where the new file entry is being placed cannot be extended because the user's
-quota of disk blocks on that file system has been exhausted, or the user's
-quota of inodes on the file system where the file is being created has been
-exhausted.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEEXIST\fR\fR
-.ad
-.RS 16n
-The \fBO_CREAT\fR and \fBO_EXCL\fR flags are set and the named file exists.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEILSEQ\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument includes non-UTF8 characters and the file system
-accepts only file names where all characters are part of the UTF-8 character
-codeset.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEINTR\fR\fR
-.ad
-.RS 16n
-A signal was caught during \fBopen()\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEFAULT\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument points to an illegal address.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEINVAL\fR\fR
-.ad
-.RS 16n
-The system does not support synchronized or direct I/O for this file, or the
-\fBO_XATTR\fR flag was supplied and the underlying file system does not support
-extended file attributes.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEIO\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument names a \fBSTREAMS\fR file and a hangup or error
-occurred during the \fBopen()\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEISDIR\fR\fR
-.ad
-.RS 16n
-The named file is a directory and \fIoflag\fR includes \fBO_WRONLY\fR or
-\fBO_RDWR\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBELOOP\fR\fR
-.ad
-.RS 16n
-Too many symbolic links were encountered in resolving \fIpath\fR.
-.sp
-A loop exists in symbolic links encountered during resolution of the \fIpath\fR
-argument.
-.sp
-The \fBO_NOFOLLOW\fR flag is set and the final component of path is a symbolic
-link.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEMFILE\fR\fR
-.ad
-.RS 16n
-There are currently {\fBOPEN_MAX\fR} file descriptors open in the calling
-process.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEMLINK\fR\fR
-.ad
-.RS 16n
-The \fBO_NOLINKS\fR flag is set and the named file has a link count greater
-than 1.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEMULTIHOP\fR\fR
-.ad
-.RS 16n
-Components of \fIpath\fR require hopping to multiple remote machines and the
-file system does not allow it.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENAMETOOLONG\fR\fR
-.ad
-.RS 16n
-The length of the \fIpath\fR argument exceeds {\fBPATH_MAX\fR} or a pathname
-component is longer than {\fBNAME_MAX\fR}.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENFILE\fR\fR
-.ad
-.RS 16n
-The maximum allowable number of files is currently open in the system.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOENT\fR\fR
-.ad
-.RS 16n
-The \fBO_CREAT\fR flag is not set and the named file does not exist; or the
-\fBO_CREAT\fR flag is set and either the path prefix does not exist or the
-\fIpath\fR argument points to an empty string.
-.sp
+.Vt off_t
+is established as the offset maximum in the open file description.
+.Sh RETURN VALUES
 The
-.B O_CREAT
+.Fn open
 and
-.B O_DIRECTORY
-flags were both set and
-.I path
-did not point to a file.
-.RE
-
-.sp
-.ne 2
-.na
-.B ENOEXEC
-.ad
-.RS 16n
-The \fBO_EXEC\fR flag is set and \fIpath\fR does not point to a regular
-file.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOLINK\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument points to a remote machine, and the link to that
-machine is no longer active.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOSR\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument names a STREAMS-based file and the system is unable to
-allocate a STREAM.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOSPC\fR\fR
-.ad
-.RS 16n
-The directory or file system that would contain the new file cannot be
-expanded, the file does not exist, and \fBO_CREAT\fR is specified.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOSYS\fR\fR
-.ad
-.RS 16n
-The device specified by \fIpath\fR does not support the open operation.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOTDIR\fR\fR
-.ad
-.RS 16n
-A component of the path prefix is not a directory or a relative path was
-supplied to \fBopenat()\fR, the \fBO_XATTR\fR flag was not supplied, and the
-file descriptor does not refer to a directory. The \fBO_SEARCH\fR flag
-was passed and \fIpath\fR does not refer to a directory.
-.sp
-The
-.B O_DIRECTORY
-flag was set and the file was not a directory.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENXIO\fR\fR
-.ad
-.RS 16n
-The \fBO_NONBLOCK\fR flag is set, the named file is a FIFO, the \fBO_WRONLY\fR
-flag is set, and no process has the file open for reading; or the named file is
-a character special or block special file and the device associated with this
-special file does not exist or has been retired by the fault management
-framework .
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEOPNOTSUPP\fR\fR
-.ad
-.RS 16n
-An attempt was made to open a path that corresponds to a \fBAF_UNIX\fR socket.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEOVERFLOW\fR\fR
-.ad
-.RS 16n
-The named file is a regular file and either \fBO_LARGEFILE\fR is not set and
-the size of the file cannot be represented correctly in an object of type
-\fBoff_t\fR or \fBO_LARGEFILE\fR is set and the size of the file cannot be
-represented correctly in an object of type \fBoff64_t\fR.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEROFS\fR\fR
-.ad
-.RS 16n
-The named file resides on a read-only file system and either \fBO_WRONLY\fR,
-\fBO_RDWR\fR, \fBO_CREAT\fR (if file does not exist), or \fBO_TRUNC\fR is set
-in the \fIoflag\fR argument.
-.RE
-
-.sp
-.LP
-The \fBopenat()\fR function will fail if:
-.sp
-.ne 2
-.na
-\fB\fBEBADF\fR\fR
-.ad
-.RS 9n
-The \fIfildes\fR argument is not a valid open file descriptor or is not
-\fBAT_FTCWD\fR.
-.RE
-
-.sp
-.LP
-The \fBopen()\fR function may fail if:
-.sp
-.ne 2
-.na
-\fB\fBEAGAIN\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument names the slave side of a pseudo-terminal device that
-is locked.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEINVAL\fR\fR
-.ad
-.RS 16n
-The value of the \fIoflag\fR argument is not valid.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENAMETOOLONG\fR\fR
-.ad
-.RS 16n
-Pathname resolution of a symbolic link produced an intermediate result whose
-length exceeds {\fBPATH_MAX\fR}.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOMEM\fR\fR
-.ad
-.RS 16n
-The \fIpath\fR argument names a \fBSTREAMS\fR file and the system is unable to
-allocate resources.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBETXTBSY\fR\fR
-.ad
-.RS 16n
-The file is a pure procedure (shared text) file that is being executed and
-\fIoflag\fR is \fBO_WRONLY\fR or \fBO_RDWR\fR.
-.RE
-
-.SH EXAMPLES
-\fBExample 1 \fROpen a file for writing by the owner.
-.sp
-.LP
-The following example opens the file \fB/tmp/file\fR, either by creating it if
-it does not already exist, or by truncating its length to 0 if it does exist.
+.Fn openat
+functions open the file and, if successful, return a non-negative integer
+representing the lowest numbered unused file descriptor; otherwise the
+value
+.Sy -1
+is returned and the global variable
+.Va errno
+is set to indicate the error and no files are created or modified.
+.Sh EXAMPLES
+.Sy Example 1
+Open a file for writing by the owner.
+.Pp
+The following example opens the file
+.Pa /tmp/file ,
+either by creating it if it does not already exist, or by truncating its length
+to
+.Sy 0
+if it does exist.
 If the call creates a new file, the access permission bits in the file mode of
 the file are set to permit reading and writing by the owner, and to permit
 reading only by group members and others.
-
-.sp
-.LP
-If the call to \fBopen()\fR is successful, the file is opened for writing.
-
-.sp
-.in +2
-.nf
+.Pp
+If the call to
+.Fn open
+is successful, the file is opened for writing.
+.Bd -literal -offset Ds
 #include <fcntl.h>
 \&...
 int fd;
@@ -928,98 +635,361 @@ char *filename = "/tmp/file";
 \&...
 fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, mode);
 \&...
-.fi
-.in -2
-
-.LP
-\fBExample 2 \fROpen a file using an existence check.
-.sp
-.LP
-The following example uses the \fBopen()\fR function to try to create the
-\fBLOCKFILE\fR file and open it for writing. Since the \fBopen()\fR function
-specifies the \fBO_EXCL\fR flag, the call fails if the file already exists. In
-that case, the application assumes that someone else is updating the password
-file and exits.
-
-.sp
-.in +2
-.nf
+.Ed
+.Pp
+.Sy Example 2
+Open a file using an existence check.
+.Pp
+The following example uses the
+.Fn open
+function to try to create the
+.Dv LOCKFILE
+file and open it for writing.
+Since the
+.Fn open
+function specifies the
+.Dv O_EXCL
+flag, the call fails if the file already exists.
+In that case, the application assumes that someone else is updating the
+password file and exits.
+.Bd -literal -offset Ds
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <err.h>
+\&...
 #define LOCKFILE "/etc/ptmp"
 \&...
 int pfd; /* Integer for file descriptor returned by open() call. */
 \&...
 if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
-        S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
-{
-        fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\en");
-        exit(1);
+    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
+        err(1, "Cannot open %s. Try again later.", LOCKFILE);
 }
 \&...
-.fi
-.in -2
-
-.LP
-\fBExample 3 \fROpen a file for writing.
-.sp
-.LP
+.Ed
+.Pp
+.Sy Example 3
+Open a file for writing.
+.Pp
 The following example opens a file for writing, creating the file if it does
-not already exist. If the file does exist, the system truncates the file to
-zero bytes.
-
-.sp
-.in +2
-.nf
+not already exist.
+If the file does exist, the system truncates the file to zero bytes.
+.Bd -literal -offset Ds
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
-#define LOCKFILE "/etc/ptmp"
+#include <err.h>
 \&...
 int pfd;
 char filename[PATH_MAX+1];
 \&...
 if ((pfd = open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-        S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
-{
-        perror("Cannot open output file\en"); exit(1);
+    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
+        err(1, "Cannot open output file");
 }
 \&...
-.fi
-.in -2
-
-.SH USAGE
-The \fBopen()\fR function has a transitional interface for 64-bit file offsets.
-See \fBlf64\fR(5). Note that using \fBopen64()\fR is equivalent to using
-\fBopen()\fR with \fBO_LARGEFILE\fR set in \fIoflag\fR.
-.SH ATTRIBUTES
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
-Interface Stability	Committed
-_
-MT-Level	Async-Signal-Safe
-_
-Standard	For \fBopen()\fR, see \fBstandards\fR(5).
-.TE
-
-.SH SEE ALSO
-\fBIntro\fR(2), \fBchmod\fR(2), \fBclose\fR(2), \fBcreat\fR(2), \fBdup\fR(2),
-\fBexec\fR(2), \fBfcntl\fR(2), \fBgetmsg\fR(2), \fBgetrlimit\fR(2),
-\fBlseek\fR(2), \fBputmsg\fR(2), \fBread\fR(2), \fBstat\fR(2), \fBumask\fR(2),
-\fBwrite\fR(2), \fBattropen\fR(3C), \fBdirectio\fR(3C),
-\fBfcntl.h\fR(3HEAD), \fBstat.h\fR(3HEAD),
-\fBunlockpt\fR(3C), \fBattributes\fR(5), \fBlf64\fR(5), \fBprivileges\fR(5),
-\fBstandards\fR(5), \fBconnld\fR(7M), \fBstreamio\fR(7I)
-.SH NOTES
-Hierarchical Storage Management (HSM) file systems can sometimes cause long
-delays when opening a file, since HSM files must be recalled from secondary
-storage.
+.Ed
+.Sh ERRORS
+The
+.Fn open
+and
+.Fn openat
+functions will fail if:
+.Bl -tag -width Er
+.It Er EACCES
+Search permission is denied on a component of the path prefix.
+.Pp
+The file exists and the permissions specified by
+.Fa oflag
+are denied.
+.Pp
+The file does not exist and write permission is denied for the parent directory
+of the file to be created.
+.Pp
+.Dv O_TRUNC
+is specified and write permission is denied.
+.Pp
+The
+.Brq Dv PRIV_FILE_DAC_SEARCH
+privilege allows processes to search directories regardless of permission bits.
+The
+.Brq Dv PRIV_FILE_DAC_WRITE
+privilege allows processes to open files for writing regardless of permission
+bits.
+See
+.Xr privileges 5 for special considerations when opening files owned by user ID
+.Sy 0
+for writing.
+The
+.Brq Dv PRIV_FILE_DAC_READ
+privilege allows
+processes to open files for reading regardless of permission bits.
+.It Er EAGAIN
+A mandatory share reservation could not be obtained because the desired access
+conflicts with an existing
+.Fa f_deny
+share reservation
+.Po
+see
+.Xr fcntl 2
+.Pc .
+.It Er EDQUOT
+The file does not exist,
+.Dv O_CREAT
+is specified, and either the directory where the new file entry is being placed
+cannot be extended because the user's quota of disk blocks on that file system
+has been exhausted, or the user's quota of inodes on the file system where the
+file is being created has been exhausted.
+.It Er EEXIST
+The
+.Dv O_CREAT
+and
+.Dv O_EXCL
+flags are set and the named file already exists.
+.It Er EILSEQ
+The
+.Fa path
+argument includes bytes that are not valid UTF-8 characters, and the file
+system accepts only file names where all characters are part of the UTF-8
+character codeset.
+.It Er EINTR
+A signal was caught during
+.Fn open .
+.It Er EFAULT
+The
+.Fa path
+argument points to an illegal address.
+.It Er EINVAL
+Either the system does not support synchronized or direct I/O for this file, or
+the
+.Dv O_XATTR
+flag was supplied and the underlying file system does not support extended file
+attributes.
+.It Er EIO
+The
+.Fa path
+argument names a STREAMS file and a hangup or error occurred during the
+.Fn open .
+.It Er EISDIR
+The named file is a directory and
+.Fa oflag
+includes
+.Dv O_WRONLY
+or
+.Dv O_RDWR .
+.It Er ELOOP
+Too many symbolic links were encountered in resolving
+.Fa path .
+.Pp
+A loop exists in symbolic links encountered during resolution of the
+.Fa path
+argument.
+.Pp
+The
+.Dv O_NOFOLLOW
+flag is set and the final component of path is a symbolic link.
+.It Er EMFILE
+There are currently
+.Brq Dv OPEN_MAX
+file descriptors open in the calling process.
+.It Er EMLINK
+The
+.Dv O_NOLINKS
+flag is set and the named file has a link count greater than
+.Sy 1 .
+.It Er EMULTIHOP
+Components of
+.Fa path
+require hopping to multiple remote machines and the file system does not allow
+it.
+.It Er ENAMETOOLONG
+The length of the
+.Fa path
+argument exceeds
+.Brq Dv PATH_MAX
+or a pathname component is longer than
+.Brq Dv NAME_MAX .
+.It Er ENFILE
+The maximum allowable number of files is currently open in the system.
+.It Er ENOENT
+The
+.Dv O_CREAT
+flag is not set and the named file does not exist; or the
+.Dv O_CREAT
+flag is set and either the path prefix does not exist or the
+.Fa path
+argument points to an empty string.
+.Pp
+The
+.Dv O_CREAT
+and
+.Dv O_DIRECTORY
+flags were both set and
+.Fa path
+did not point to a file.
+.It Er ENOEXEC
+The
+.Dv O_EXEC
+flag is set and
+.Fa path
+does not point to a regular file.
+.It Er ENOLINK
+The
+.Fa path
+argument points to a remote machine, and the link to that machine is no longer
+active.
+.It Er ENOSR
+Th
+.Fa path
+argument names a STREAMS-based file and the system is unable to allocate a
+STREAM.
+.It Er ENOSPC
+The directory or file system that would contain the new file cannot be
+expanded, the file does not exist, and
+.Dv O_CREAT
+is specified.
+.It Er ENOSYS
+The device specified by
+.Fa path
+does not support the open operation.
+.It Er ENOTDIR
+A component of the path prefix is not a directory or a relative path was
+supplied to
+.Fn openat ,
+the
+.Dv O_XATTR
+flag was not supplied, and the file descriptor does not refer to a directory.
+The
+.Dv O_SEARCH
+flag was passed and
+.Fa path
+does not refer to a directory.
+.Pp
+The
+.Dv O_DIRECTORY
+flag was set and the file was not a directory.
+.It Er ENXIO
+The
+.Dv O_NONBLOCK
+flag is set, the named file is a FIFO, the
+.Dv O_WRONLY
+flag is set, and no process has the file open for reading; or the named file is
+a character special or block special file and the device associated with this
+special file does not exist or has been retired by the fault management
+framework.
+.It Er EOPNOTSUPP
+An attempt was made to open a path that corresponds to an
+.Dv AF_UNIX
+socket.
+.It Er EOVERFLOW
+The named file is a regular file and either
+.Dv O_LARGEFILE
+is not set and the size of the file cannot be represented correctly in an
+object of type
+.Vt off_t
+or
+.Dv O_LARGEFILE
+is set and the size of the file cannot be represented correctly in an object of
+type
+.Vt off64_t .
+.It Er EROFS
+The named file resides on a read-only file system and either
+.Dv O_WRONLY ,
+.Dv O_RDWR ,
+.Dv O_CREAT
+(if file does not exist), or
+.Dv O_TRUNC
+is set in the
+.Fa oflag
+argument.
+.El
+.Pp
+The
+.Fn openat
+function will fail if:
+.Bl -tag -width Er
+.It Er EBADF
+The
+.Fa fildes
+argument is not a valid open file descriptor or is not
+.Dv AT_FTCWD .
+.El
+.Pp
+The
+.Fn open
+function may fail if:
+.Bl -tag -width Er
+.It Er EAGAIN
+The
+.Fa path
+argument names the subsidiary side of a pseudo-terminal device that is locked.
+.It Er EINVAL
+The value of the
+.Fa oflag
+argument is not valid.
+.It Er ENAMETOOLONG
+Pathname resolution of a symbolic link produced an intermediate result whose
+length exceeds
+.Brq Dv PATH_MAX .
+.It Er ENOMEM
+The
+.Fa path
+argument names a STREAMS file and the system is unable to allocate resources.
+.It Er ETXTBSY
+The file is a pure procedure (shared text) file that is being executed and
+.Fa oflag
+is
+.Dv O_WRONLY
+or
+.Dv O_RDWR .
+.El
+.Sh USAGE
+The
+.Fn open
+function has a transitional interface for 64-bit file offsets.
+See
+.Xr lf64 5 .
+Note that using
+.Fn open64
+is equivalent to using
+.Fn open with
+.Dv O_LARGEFILE
+set in
+.Fa oflag .
+.Sh INTERFACE STABILITY
+.Sy Committed
+.Sh MT LEVEL
+.Sy Async-Signal-Safe
+.Sh SEE ALSO
+.Xr chmod 2 ,
+.Xr close 2 ,
+.Xr creat 2 ,
+.Xr dup 2 ,
+.Xr exec 2 ,
+.Xr fcntl 2 ,
+.Xr getmsg 2 ,
+.Xr getrlimit 2 ,
+.Xr Intro 2 ,
+.Xr lseek 2 ,
+.Xr putmsg 2 ,
+.Xr read 2 ,
+.Xr stat 2 ,
+.Xr umask 2 ,
+.Xr write 2 ,
+.Xr attropen 3C ,
+.Xr directio 3C ,
+.Xr unlockpt 3C ,
+.Xr fcntl.h 3HEAD ,
+.Xr stat.h 3HEAD ,
+.Xr attributes 5 ,
+.Xr lf64 5 ,
+.Xr privileges 5 ,
+.Xr standards 5 ,
+.Xr streamio 7I ,
+.Xr connld 7M
+.Sh NOTES
+Hierarchical Storage Management
+.Pq HSM
+file systems can sometimes cause long delays when opening a file, since HSM
+files must be recalled from secondary storage.
diff --git a/usr/src/man/man3c/grantpt.3c b/usr/src/man/man3c/grantpt.3c
index 7e523af80b..154a5a07f5 100644
--- a/usr/src/man/man3c/grantpt.3c
+++ b/usr/src/man/man3c/grantpt.3c
@@ -43,88 +43,76 @@
 .\" Copyright 1989 AT&T
 .\" Portions Copyright (c) 1994, X/Open Company Limited.  All Rights Reserved.
 .\" Copyright (c) 2006, Sun Microsystems, Inc.  All Rights Reserved.
+.\" Copyright 2022 Oxide Computer Company
 .\"
-.TH GRANTPT 3C "Aug 14, 2006"
-.SH NAME
-grantpt \- grant access to the slave pseudo-terminal device
-.SH SYNOPSIS
-.LP
-.nf
-#include <stdlib.h>
-
-\fBint\fR \fBgrantpt\fR(\fBint\fR \fIfildes\fR);
-.fi
-
-.SH DESCRIPTION
-.sp
-.LP
-The \fBgrantpt()\fR function changes the mode and ownership of the slave
-pseudo-terminal device associated with its master  pseudo-terminal counterpart.
-\fIfildes\fR is the file descriptor returned from a successful open of the
-master pseudo-terminal device. The user ID of the slave is set to the real UID
-of the calling process and the group ID is set to a reserved group. The
-permission mode of the slave pseudo-terminal is set to readable and writable by
-the owner and writable by the group.
-.SH RETURN VALUES
-.sp
-.LP
-Upon successful completion, \fBgrantpt()\fR returns \fB0\fR. Otherwise, it
-returns \fB\(mi1\fR and sets \fBerrno\fR to indicate the error.
-.SH ERRORS
-.sp
-.LP
-The \fBgrantpt()\fR function may fail if:
-.sp
-.ne 2
-.na
-\fB\fBEBADF\fR\fR
-.ad
-.RS 10n
-The \fIfildes\fR argument is not a valid open file descriptor.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEINVAL\fR\fR
-.ad
-.RS 10n
-The \fIfildes\fR argument is not associated with a master pseudo-terminal
+.Dd February 5, 2022
+.Dt GRANTPT 3C
+.Os
+.Sh NAME
+.Nm grantpt
+.Nd grant access to the subsidiary device of a pseudo-terminal
+.Sh SYNOPSIS
+.In stdlib.h
+.Ft int
+.Fo grantpt
+.Fa "int fildes"
+.Fc
+.Sh DESCRIPTION
+The
+.Fn grantpt
+function changes the mode and ownership of the pseudo-terminal subsidiary
+device associated with its pseudo-terminal manager counterpart.
+.Pp
+The
+.Fa fildes
+argument is the file descriptor returned from a successful
+.Xr open 2
+of the pseudo-terminal manager device; e.g., by calling
+.Xr posix_openpt 3C
+or by performing an
+.Xr open 2
+of the
+.Xr ptm 7D
 device.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEACCES\fR\fR
-.ad
-.RS 10n
-The corresponding slave pseudo-terminal device could not be accessed.
-.RE
-
-.SH ATTRIBUTES
-.sp
-.LP
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
-Interface Stability	Standard
-_
-MT-Level	Safe
-.TE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBopen\fR(2), \fBptsname\fR(3C), \fBunlockpt\fR(3C), \fBattributes\fR(5),
-\fBstandards\fR(5)
-.sp
-.LP
-\fISTREAMS Programming Guide\fR
+.Pp
+The user ID owner of the subsidiary device is set to the real user ID of the
+calling process.
+The group ID owner is set to a reserved group.
+.Pp
+The permission mode of the subsidiary device is set to be readable and writable
+by the owner, and writable by the group.
+.Sh RETURN VALUES
+.Rv -std grantpt
+.Sh EXAMPLES
+See
+.Xr posix_openpt 3C
+for an example that includes a call to
+.Fn grantpt .
+.Sh ERRORS
+The
+.Fn grantpt
+function may fail if:
+.Bl -tag -width Er
+.It Er EBADF
+The
+.Fa fildes
+argument is not a valid open file descriptor.
+.It Er EINVAL
+The
+.Fa fildes
+argument is not associated with a pseudo-terminal manager device.
+.It Er EACCES
+The corresponding pseudo-terminal subsidiary device could not be accessed.
+.El
+.Sh INTERFACE STABILITY
+.Sy Committed
+.Sh MT LEVEL
+.Sy Safe
+.Sh SEE ALSO
+.Xr open 2 ,
+.Xr posix_openpt 3C ,
+.Xr ptsname 3C ,
+.Xr unlockpt 3C ,
+.Xr attributes 5 ,
+.Xr standards 5 ,
+.Xr ptm 7D
diff --git a/usr/src/man/man3c/posix_openpt.3c b/usr/src/man/man3c/posix_openpt.3c
index 16193b89f3..b009dd6e17 100644
--- a/usr/src/man/man3c/posix_openpt.3c
+++ b/usr/src/man/man3c/posix_openpt.3c
@@ -42,160 +42,142 @@
 .\"
 .\" Copyright (c) 2001, The IEEE and The Open Group.  All Rights Reserved.
 .\" Portions Copyright (c) 2003, Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2022 Oxide Computer Company
 .\"
-.TH POSIX_OPENPT 3C "June 18, 2021"
-.SH NAME
-posix_openpt \- open a pseudo terminal device
-.SH SYNOPSIS
-.nf
-#include <stdlib.h>
-#include <fcntl.h>
-
-\fBint\fR \fBposix_openpt\fR(\fBint\fR \fIoflag\fR);
-.fi
-
-.SH DESCRIPTION
-The \fBposix_openpt()\fR function establishes a connection between a master
-device for a pseudo-terminal and a file descriptor. The file descriptor is used
-by other I/O functions that refer to that pseudo-terminal.
-.sp
-.LP
+.Dd February 5, 2022
+.Dt POSIX_OPENPT 3C
+.Os
+.Sh NAME
+.Nm posix_openpt
+.Nd open a pseudo-terminal manager device
+.Sh SYNOPSIS
+.In stdlib.h
+.In fcntl.h
+.Ft int
+.Fo posix_openpt
+.Fa "int oflag"
+.Fc
+.Sh DESCRIPTION
+The
+.Fn posix_openpt
+function establishes a connection between a manager device for a
+pseudo-terminal and a file descriptor.
+The file descriptor is used by other I/O functions that refer to that
+pseudo-terminal.
+.Pp
 The file status flags and file access modes of the open file description are
-set according to the value of \fIoflag\fR.
-.sp
-.LP
-Values for \fIoflag\fR are constructed by a bitwise-inclusive OR of flags from
-the following list, defined in <\fBfcntl.h\fR>.
-.sp
-.ne 2
-.na
-\fB\fBO_RDWR\fR\fR
-.ad
-.RS 12n
+set according to the value of
+.Fa oflag .
+.Pp
+Values for
+.Fa oflag
+are constructed by a bitwise-inclusive OR of flags from
+the following list, defined in
+.Xr fcntl.h 3HEAD :
+.Bl -tag -width Ds
+.It Dv O_RDWR
 Open for reading and writing.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBO_NOCTTY\fR\fR
-.ad
-.RS 12n
-If set, \fBposix_openpt()\fR does not cause the terminal device to become the
-controlling terminal for the process.
-.RE
-
-.sp
-.LP
-The behavior of other values for the \fIoflag\fR argument is unspecified.
-.SH RETURN VALUES
-Upon successful completion, the \fBposix_openpt()\fR function opens a master
-pseudo-terminal device and returns a non-negative integer representing the
-lowest numbered unused file descriptor. Otherwise, -1 is returned and
-\fBerrno\fR is set to indicate the error.
-.SH ERRORS
-The \fBposix_openpt()\fR function will fail if:
-.sp
-.ne 2
-.na
-\fB\fBEMFILE\fR\fR
-.ad
-.RS 10n
-{\fBOPEN_MAX\fR} file descriptors are currently open in the calling process.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENFILE\fR\fR
-.ad
-.RS 10n
-The maximum allowable number of files is currently open in the system.
-.RE
-
-.sp
-.LP
-The \fBposix_openpt()\fR function may fail if:
-.sp
-.ne 2
-.na
-\fB\fBEINVAL\fR\fR
-.ad
-.RS 10n
-The value of \fIoflag\fR is not valid.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEAGAIN\fR\fR
-.ad
-.RS 10n
-Out of pseudo-terminal resources.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBENOSR\fR\fR
-.ad
-.RS 10n
-Out of STREAMS resources.
-.RE
-
-.SH EXAMPLES
-\fBExample 1 \fROpen a pseudo-terminal.
-.sp
-.LP
-The following example opens a pseudo-terminal and returns the name of the slave
-device and a file descriptor.
-
-.sp
-.in +2
-.nf
+.It Dv O_NOCTTY
+If set,
+.Fn posix_openpt
+does not cause the terminal device to become the controlling terminal for the
+process.
+.El
+.Pp
+The behavior of other values for the
+.Fa oflag
+argument is unspecified.
+.Sh RETURN VALUES
+The
+.Fn posix_getopt
+function opens a manager pseudo-terminal device and, if successful, returns a
+non-negative integer representing the lowest numbered unused file descriptor ;
+otherwise, the value
+.Sy -1
+is returned and the global variable
+.Va errno
+is set to indicate the error.
+.Sh EXAMPLES
+.Sy Example 1
+Open a pseudo-terminal.
+.Pp
+The following example opens a pseudo-terminal and returns the name of the
+subsidiary device and a file descriptor.
+.Bd -literal -offset Ds
 #include <fcntl.h>
 #include <stdio.h>
-
-int masterfd, slavefd;
-char *slavedevice;
-
-masterfd = posix_openpt(O_RDWR|O_NOCTTY);
-
-if (masterfd == -1
-      || grantpt (masterfd) == -1
-      || unlockpt (masterfd) == -1
-      || (slavedevice = ptsname (masterfd)) == NULL)
-      return -1;
-
-printf("slave device is: %s\en", slavedevice);
-
-slavefd = open(slave, O_RDWR|O_NOCTTY);
-if (slavefd < 0)
-      return -1;
-.fi
-.in -2
-
-.SH USAGE
-This function provides a method for portably obtaining a file descriptor of a
-master terminal device for a pseudo-terminal. The \fBgrantpt\fR(3C) and
-\fBptsname\fR(3C) functions can be used to manipulate mode and ownership
-permissions and to obtain the name of the slave device, respectively.
-.SH ATTRIBUTES
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
-Interface Stability	Standard
-_
-MT-Level	MT-Safe
-.TE
-
-.SH SEE ALSO
-\fBopen\fR(2), \fBgrantpt\fR(3C), \fBptsname\fR(3C), \fBunlockpt\fR(3C),
-\fBattributes\fR(5), \fBstandards\fR(5)
+#include <err.h>
+
+int managerfd, subsidiaryfd;
+char *subsidiarydevice;
+
+if ((managerfd = posix_openpt(O_RDWR|O_NOCTTY)) < 0) {
+        err(1, "opening pseudo-terminal manager");
+}
+
+if (grantpt(managerfd) != 0 ||
+    unlockpt(managerfd) != 0 ||
+    (subsidiarydevice = ptsname(managerfd)) == NULL) {
+        (void) close(managerfd);
+        err(1, "locating pseudo-terminal subsidiary");
+}
+
+printf("subsidiary device is: %s\en", subsidiarydevice);
+
+if ((subsidiaryfd = open(subsidiary, O_RDWR|O_NOCTTY)) < 0) {
+        err(1, "opening pseudo-terminal subsidiary");
+}
+.Ed
+.Sh ERRORS
+The
+.Fn posix_openpt
+function will fail if:
+.Bl -tag -width Er
+.It Er EMFILE
+.Brq Dv OPEN_MAX
+file descriptors are currently open in the calling process.
+.It Er ENFILE
+The maximum allowable number of files is currently open in the system.
+.El
+.Pp
+The
+.Fn posix_openpt
+function may fail if:
+.Bl -tag -width Er
+.It Er EINVAL
+The value of
+.Fa oflag
+is not valid.
+.It Er EAGAIN
+The system has run out of pseudo-terminal resources.
+.It Er ENOSR
+The system has run out of STREAMS resources.
+.El
+.Sh USAGE
+This function provides a portable method for obtaining the file descriptor of a
+manager terminal device for a pseudo-terminal, as opposed to using
+.Xr open 2
+on the
+.Xr ptm 7D
+device which is system-specific.
+.Pp
+The
+.Xr grantpt 3C
+function can be used to manipulate the mode and ownership permissions
+of the subsidiary device.
+The
+.Xr ptsname 3C
+function can be used to obtain the name of the subsidiary device.
+.Sh INTERFACE STABILITY
+.Sy Committed
+.Sh MT LEVEL
+.Sy MT-Safe
+.Sh SEE ALSO
+.Xr open 2 ,
+.Xr grantpt 3C ,
+.Xr ptsname 3C ,
+.Xr unlockpt 3C ,
+.Xr attributes 5 ,
+.Xr standards 5 ,
+.Xr ptm 7D ,
+.Xr pts 7D
diff --git a/usr/src/man/man3c/ptsname.3c b/usr/src/man/man3c/ptsname.3c
index 8fa25e2ea6..264a3dcc90 100644
--- a/usr/src/man/man3c/ptsname.3c
+++ b/usr/src/man/man3c/ptsname.3c
@@ -43,59 +43,72 @@
 .\" Copyright 1989 AT&T
 .\" Portions Copyright (c) 1992, X/Open Company Limited  All Rights Reserved
 .\" Copyright (c) 2002, Sun Microsystems, Inc.  All Rights Reserved.
+.\" Copyright 2022 Oxide Computer Company
 .\"
-.TH PTSNAME 3C "Aug 14, 2002"
-.SH NAME
-ptsname \- get name of the slave pseudo-terminal device
-.SH SYNOPSIS
-.LP
-.nf
-#include <stdlib.h>
-
-\fBchar *\fR\fBptsname\fR(\fBint\fR \fIfildes\fR);
-.fi
-
-.SH DESCRIPTION
-.sp
-.LP
-The \fBptsname()\fR function returns the name of the slave pseudo-terminal
-device associated with a master pseudo-terminal device. \fIfildes\fR is a file
-descriptor returned from a successful open of the master device.
-\fBptsname()\fR returns a pointer to a string containing the null-terminated
-path name of the slave device of the form \fB/dev/pts/N\fR, where \fBN\fR is a
-non-negative integer.
-.SH RETURN VALUES
-.sp
-.LP
-Upon successful completion, the function \fBptsname()\fR returns a pointer to a
-string which is the name of the pseudo-terminal slave device. This value points
-to a static data area that is overwritten by each call to \fBptsname()\fR. Upon
-failure, \fBptsname()\fR returns \fINULL\fR. This could occur if \fIfildes\fR
-is an invalid file descriptor or if  the slave device name does not exist in
-the file system.
-.SH ATTRIBUTES
-.sp
-.LP
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
-Interface Stability	Standard
-_
-MT-Level	Safe
-.TE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBopen\fR(2), \fBgrantpt\fR(3C), \fBttyname\fR(3C), \fBunlockpt\fR(3C),
-\fBattributes\fR(5), \fBstandards\fR(5)
-.sp
-.LP
-\fISTREAMS Programming Guide\fR
+.Dd February 5, 2022
+.Dt PTSNAME 3C
+.Os
+.Sh NAME
+.Nm ptsname
+.Nd get the name of the subsidiary device of a pseudo-terminal
+.Sh SYNOPSIS
+.In stdlib.h
+.Ft char *
+.Fo ptsname
+.Fa "int fildes"
+.Fc
+.Sh DESCRIPTION
+The
+.Fn ptsname
+function returns the name of the pseudo-terminal subsidiary device associated
+with a pseudo-terminal manager device.
+The
+.Fa fildes
+argument is a file descriptor returned from a successful open of the
+pseudo-terminal manager device; e.g., by calling
+.Xr posix_openpt 3C
+or by performing an
+.Xr open 2
+of the
+.Xr ptm 7D
+device.
+.Pp
+The
+.Fn ptsname
+function returns a pointer to a string containing the null-terminated
+path name of the subsidiary device.
+This string is of the form
+.Pa /dev/pts/N ,
+where
+.Sy N
+is a non-negative integer.
+.Sh RETURN VALUES
+If successful, the
+.Fn ptsname
+function returns a pointer to a string which is the name of the pseudo-terminal
+subsidiary device.
+This value points to a static data area that is overwritten by each call to
+.Fn ptsname .
+.Pp
+Upon failure,
+.Fn ptsname
+returns
+.Dv NULL .
+This could occur if
+.Fa fildes
+is an invalid file descriptor or if the subsidiary device name does not exist
+in the file system.
+.Sh INTERFACE STABILITY
+.Sy Committed
+.Sh MT LEVEL
+.Sy Safe
+.Sh SEE ALSO
+.Xr open 2 ,
+.Xr grantpt 3C ,
+.Xr posix_openpt 3C ,
+.Xr ttyname 3C ,
+.Xr unlockpt 3C ,
+.Xr attributes 5 ,
+.Xr standards 5 ,
+.Xr ptm 7D ,
+.Xr pts 7D
diff --git a/usr/src/man/man3c/unlockpt.3c b/usr/src/man/man3c/unlockpt.3c
index 598a56717d..865c217e32 100644
--- a/usr/src/man/man3c/unlockpt.3c
+++ b/usr/src/man/man3c/unlockpt.3c
@@ -43,78 +43,69 @@
 .\" Copyright 1989 AT&T
 .\" Copyright (c) 1997, The Open Group. All Rights Reserved.
 .\" Portions Copyright (c) 2002, Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2022 Oxide Computer Company
 .\"
-.TH UNLOCKPT 3C "Aug 14, 2002"
-.SH NAME
-unlockpt \- unlock a pseudo-terminal master/slave pair
-.SH SYNOPSIS
-.LP
-.nf
-#include <stdlib.h>
-
-\fBint\fR \fBunlockpt\fR(\fBint\fR \fIfildes\fR);
-.fi
-
-.SH DESCRIPTION
-.sp
-.LP
-The \fBunlockpt()\fR function unlocks the slave pseudo-terminal device
-associated with the master to which \fIfildes\fR refers.
-.sp
-.LP
-Portable applications must call \fBunlockpt()\fR before opening the slave side
-of a pseudo-terminal device.
-.SH RETURN VALUES
-.sp
-.LP
-Upon successful completion, \fBunlockpt()\fR returns \fB0\fR. Otherwise, it
-returns \fB\(mi1\fR and sets \fBerrno\fR to indicate the error.
-.SH ERRORS
-.sp
-.LP
-The \fBunlockpt()\fR function may fail if:
-.sp
-.ne 2
-.na
-\fB\fBEBADF\fR\fR
-.ad
-.RS 10n
-The \fIfildes\fR argument is not a file descriptor open for writing.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBEINVAL\fR\fR
-.ad
-.RS 10n
-The \fIfildes\fR argument is not associated with a master pseudo-terminal
-device.
-.RE
-
-.SH ATTRIBUTES
-.sp
-.LP
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
-Interface Stability	Standard
-_
-MT-Level	Safe
-.TE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBopen\fR(2), \fBgrantpt\fR(3C), \fBptsname\fR(3C), \fBattributes\fR(5),
-\fBstandards\fR(5)
-.sp
-.LP
-\fISTREAMS Programming Guide\fR
+.Dd February 5, 2022
+.Dt UNLOCKPT 3C
+.Os
+.Sh NAME
+.Nm unlockpt
+.Nd unlock a pseudo-terminal device pair
+.Sh SYNOPSIS
+.In stdlib.h
+.Ft int
+.Fo unlockpt
+.Fa "int fildes"
+.Fc
+.Sh DESCRIPTION
+When a pseudo-terminal manager device is opened, whether through
+.Xr posix_openpt 3C
+or
+.Xr open 2
+on a
+.Xr ptm 7D
+device, the subsidiary device begins operation in a locked state.
+The
+.Fn unlockpt
+function unlocks the pseudo-terminal subsidiary device associated with the
+manager device to which
+.Fa fildes
+refers.
+.Pp
+Portable applications must call
+.Fn unlockpt
+before opening the pseudo-terminal subsidiary device.
+.Sh RETURN VALUES
+.Rv -std unlockpt
+.Sh EXAMPLES
+See
+.Xr posix_openpt 3C
+for an example that includes a call to
+.Fn unlockpt .
+.Sh ERRORS
+The
+.Fn unlockpt
+function may fail if:
+.Bl -tag -width Er
+.It Er EBADF
+The
+.Fa fildes
+argument is not a file descriptor open for writing.
+.It Er EINVAL
+EINVAL
+The
+.Fa fildes
+argument is not associated with a pseudo-terminal manager device.
+.El
+.Sh INTERFACE STABILITY
+.Sy Committed
+.Sh MT LEVEL
+.Sy Safe
+.Sh SEE ALSO
+.Xr open 2 ,
+.Xr grantpt 3C ,
+.Xr posix_openpt 3C ,
+.Xr ptsname 3C ,
+.Xr attributes 5 ,
+.Xr standards 5 ,
+.Xr ptm 7D
diff --git a/usr/src/man/man3utempter/utempter_add_record.3utempter b/usr/src/man/man3utempter/utempter_add_record.3utempter
index da6cbb7211..21f0f44a94 100644
--- a/usr/src/man/man3utempter/utempter_add_record.3utempter
+++ b/usr/src/man/man3utempter/utempter_add_record.3utempter
@@ -23,7 +23,7 @@
 .\" SUCH DAMAGE.
 .\"
 .\"
-.Dd May 5, 2020
+.Dd February 5, 2022
 .Dt UTEMPTER_ADD_RECORD 3UTEMPTER
 .Os
 .Sh NAME
@@ -67,7 +67,7 @@ and
 .Fn addToUtmp
 functions add a login record to the
 .Xr utmpx 4
-database for the TTY belonging to the pseudo-terminal master file descriptor
+database for the TTY belonging to the pseudo-terminal manager file descriptor
 .Fa fd ,
 using the username corresponding with the real user ID of the calling
 process and the optional hostname
@@ -83,7 +83,7 @@ The
 and
 .Fn removeLineFromUtmp
 functions mark the login session as being closed for the TTY belonging
-to the pseudo-terminal master file descriptor
+to the pseudo-terminal manager file descriptor
 .Fa fd .
 .Pp
 The
diff --git a/usr/src/man/man7d/Makefile b/usr/src/man/man7d/Makefile
index af38c7a9bd..78b9601e29 100644
--- a/usr/src/man/man7d/Makefile
+++ b/usr/src/man/man7d/Makefile
@@ -16,7 +16,7 @@
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
 # Copyright 2018 Nexenta Systems, Inc.
 # Copyright 2020 Peter Tribble
-# Copyright 2021 Oxide Computer Company
+# Copyright 2022 Oxide Computer Company
 #
 
 include		$(SRC)/Makefile.master
@@ -105,7 +105,6 @@ _MANFILES=	aac.7d		\
 		poll.7d		\
 		profile.7d	\
 		ptm.7d		\
-		pts.7d		\
 		pty.7d		\
 		qlc.7d		\
 		ramdisk.7d	\
@@ -256,6 +255,7 @@ _MANLINKS=	1394.7d		\
 		firewire.7d	\
 		kmem.7d		\
 		lo0.7d		\
+		pts.7d		\
 		ticots.7d	\
 		ticotsord.7d	\
 		urandom.7d	\
@@ -279,6 +279,8 @@ firewire.7d	:= LINKSRC = ieee1394.7d
 
 lo0.7d		:= LINKSRC = ipnet.7d
 
+pts.7d		:= LINKSRC = ptm.7d
+
 allkmem.7d	:= LINKSRC = mem.7d
 kmem.7d		:= LINKSRC = mem.7d
 
diff --git a/usr/src/man/man7d/ptm.7d b/usr/src/man/man7d/ptm.7d
index 83c7830293..adf66469bc 100644
--- a/usr/src/man/man7d/ptm.7d
+++ b/usr/src/man/man7d/ptm.7d
@@ -4,89 +4,255 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PTM 7D "Feb 5, 1997"
-.SH NAME
-ptm \- STREAMS pseudo-tty master driver
-.SH DESCRIPTION
-.sp
-.LP
-The pseudo-tty subsystem simulates a terminal connection, where the master side
-represents the terminal and the slave represents the user process's special
-device end point. In order to use the pseudo-tty subsystem, a node for the
-master side driver \fB/dev/ptmx\fR and \fBN\fR number of nodes for the slave
-driver must be installed. See \fBpts\fR(7D). The master device is set up as a
-cloned device where its major device number is the major for the clone device
-and its minor device number is the major for the \fBptm\fR driver. There are no
-nodes in the file system for master devices. The master pseudo driver is opened
-using the \fBopen\fR(2) system call with \fB/dev/ptmx\fR as the device
-parameter. The clone open finds the next available minor device for the
-\fBptm\fR major device.
-.sp
-.LP
-A master device is available only if it and its corresponding slave device are
-not already open. When the master device is opened, the corresponding slave
-device is automatically locked out. Only one open is allowed on a master
-device.  Multiple opens are allowed on the slave device. After both the master
-and slave have been opened, the user has two file descriptors which are the end
-points of a full duplex connection composed of two streams which are
-automatically connected at the master and slave drivers. The user may then push
-modules onto either side of the stream pair.
-.sp
-.LP
-The master and slave drivers pass all messages to their adjacent queues. Only
-the \fBM_FLUSH\fR needs some processing. Because the read queue of one side is
-connected to the write queue of the other, the \fBFLUSHR\fR flag is changed to
-the \fBFLUSHW\fR flag and vice versa. When the master device is closed an
-\fBM_HANGUP\fR message is sent to the slave device which will render the device
-unusable. The process on the slave side gets the errno \fBEIO\fR when
-attempting to write on that stream but it will be able to read any data
-remaining on the stream head read queue. When all the data has been read,
-\fBread()\fR returns 0 indicating that the stream can no longer be used. On the
-last close of the slave device, a 0-length message is sent to the master
-device. When the application on the master side issues a \fBread()\fR or
-\fBgetmsg()\fR and 0 is returned, the user of the master device decides whether
-to issue a \fBclose()\fR that dismantles the pseudo-terminal subsystem. If the
-master device is not closed, the pseudo-tty subsystem will be available to
-another user to open the slave device.
-.sp
-.LP
-If \fBO_NONBLOCK\fR or \fBO_NDELAY\fR is set, read on the master side returns
-\(mi1 with errno set to \fBEAGAIN\fR if no data is available, and write returns
-\(mi1 with errno set to \fBEAGAIN\fR if there is internal flow control.
-.SH IOCTLS
-.sp
-.LP
-The master driver supports the \fBISPTM\fR and \fBUNLKPT\fR ioctls that are
-used by the functions \fBgrantpt\fR(3C), \fBunlockpt\fR(3C) and
-\fBptsname\fR(3C). The ioctl \fBISPTM\fR determines whether the file descriptor
-is that of an open master device. On success, it returns the 0. The ioctl
-\fBUNLKPT\fR unlocks the master and slave devices. It returns 0 on success. On
-failure, the errno is set to \fBEINVAL\fR indicating that the master device is
-not open.
-.SH FILES
-.sp
-.ne 2
-.na
-\fB\fB/dev/ptmx\fR\fR
-.ad
-.RS 14n
-master clone device
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fB/dev/pts/M\fR\fR
-.ad
-.RS 14n
-slave devices (M = 0 -> N-1)
-.RE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBgrantpt\fR(3C), \fBptsname\fR(3C), \fBunlockpt\fR(3C), \fBpckt\fR(7M),
-\fBpts\fR(7D)
-.sp
-.LP
-\fISTREAMS Programming Guide\fR
+.\" Copyright 2022 Oxide Computer Company
+.Dd February 5, 2022
+.Dt PTM 7D
+.Os
+.Sh NAME
+.Nm ptm ,
+.Nm pts
+.Nd STREAMS pseudo-terminal manager and subsidiary drivers
+.Sh SYNOPSIS
+.Pa /dev/ptmx
+.Pp
+.Pa /dev/pts/*
+.Sh DESCRIPTION
+The pseudo-terminal subsystem simulates a terminal connection, where the
+manager side represents the terminal and the subsidiary represents the user
+process's special device end point.
+The manager device is set up as a cloned device where its major device number
+is the major for the clone device and its minor device number is the major for
+the
+.Nm ptm
+driver; see
+.Dv CLONE_DEV
+in
+.Xr ddi_create_minor_node 9F .
+.Pp
+There are no nodes in the file system for manager devices.
+The manager pseudo driver is opened using the
+.Xr open 2
+system call with
+.Pa /dev/ptmx
+as the device parameter.
+The clone open finds the next available minor device for the
+.Nm ptm
+major device.
+.Pp
+A manager device is only available if it and its corresponding subsidiary
+device are not already open.
+Only one open is allowed on a manager device.
+Multiple opens are allowed on the subsidiary device.
+.Pp
+When the manager device is opened, the corresponding subsidiary device is
+automatically locked out.
+No user may open the subsidiary device until its permissions are adjusted and
+the device is unlocked by calling the functions
+.Xr grantpt 3C
+and
+.Xr unlockpt 3C .
+The user can then invoke the
+.Xr open 2
+system call with the device name returned by the
+.Xr ptsname 3C
+function.
+.Pp
+After both the manager and subsidiary have been opened, the user has two file
+descriptors which are the end points of a full duplex connection composed of
+two streams which are automatically connected at the manager and subsidiary
+drivers.
+The user may then push modules onto either side of the stream pair.
+Unless compiled in XPG4v2 mode
+.Po
+see
+.Sx "XPG4v2 MODE"
+.Pc ,
+the consumer needs to push the
+.Xr ptem 7M
+and
+.Xr ldterm 7M
+modules onto the subsidiary device to get terminal semantics.
+.Pp
+The manager and subsidiary drivers pass all messages to their adjacent queues.
+Only the
+.Dv M_FLUSH
+needs some processing.
+Because the read queue of one side is connected to the write queue of the
+other, the
+.Dv FLUSHR
+flag is changed to the
+.Dv FLUSHW
+flag and vice versa.
+.Pp
+When the manager device is closed, an
+.Dv M_HANGUP
+message is sent to the subsidiary device which will render the device unusable.
+The process on the subsidiary side gets an
+.Er EIO
+error when attempting to write on that stream, but it will be able to read
+any data remaining on the stream head read queue.
+When all the data has been read,
+.Xr read 2
+returns
+.Sy 0
+indicating that the stream can no longer be used.
+.Pp
+On the last close of the subsidiary device, a 0-length message is sent to the
+manager device.
+When the application on the manager side issues a
+.Xr read 2
+or
+.Xr getmsg 2
+and
+.Sy 0
+is returned, the user of the manager device decides whether to issue a
+.Xr close 2
+that dismantles the entire pseudo-terminal.
+If the manager device is not closed, the pseudo-terminal will be available to
+another user to open the subsidiary device.
+.Pp
+Since 0-length messages are used to indicate that the process on the
+subsidiary side has closed, and should be interpreted that way by the process
+on the manager side, applications on the subsidiary side should not write
+0-length messages.
+Unless the application is compiled in XPG4v2 mode
+.Po
+see
+.Sx "XPG4v2 MODE"
+.Pc ,
+then any 0-length messages written to the subsidiary device will be discarded
+by the
+.Xr ptem 7M
+module.
+.Pp
+If
+.Dv O_NONBLOCK
+or
+.Dv O_NDELAY
+is set on the manager side:
+.Bl -bullet
+.It
+Read on the manager side returns
+.Sy -1
+with
+.Va errno
+set to
+.Er EAGAIN
+if no data is available
+.It
+Write returns
+.Sy -1
+with
+.Va errno
+set to
+.Er EAGAIN
+if there is internal flow control
+.El
+.Pp
+Standard STREAMS system calls can access pseudo-terminal devices.
+The subsidiary devices support the
+.Dv O_NDELAY
+and
+.Dv O_NONBLOCK
+flags.
+.Sh XPG4v2 MODE
+.Em XPG4v2
+requires that subsidiary pseudo-terminal devices provide the process with an
+interface that is identical to the terminal interface, without needing to
+explicitly push any modules to achieve this.
+It also requires that 0-length messages written on the subsidiary device will
+be propagated to the manager device.
+.Pp
+Experience has shown that most software does not expect subsidiary
+pseudo-terminal devices to operate in this manner.
+This XPG4v2-compliant behaviour is only enabled in XPG4v2/SUS
+.Po
+see
+.Xr standards 5
+.Pc
+mode.
+.Sh IOCTLS
+The manager driver provides several ioctls to support the
+.Xr grantpt 3C ,
+.Xr unlockpt 3C ,
+and
+.Xr ptsname 3C
+functions:
+.Bl -tag -width Ds
+.It Dv ISPTM
+Determines whether the file descriptor is that of an open manager device.
+On success, it returns the value
+.Sy 0 .
+.It Dv UNLKPT
+Unlocks the manager and subsidiary devices.
+It returns
+.Sy 0
+on success.
+On failure,
+.Vt errno
+is set to
+.Vt EINVAL
+indicating that the manager device is not open.
+.El
+.Sh FILES
+.Bl -tag -width Pa
+.It Pa /dev/ptmx
+Pseudo-terminal manager clone device.
+.It Pa /dev/pts/N
+Pseudo-terminal subsidiary devices, where
+.Sy N
+is a non-negative integer.
+Located via calls to
+.Xr ptsname 3C .
+.El
+.Sh EXAMPLES
+.Sy Example 1
+Opening the manager and subsidiary device for a pseudo-terminal.
+.Bd -literal -offset Ds
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stropts.h>
+#include <fcntl.h>
+#include <err.h>
+\&...
+int fdm, fds;
+char *subsidiaryname;
+\&...
+/*
+ * NOTE: Portable applications should use posix_openpt(3C) here:
+ */
+if ((fdm = open("/dev/ptmx", O_RDWR | O_NOCTTY)) < 0) {
+        err(1, "open manager");
+}
+if (grantpt(fdm) != 0 || unlockpt(fdm) != 0 ||
+    (subsidiaryname = ptsname(fdm)) == NULL) {
+        close(fdm);
+        err(1, "locate subsidiary");
+}
+if ((fds = open(subsidiaryname, O_RDWR | O_NOCTTY)) < 0) {
+        close(fdm);
+        err(1, "open subsidiary");
+}
+if (ioctl(fds, I_PUSH, "ptem") != 0 ||
+    ioctl(fds, I_PUSH, "ldterm") != 0) {
+        close(fds);
+        close(fdm);
+        err(1, "push modules");
+}
+.Ed
+.Sh SEE ALSO
+.Xr close 2 ,
+.Xr getmsg 2 ,
+.Xr open 2 ,
+.Xr read 2 ,
+.Xr grantpt 3C ,
+.Xr posix_openpt 3C ,
+.Xr ptsname 3C ,
+.Xr unlockpt 3C ,
+.Xr standards 5 ,
+.Xr ldterm 7M ,
+.Xr pckt 7M ,
+.Xr ptem 7M ,
+.Xr ddi_create_minor_node 9F
diff --git a/usr/src/man/man7d/pts.7d b/usr/src/man/man7d/pts.7d
deleted file mode 100644
index 6ac5bbcbd1..0000000000
--- a/usr/src/man/man7d/pts.7d
+++ /dev/null
@@ -1,107 +0,0 @@
-'\" te
-.\" Copyright 2020 OmniOS Community Edition (OmniOSce) Association.
-.\"  Copyright 1992 Sun Microsystems
-.\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
-.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
-.\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PTS 7D "Feb 29, 2020"
-.SH NAME
-pts \- STREAMS pseudo-tty slave driver
-.SH DESCRIPTION
-The pseudo-tty subsystem simulates a terminal connection, where the master side
-represents the terminal and the slave represents the user process's special
-device end point. In order to use the pseudo-tty subsystem, a node for the
-master side driver \fB/dev/ptmx\fR and N nodes for the slave driver (N is
-determined at installation time) must be installed. The names of the slave
-devices are \fB/dev/pts/M\fR where \fBM\fR has the values 0 through N-1. When
-the master device is opened, the corresponding slave device is automatically
-locked out. No user may open that slave device until its permissions are
-adjusted and the device unlocked by calling functions \fBgrantpt\fR(3C) and
-\fBunlockpt\fR(3C). The user can then invoke the open system call with the name
-that is returned by the \fBptsname\fR(3C) function. See the example below.
-.sp
-.LP
-Only one open is allowed on a master device. Multiple opens are allowed on the
-slave device. After both the master and slave have been opened, the user has
-two file descriptors which are end points of a full duplex connection composed
-of two streams automatically connected at the master and slave drivers. The
-user may then push modules onto either side of the stream pair. Unless compiled
-in XPG4v2 mode (see below), the consumer needs to push the \fBptem\fR(7M) and
-\fBldterm\fR(7M) modules onto the slave side of the pseudo-terminal subsystem
-to get terminal semantics.
-.sp
-.LP
-The master and slave drivers pass all messages to their adjacent queues. Only
-the \fBM_FLUSH\fR needs some processing. Because the read queue of one side is
-connected to the write queue of the other, the \fBFLUSHR\fR flag is changed to
-the \fBFLUSHW\fR flag and vice versa. When the master device is closed an
-\fBM_HANGUP\fR message is sent to the slave device which will render the device
-unusable. The process on the slave side gets the errno \fBEIO\fR when
-attempting to write on that stream but it will be able to read any data
-remaining on the stream head read queue. When all the data has been read, read
-returns 0 indicating that the stream can no longer be used. On the last close
-of the slave device, a 0-length message is sent to the master device. When the
-application on the master side issues a \fBread()\fR or \fBgetmsg()\fR and 0 is
-returned, the user of the master device decides whether to issue a
-\fBclose()\fR that dismantles the pseudo-terminal subsystem. If the master
-device is not closed, the pseudo-tty subsystem will be available to another
-user to open the slave device. Since 0-length messages are used to indicate
-that the process on the slave side has closed and should be interpreted that
-way by the process on the master side, applications on the slave side should
-not write 0-length messages. Unless the application is compiled in XPG4v2 mode
-(see below) then any 0-length messages written on the slave side will be
-discarded by the \fBptem\fR module.
-.sp
-.LP
-The standard STREAMS system calls can access the pseudo-tty devices. The slave
-devices support the \fBO_NDELAY\fR and \fBO_NONBLOCK\fR flags.
-.SH XPG4v2 MODE
-XPG4v2 requires that open of a slave pseudo terminal device provides the
-process with an interface that is identical to the terminal interface (without
-having to explicitly push any modules to achieve this). It also requires that
-0-length messages written on the slave side will be propagated to the master.
-.sp
-Experience has shown, however, that most software does not expect slave pty
-devices to operate in this manner and therefore this XPG4v2-compliant
-behaviour is only enabled in XPG4v2/SUS (see \fBstandards\fR(5)) mode.
-.SH EXAMPLES
-.in +2
-.nf
-int    fdm fds;
-char   *slavename;
-extern char *ptsname();
-
-fdm = open("/dev/ptmx", O_RDWR);  /* open master */
-grantpt(fdm);                     /* change permission of	slave */
-unlockpt(fdm);                    /* unlock slave */
-slavename = ptsname(fdm);         /* get name of slave */
-fds = open(slavename, O_RDWR);    /* open slave */
-ioctl(fds, I_PUSH, "ptem");       /* push ptem */
-ioctl(fds, I_PUSH, "ldterm");     /* push ldterm*/
-.fi
-.in -2
-
-.SH FILES
-.ne 2
-.na
-\fB\fB/dev/ptmx\fR\fR
-.ad
-.RS 14n
-master clone device
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fB/dev/pts/M\fR\fR
-.ad
-.RS 14n
-slave devices (M = 0 -> N-1)
-.RE
-
-.SH SEE ALSO
-\fBgrantpt\fR(3C), \fBptsname\fR(3C), \fBunlockpt\fR(3C), \fBldterm\fR(7M),
-\fBptm\fR(7D), \fBptem\fR(7M), \fBstandards\fR(5)
-.sp
-.LP
-\fISTREAMS Programming Guide\fR
diff --git a/usr/src/man/man7d/pty.7d b/usr/src/man/man7d/pty.7d
index e2f85c3224..8e14dd3ea2 100644
--- a/usr/src/man/man7d/pty.7d
+++ b/usr/src/man/man7d/pty.7d
@@ -3,244 +3,263 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PTY 7D "Aug 8, 1994"
-.SH NAME
-pty \- pseudo-terminal driver
-.SH DESCRIPTION
-.sp
-.LP
-The \fBpty\fR driver provides support for a pair of devices collectively known
-as a \fIpseudo-terminal\fR. The two devices comprising a pseudo-terminal are
-known as a \fIcontroller\fR and a \fIslave\fR. The slave device distinguishes
-between the \fBB0\fR baud rate and other baud rates specified in the
-\fBc_cflag\fR word of the \fBtermios\fR structure, and the \fBCLOCAL\fR flag in
-that word. It does not support any of the other \fBtermio\fR(7I) device control
-functions specified by flags in the \fBc_cflag\fR word of the \fBtermios\fR
-structure and by the \fB\fR\fBIGNBRK\fR\fB, \fR \fB\fR\fBIGNPAR\fR\fB, \fR
-\fB\fR\fBPARMRK\fR\fB, \fR or \fBINPCK\fR flags in the \fBc_iflag\fR word of
-the \fBtermios\fR structure, as these functions apply only to asynchronous
-serial ports.  All other \fBtermio\fR(7I) functions must be performed by
-\fBSTREAMS\fR modules pushed atop the driver; when a slave device is opened,
-the \fBldterm\fR(7M) and \fBttcompat\fR(7M) \fBSTREAMS\fR modules are
-automatically pushed on top of the stream, providing the standard
-\fBtermio\fR(7I) interface.
-.sp
-.LP
+.\" Copyright 2022 Oxide Computer Company
+.Dd February 5, 2022
+.Dt PTY 7D
+.Os
+.Sh NAME
+.Nm pty
+.Nd legacy pseudo-terminal driver
+.Sh SYNOPSIS
+.Pa /dev/pty[p-r]*
+.Pp
+.Pa /dev/tty[p-r]*
+.Sh DESCRIPTION
+This driver provides support for legacy static pseudo-terminal devices.
+Modern software does not use this driver, preferring instead the STREAMS-based
+.Xr ptm 7D
+and
+.Xr pts 7D
+pseudo-terminal drivers, consumed through the portable
+.Xr posix_openpt 3C
+interface.
+.Pp
+The
+.Nm pty
+driver provides support for a pair of devices collectively known
+as a
+.Em pseudo-terminal .
+The two devices comprising a pseudo-terminal are known as a
+.Em manager
+and a
+.Em subsidiary .
+The subsidiary device distinguishes between the
+.Dv B0 baud rate and other baud rates specified in
+the
+.Fa c_cflag
+field of the
+.Vt termios
+structure, and the
+.Dv CLOCAL
+flag in that member.
+It does not support any of the other
+.Xr termio 7I
+device control functions specified by flags in the
+.Fa c_cflag
+field of the
+.Vt termios
+structure and by the
+.Dv IGNBRK ,
+.Dv IGNPAR ,
+.Dv PARMRK ,
+or
+.Dv INPCK
+flags in the
+.Fa c_iflag
+field of the
+.Vt termios
+structure, as these functions apply only to asynchronous serial ports.
+All other
+.Xr termio 7I
+functions must be performed by STREAMS modules pushed atop the driver; when a
+subsidiary device is opened, the
+.Xr ldterm 7M
+and
+.Xr ttcompat 7M
+STREAMS modules are automatically pushed on top of the stream, providing the
+standard
+.Xr termio 7I
+interface.
+.Pp
 Instead of having a hardware interface and associated hardware that supports
 the terminal functions, the functions are implemented by another process
-manipulating the controller device of the pseudo-terminal.
-.sp
-.LP
-The controller and the slave devices of the pseudo-terminal are tightly
-connected. Any data written on the controller device is given to the slave
-device as input, as though it had been received from a hardware interface. Any
-data written on the slave terminal can be read from the controller device
-(rather than being transmitted from a \fBUAR\fR).
-.sp
-.LP
-By default, 48 pseudo-terminal pairs are configured as follows:
-.sp
-.in +2
-.nf
-/dev/pty[p-r][0-9a-f] controller devices
-/dev/tty[p-r][0-9a-f] slave devices
-.fi
-.in -2
-
-.SH IOCTLS
-.sp
-.LP
-The standard set of \fBtermio ioctl\fRs are supported by the slave device.
-None of the bits in the \fBc_cflag\fR word have any effect on the
-pseudo-terminal, except that if the baud rate is set to \fBB0\fR, it will
-appear to the process on the controller device as if the last process on the
-slave device had closed the line; thus, setting the baud rate to \fBB0\fR has
-the effect of ``hanging up'' the pseudo-terminal, just as it has the effect of
-``hanging up'' a real terminal.
-.sp
-.LP
-There is no notion of ``parity'' on a pseudo-terminal, so none of the flags in
-the \fBc_iflag\fR word that control the processing of parity errors have any
-effect. Similarly, there is no notion of a ``break'', so none of the flags that
-control the processing of breaks, and none of the \fBioctl\fRs that generate
-breaks, have any effect.
-.sp
-.LP
+manipulating the manager device of the pseudo-terminal.
+.Pp
+The manager and the subsidiary devices of the pseudo-terminal are tightly
+connected.
+Any data written on the manager device is given to the subsidiary device as
+input, as though it had been received from a hardware interface.
+Any data written on the subsidiary terminal can be read from the manager device
+.Pq "rather than being transmitted from a UAR" .
+.Pp
+The driver is statically configured to provide 48 pseudo-terminal pairs.
+Software that requires dynamic pseudo-terminal devices, or a greater number
+of devices, must be converted to use
+.Xr ptm 7D .
+.Sh IOCTLS
+The standard set of
+.Xr termio 7I
+ioctls are supported by the subsidiary device.
+None of the bits in the
+.Fa c_cflag
+field have any effect on the pseudo-terminal, except that if the baud rate is
+set to
+.Dv B0 ,
+it will appear to the process on the manager device as if the last process on
+the subsidiary device had closed the line; thus, setting the baud rate to
+.Dv B0
+has the effect of
+.Dq hanging up
+the pseudo-terminal, just as it has the effect of
+.Dq hanging up
+a real terminal.
+.Pp
+There is no notion of
+.Dq parity
+on a pseudo-terminal, so none of the flags in the
+.Fa c_iflag
+field that control the processing of parity errors have any
+effect.
+Similarly, there is no notion of a
+.Fa break ,
+so none of the flags that control the processing of breaks, and none of the
+ioctls that generate breaks, have any effect.
+.Pp
 Input flow control is automatically performed; a process that attempts to write
-to the controller device will be blocked if too much unconsumed data is
-buffered on the slave device.  The input flow control provided by the
-\fBIXOFF\fR flag in the \fBc_iflag\fR word is not supported.
-.sp
-.LP
-The delays specified in the \fBc_oflag\fR word are not supported.
-.sp
-.LP
-As there are no modems involved in a pseudo-terminal, the \fBioctl\fRs that
-return or alter the state of modem control lines are silently ignored.
-.sp
-.LP
-A few special \fBioctl\fRs are provided on the controller devices of
-pseudo-terminals to provide the functionality needed by applications programs
-to emulate real hardware interfaces:
-.sp
-.ne 2
-.na
-\fB\fBTIOCSTOP\fR\fR
-.ad
-.RS 14n
-The argument is ignored. Output to the pseudo-terminal is suspended, as if a
-\fBSTOP\fR character had been typed.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCSTART\fR\fR
-.ad
-.RS 14n
-The argument is ignored. Output to the pseudo-terminal is restarted, as if a
-\fBSTART\fR character had been typed.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT\fR\fR
-.ad
-.RS 14n
-The argument is a pointer to an \fBint\fR. If the value of the \fBint\fR is
-non-zero, \fIpacket\fR mode is enabled; if the value of the \fBint\fR is zero,
-packet mode is disabled. When a pseudo-terminal is in packet mode, each
-subsequent \fBread\fR(2) from the controller device will return data written on
-the slave device preceded by a zero byte (symbolically defined as
-\fB\fR\fBTIOCPKT_DATA\fR\fB), \fR or a single byte reflecting control status
-information.  In the latter case, the byte is an inclusive-or of zero or more
-of the bits:
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT_FLUSHREAD\fR\fR
-.ad
-.RS 22n
-whenever the read queue for the terminal is flushed.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT_FLUSHWRITE\fR\fR
-.ad
-.RS 22n
-whenever the write queue for the terminal is flushed.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT_STOP\fR\fR
-.ad
-.RS 22n
-whenever output to the terminal is stopped using ^S.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT_START\fR\fR
-.ad
-.RS 22n
-whenever output to the terminal is restarted.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT_DOSTOP\fR\fR
-.ad
-.RS 22n
-whenever \fBXON/XOFF\fR flow control is enabled after being disabled; it is
-considered ``enabled'' when the \fBIXON\fR flag in the \fBc_iflag\fR word is
-set, the \fBVSTOP\fR member of the \fBc_cc\fR array is ^S and the \fBVSTART\fR
-member of the \fBc_cc\fR array is ^Q.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCPKT_NOSTOP\fR\fR
-.ad
-.RS 22n
-whenever \fBXON/XOFF\fR flow control is disabled after being enabled.
-.RE
-
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fBTIOCREMOTE\fR\fR
-.ad
-.RS 14n
-The argument is a pointer to an \fBint\fR. If the value of the \fBint\fR is
-non-zero, \fIremote\fR mode is enabled; if the value of the \fBint\fR is zero,
-remote mode is disabled. This mode can be enabled or disabled independently of
-packet mode. When a pseudo-terminal is in remote mode, input to the slave
-device of the pseudo-terminal is flow controlled and not input edited
-(regardless of the mode the slave side of the pseudo-terminal). Each write to
-the controller device produces a record boundary for the process reading the
-slave device.  In normal usage, a write of data is like the data typed as a
-line on the terminal; a write of 0 bytes is like typing an \fBEOF\fR character.
-Note: this means that a process writing to a pseudo-terminal controller in
-\fIremote\fR mode must keep track of line boundaries, and write only one line
-at a time to the controller.  If, for example, it were to buffer up several
-\fBNEWLINE\fR characters and write them to the controller with one
-\fBwrite()\fR, it would appear to a process reading from the slave as if a
-single line containing several \fBNEWLINE\fR characters had been typed (as if,
-for example, a user had typed the \fBLNEXT\fR character before typing all but
-the last of those \fBNEWLINE\fR characters). Remote mode can be used when doing
-remote line editing in a window manager, or whenever flow controlled input is
-required.
-.RE
-
-.SH EXAMPLES
-.sp
-.in +2
-.nf
-#include <fcntl.h>
-#include <sys/termios.h>
-
-int fdm fds;
-fdm = open("/dev/ptyp0, O_RDWR);  /* open master */
-fds = open("/dev/ttyp0, O_RDWR);  /* open slave */
-.fi
-.in -2
-
-.SH FILES
-.sp
-.ne 2
-.na
-\fB\fB/dev/pty[p-z][0-9a-f]\fR\fR
-.ad
-.RS 25n
-pseudo-terminal controller devices
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fB/dev/tty[p-z][0-9a-f]\fR\fR
-.ad
-.RS 25n
-pseudo-terminal slave devices
-.RE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBrlogin\fR(1), \fBrlogind\fR(1M), \fBldterm\fR(7M), \fBtermio\fR(7I),
-\fBttcompat\fR(7M),
-.SH NOTES
-.sp
-.LP
-It is apparently not possible to send an \fBEOT\fR by writing zero bytes in
-\fBTIOCREMOTE\fR mode.
+to the manager device will be blocked if too much unconsumed data is buffered
+on the subsidiary device.
+The input flow control provided by the
+.Dv IXOFF
+flag in the
+.Fa c_iflag
+field is not supported.
+.Pp
+The delays specified in the
+.Fa c_oflag
+field are not supported.
+.Pp
+As there are no modems involved in a pseudo-terminal, the ioctls that return or
+alter the state of modem control lines are silently ignored.
+.Pp
+A few special ioctls are provided on the manager devices of pseudo-terminals to
+provide the functionality needed by applications programs to emulate real
+hardware interfaces:
+.Bl -tag -width Ds
+.It Dv TIOCSTOP
+The argument is ignored.
+Output to the pseudo-terminal is suspended, as if a
+.Sy STOP
+character had been typed.
+.It Dv TIOCSTART
+The argument is ignored.
+Output to the pseudo-terminal is restarted, as if a
+.Sy START
+character had been typed.
+.It Dv TIOCPKT
+The argument is a pointer to an
+.Vt int .
+If the value of the
+.Vt int
+is non-zero,
+.Em packet
+mode is enabled; if the value of the
+.Vt int
+is zero, packet mode is disabled.
+When a pseudo-terminal is in packet mode, each subsequent
+.Xr read 2
+from the manager device will return data written on the subsidiary device
+preceded by a zero byte
+.Po
+symbolically defined as
+.Dv TIOCPKT_DATA
+.Pc ,
+or a single byte reflecting control status information.
+In the latter case, the byte is an inclusive-or of zero or more of the bits:
+.Bl -tag -width Ds
+.It Dv TIOCPKT_FLUSHREAD
+Whenever the read queue for the terminal is flushed.
+.It Dv TIOCPKT_FLUSHWRITE
+Whenever the write queue for the terminal is flushed.
+.It Dv TIOCPKT_STOP
+Whenever output to the terminal is stopped using
+.Sy ^S .
+.It Dv TIOCPKT_START
+Whenever output to the terminal is restarted.
+.It Dv TIOCPKT_DOSTOP
+Whenever
+.Em XON/XOFF
+flow control is enabled after being disabled; it is
+considered
+.Dq enabled
+when the
+.Dv IXON
+flag in the
+.Fa c_iflag
+field is set, the
+.Dv VSTOP
+member of the
+.Fa c_cc
+array is
+.Sy ^S
+and the
+.Dv VSTART
+member of the
+.Fa c_cc
+array is
+.Sy ^Q.
+.It Dv TIOCPKT_NOSTOP
+Whenever
+.Em XON/XOFF
+flow control is disabled after being enabled.
+.El
+.It Dv TIOCREMOTE
+The argument is a pointer to an
+.Vt int .
+If the value of the
+.Vt int
+is non-zero,
+.Em remote
+mode is enabled; if the value of the
+.Vt int
+is zero, remote mode is disabled.
+This mode can be enabled or disabled independently of packet mode.
+When a pseudo-terminal is in remote mode, input to the subsidiary device of the
+pseudo-terminal is flow controlled and not input edited (regardless of the mode
+the subsidiary side of the pseudo-terminal).
+.Pp
+Each write to the manager device produces a record boundary for the process
+reading the subsidiary device.
+In normal usage, a write of data is like the data typed as a line on the
+terminal; a write of 0 bytes is like typing an
+.Sy EOF
+character.
+Note: this means that a process writing to a pseudo-terminal manager in remote
+mode must keep track of line boundaries, and write only one line at a time to
+the manager.
+.Pp
+If, for example, it were to buffer up several newline characters and write them
+to the manager with one
+.Xr write 2 ,
+it would appear to a process reading from the subsidiary as if a single line
+containing several newline characters had been typed
+.Po
+as if, for example, a user had typed the literal next
+.Pq Sy LNEXT
+character before typing all but the last of those newline characters
+.Pc .
+Remote mode can be used when doing remote line editing in a window manager, or
+whenever flow controlled input is required.
+.El
+.Sh FILES
+.Bl -tag -width Pa
+.It Pa /dev/pty[p-r][0-9a-f]
+Pseudo-terminal manager devices.
+.It Pa /dev/tty[p-r][0-9a-f]
+Pseudo-terminal subsidiary devices.
+.El
+.Sh SEE ALSO
+.Xr rlogin 1 ,
+.Xr rlogind 1M ,
+.Xr posix_openpty 3C ,
+.Xr ptm 7D ,
+.Xr termio 7I ,
+.Xr ldterm 7M ,
+.Xr ttcompat 7M
+.Sh NOTES
+This is a legacy device and should not be used by new software.
+.Pp
+It is apparently not possible to send an
+.Sy EOT
+by writing zero bytes in
+.Dv TIOCREMOTE
+mode.
diff --git a/usr/src/man/man7d/zcons.7d b/usr/src/man/man7d/zcons.7d
index 433daddbcf..07df6b458e 100644
--- a/usr/src/man/man7d/zcons.7d
+++ b/usr/src/man/man7d/zcons.7d
@@ -3,73 +3,62 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH ZCONS 7D "Aug 24, 2003"
-.SH NAME
-zcons \- Zone console device driver
-.SH DESCRIPTION
-.sp
-.LP
-The \fBzcons\fR character driver exports the console for system zones. The
-driver is comprised of two "sides:" a master side with which applications in
-the global zone communicate, and a slave side, which receives I/O from the
-master side. The slave side is available in the global zones.
-.sp
-.LP
-Applications must not depend on the location of \fB/dev\fR or \fB/devices\fR
-entries exported by \fBzcons\fR. Inside a zone, the \fBzcons\fR slave  side is
-fronted by \fB/dev/console\fR and other console-related  symbolic links, which
-are used by applications that expect to write to the system console.
-.sp
-.LP
-The \fBzcons\fR driver is Sun Private, and may change in future releases.
-.SH FILES
-.sp
-.ne 2
-.na
-\fB\fB/dev/zcons/<\fIzonename\fR>/masterconsole\fR \fR
-.ad
-.sp .6
-.RS 4n
-Global zone master side console for zone <\fIzonename\fR>.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fB/dev/zcons/<\fIzonename\fR>/slaveconsole\fR \fR
-.ad
-.sp .6
-.RS 4n
-Global zone slave side console for zone <\fIzonename\fR>.
-.RE
-
-.sp
-.ne 2
-.na
-\fB\fB/dev/zconsole\fR \fR
-.ad
-.sp .6
-.RS 4n
-Non-global zone console (slave side).
-.RE
-
-.SH ATTRIBUTES
-.sp
-.LP
-See \fBattributes\fR(5) for descriptions of the following attributes:
-.sp
-
-.sp
-.TS
-box;
-c | c
-l | l .
-ATTRIBUTE TYPE	ATTRIBUTE VALUE
-_
- Interface Stability	Sun Private
-.TE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBzoneadm\fR(1M), \fBzonecfg\fR(1M), \fBattributes\fR(5), \fBzones\fR(5)
+.\" Copyright 2022 Oxide Computer Company
+.Dd February 5, 2022
+.Dt ZCONS 7D
+.Os
+.Sh NAME
+.Nm zcons
+.Nd Zone console device driver
+.Sh DESCRIPTION
+The
+.Nm zcons
+character driver exports the console for system zones.
+The driver is fundamentally similar to a pseudo-terminal device, and is thus
+comprised of two sides:
+.Bl -bullet
+.It
+a manager device, which applications in the global zone can open for
+communication
+.It
+a subsidiary device, which processes in the non-global zone can write to, to
+communicate with global zone management applications
+.El
+.Pp
+Applications must not depend on the location of
+.Pa /dev
+or
+.Pa /devices
+entries exposed by
+.Nm zcons
+in the global zone.
+Inside a non-global zone, the
+.Nm zcons
+subsidiary device is fronted by
+.Pa /dev/console
+and other console-related symbolic links, which are used by applications that
+expect to write to the system console.
+.Pp
+The
+.Nm
+driver is not a
+.Sy Committed
+interface, and may change at any time.
+.Sh FILES
+.Bl -tag -width Pa
+.It Pa /dev/zcons/ZONENAME/globalconsole
+Global zone console manager device for zone
+.Sy ZONENAME .
+.It Pa /dev/zcons/ZONENAME/zoneconsole
+Global zone console subsidiary device for zone
+.Sy ZONENAME .
+.It Pa /dev/zconsole
+Non-global zone console (subsidiary device).
+.El
+.Sh INTERFACE STABILITY
+.Sy Uncommitted
+.Sh SEE ALSO
+.Xr zoneadm 1M ,
+.Xr zonecfg 1M ,
+.Xr attributes 5 ,
+.Xr zones 5
diff --git a/usr/src/man/man7m/pckt.7m b/usr/src/man/man7m/pckt.7m
index 9cb6149cd5..909e1e0367 100644
--- a/usr/src/man/man7m/pckt.7m
+++ b/usr/src/man/man7m/pckt.7m
@@ -3,21 +3,18 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PCKT 7M "Jul 3, 1990"
+.TH PCKT 7M "Feb 5, 2022"
 .SH NAME
 pckt \- STREAMS Packet Mode module
 .SH SYNOPSIS
-.LP
 .nf
 int ioctl(\fI fd, \fRI_PUSH, "pckt");
 .fi
 
 .SH DESCRIPTION
-.sp
-.LP
 \fBpckt\fR is a STREAMS module that may be used with a pseudo terminal to
 packetize certain messages. The \fBpckt\fR module should be pushed (see
-\fBI_PUSH\fR on  \fBstreamio\fR(7I)) onto the master side of a pseudo terminal.
+\fBI_PUSH\fR on \fBstreamio\fR(7I)) onto the manager side of a pseudo terminal.
 .sp
 .LP
 Packetizing is performed by prefixing a message with an  \fBM_PROTO\fR message.
@@ -31,21 +28,19 @@ On the read-side, only the \fBM_PROTO\fR, \fBM_PCPROTO\fR, \fBM_STOP\fR,
 types are passed upstream unmodified.
 .sp
 .LP
-Since all unread state information is held in the master's stream head read
+Since all unread state information is held in the manager's stream head read
 queue, flushing of this queue is disabled.
 .sp
 .LP
 On the write-side, all messages are sent down unmodified.
 .sp
 .LP
-With this module in place, all reads from the master side of the pseudo
+With this module in place, all reads from the manager side of the pseudo
 terminal should be performed with the  \fBgetmsg\fR(2) or \fBgetpmsg\fR()
 function. The control part of the message contains the message type. The data
 part contains the actual data associated with that message type. The onus is on
 the application to separate the data into its component parts.
 .SH SEE ALSO
-.sp
-.LP
 \fBgetmsg\fR(2), \fBioctl\fR(2), \fBldterm\fR(7M), \fBptem\fR(7M),
 \fBstreamio\fR(7I), \fBtermio\fR(7I)
 .sp
diff --git a/usr/src/man/man7m/ptem.7m b/usr/src/man/man7m/ptem.7m
index aefea791d6..0a5354b222 100644
--- a/usr/src/man/man7m/ptem.7m
+++ b/usr/src/man/man7m/ptem.7m
@@ -4,65 +4,127 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PTEM 7M "Jul 3, 1990"
-.SH NAME
-ptem \- STREAMS Pseudo Terminal Emulation module
-.SH SYNOPSIS
-.LP
-.nf
-\fBint ioctl(\fR\fIfd\fR, \fBI_PUSH\fR,\fB "ptem");\fR
-.fi
-
-.SH DESCRIPTION
-.sp
-.LP
-\fBptem\fR is a STREAMS module that, when used in conjunction with a line
-discipline and pseudo terminal driver, emulates a terminal.
-.sp
-.LP
-The \fBptem\fR module must be pushed (see  \fBI_PUSH\fR, \fBstreamio\fR(7I))
-onto the slave side of a pseudo terminal STREAM, before the \fBldterm\fR(7M)
+.\" Copyright 2022 Oxide Computer Company
+.Dd February 5, 2022
+.Dt PTEM 7M
+.Os
+.Sh NAME
+.Nm ptem
+.Nd STREAMS Pseudo-Terminal Emulation module
+.Sh SYNOPSIS
+.In unistd.h
+.In stropts.h
+.Ft int
+.Fo ioctl
+.Fa "int fildes" ,
+.Dv I_PUSH ,
+.Qq ptem
+.Fc
+.Sh DESCRIPTION
+.Nm ptem
+is a STREAMS module that emulates a terminal device when used in conjunction
+with the line discipline,
+.Xr ldterm 7M ,
+and the pseudo terminal driver,
+.Xr ptm 7D .
+.Pp
+The
+.Nm ptem
+module must be pushed
+.Po
+see
+.Dv I_PUSH
+in
+.Xr streamio 7I
+.Pc
+onto the subsidiary device of a pseudo-terminal STREAM, before the
+.Xr ldterm 7M
 module is pushed.
-.sp
-.LP
-On the write-side, the \fBTCSETA\fR, \fBTCSETAF\fR, \fBTCSETAW\fR,
-\fBTCGETA\fR, \fBTCSETS\fR, \fBTCSETSW\fR, \fBTCSETSF\fR, \fBTCGETS\fR,
-\fBTCSBRK\fR, \fBJWINSIZE\fR, \fBTIOCGWINSZ\fR, and \fBTIOCSWINSZ\fR
-\fBtermio\fR \fBioctl\fR(2) messages are processed and acknowledged. If remote
-mode is not in effect, \fBptem\fR handles the \fBTIOCSTI\fR ioctl by copying
-the argument bytes into an  \fBM_DATA\fR message and passing it back up the
-read side. Regardless of the remote mode setting, \fBptem\fR acknowledges the
-ioctl and passes a copy of it downstream for possible further processing. A
-hang up (that is, \fBstty 0\fR) is converted to a zero length \fBM_DATA\fR
-message and passed downstream. Termio \fBcflags\fR and window row and column
-information are stored locally one per stream. \fBM_DELAY\fR messages are
-discarded. All other messages are passed downstream unmodified.
-.sp
-.LP
-On the read-side all messages are passed upstream unmodified with the following
-exceptions. All \fBM_READ\fR and \fBM_DELAY\fR messages are freed in both
-directions. A \fBTCSBRK\fR ioctl is converted to an \fBM_BREAK\fR message and
-passed upstream and an acknowledgement is returned downstream. A
-\fBTIOCSIGNAL\fR ioctl is converted into an \fBM_PCSIG\fR message,  and passed
-upstream and an acknowledgement is returned downstream. Finally a
-\fBTIOCREMOTE\fR ioctl is converted into an \fBM_CTL\fR message, acknowledged,
-and passed upstream; the resulting mode is retained for use in subsequent
-\fBTIOCSTI\fR parsing.
-.SH FILES
-.sp
-.ne 2
-.na
-\fB<\fBsys/ptem.h\fR> \fR
-.ad
-.RS 17n
-
-.RE
-
-.SH SEE ALSO
-.sp
-.LP
-\fBstty\fR(1), \fBioctl\fR(2), \fBldterm\fR(7M), \fBpckt\fR(7M),
-\fBstreamio\fR(7I), \fBtermio\fR(7I)
-.sp
-.LP
-\fISTREAMS Programming Guide\fR
+.Ss Write-side Behaviour
+The
+.Dv TCSETA ,
+.Dv TCSETAF ,
+.Dv TCSETAW ,
+.Dv TCGETA ,
+.Dv TCSETS ,
+.Dv TCSETSW ,
+.Dv TCSETSF ,
+.Dv TCGETS ,
+.Dv TCSBRK ,
+.Dv JWINSIZE ,
+.Dv TIOCGWINSZ ,
+and
+.Dv TIOCSWINSZ
+.Xr termio 7I
+.Xr ioctl 2
+messages are processed and acknowledged.
+.Pp
+If
+.Em remote mode
+is not in effect,
+.Nm ptem
+handles the
+.Dv TIOCSTI
+ioctl by copying the argument bytes into an
+.Dv M_DATA
+message and passing it back up the read side.
+Regardless of the
+.Em remote mode
+setting,
+.Nm ptem
+acknowledges the ioctl and passes a copy of it downstream for possible further
+processing.
+.Pp
+A hang up
+.Po
+e.g.,
+.Ic stty 0
+.Pc
+is converted to a zero length
+.Dv M_DATA
+message and passed downstream.
+.Xr termio 7I
+.Sy cflags
+and window row and column information are stored locally, one per stream.
+.Dv M_DELAY
+messages are discarded.
+.Pp
+All other messages are passed downstream unmodified.
+.Ss Read-side Behaviour
+All messages are passed upstream unmodified with the following exceptions:
+.Bl -bullet
+.It
+All
+.Dv M_READ
+and
+.Dv M_DELAY
+messages are freed in both directions.
+.It
+A
+.Dv TCSBRK
+ioctl is converted to an
+.Dv M_BREAK
+message and passed upstream and an acknowledgement is returned downstream.
+.It
+A
+.Dv TIOCSIGNAL
+ioctl is converted into an
+.Dv M_PCSIG
+message, passed upstream, and an acknowledgement is returned downstream.
+.It
+A
+.Dv TIOCREMOTE
+ioctl is converted into an
+.Dv M_CTL
+message, acknowledged, and passed upstream; the resulting mode is retained for
+use in subsequent
+.Dv TIOCSTI
+parsing.
+.El
+.Sh SEE ALSO
+.Xr stty 1 ,
+.Xr ioctl 2 ,
+.Xr streamio 7I ,
+.Xr termio 7I ,
+.Xr ldterm 7M ,
+.Xr pckt 7M
diff --git a/usr/src/pkg/manifests/SUNWcs.man7d.inc b/usr/src/pkg/manifests/SUNWcs.man7d.inc
index 66aec80ed4..901eb05c4e 100644
--- a/usr/src/pkg/manifests/SUNWcs.man7d.inc
+++ b/usr/src/pkg/manifests/SUNWcs.man7d.inc
@@ -14,4 +14,4 @@
 file path=usr/share/man/man7d/kstat.7d
 file path=usr/share/man/man7d/ksyms.7d
 file path=usr/share/man/man7d/ptm.7d
-file path=usr/share/man/man7d/pts.7d
+link path=usr/share/man/man7d/pts.7d target=ptm.7d
diff --git a/usr/src/uts/common/fs/dev/sdev_ptsops.c b/usr/src/uts/common/fs/dev/sdev_ptsops.c
index 4d8f47397b..1b3f1561de 100644
--- a/usr/src/uts/common/fs/dev/sdev_ptsops.c
+++ b/usr/src/uts/common/fs/dev/sdev_ptsops.c
@@ -97,7 +97,6 @@ devpts_strtol(const char *nm, minor_t *mp)
  *	  away, we use the validator to do deferred cleanup i.e. when such
  *	  nodes are encountered during subsequent lookup() and readdir().
  */
-/*ARGSUSED*/
 int
 devpts_validate(struct sdev_node *dv)
 {
@@ -124,8 +123,8 @@ devpts_validate(struct sdev_node *dv)
 	/*
 	 * Check if pts driver is attached
 	 */
-	if (ptms_slave_attached() == (major_t)-1) {
-		sdcmn_err7(("devpts_validate: slave not attached\n"));
+	if (ptms_subsidiary_attached() == (major_t)-1) {
+		sdcmn_err7(("devpts_validate: subsidiary not attached\n"));
 		return (SDEV_VTOR_INVALID);
 	}
 
@@ -159,7 +158,6 @@ devpts_validate(struct sdev_node *dv)
  * This callback is invoked from devname_lookup_func() to create
  * a pts entry when the node is not found in the cache.
  */
-/*ARGSUSED*/
 static int
 devpts_create_rvp(struct sdev_node *ddv, char *nm,
     void **arg, cred_t *cred, void *whatever, char *whichever)
@@ -177,12 +175,11 @@ devpts_create_rvp(struct sdev_node *ddv, char *nm,
 	}
 
 	/*
-	 * Check if pts driver is attached and if it is
-	 * get the major number.
+	 * Check if pts driver is attached and if it is get the major number.
 	 */
-	maj = ptms_slave_attached();
+	maj = ptms_subsidiary_attached();
 	if (maj == (major_t)-1) {
-		sdcmn_err7(("devpts_create_rvp: slave not attached\n"));
+		sdcmn_err7(("devpts_create_rvp: subsidiary not attached\n"));
 		return (-1);
 	}
 
@@ -286,7 +283,6 @@ devpts_prunedir(struct sdev_node *ddv)
  * access the realvp of the specfs node directly instead of using
  * VOP_REALVP().
  */
-/*ARGSUSED3*/
 static int
 devpts_lookup(struct vnode *dvp, char *nm, struct vnode **vpp,
     struct pathname *pnp, int flags, struct vnode *rdir, struct cred *cred,
@@ -326,7 +322,6 @@ devpts_lookup(struct vnode *dvp, char *nm, struct vnode **vpp,
  *	- creating an existing dir read-only succeeds, otherwise EISDIR
  *	- exclusive creates fail - EEXIST
  */
-/*ARGSUSED2*/
 static int
 devpts_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,
     int mode, struct vnode **vpp, struct cred *cred, int flag,
@@ -359,11 +354,10 @@ devpts_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,
 }
 
 /*
- * Display all instantiated pts (slave) device nodes.
- * A /dev/pts entry will be created only after the first lookup of the slave
- * device succeeds.
+ * Display all instantiated pts (subsidiary) device nodes.
+ * A /dev/pts entry will be created only after the first lookup of the
+ * subsidiary device succeeds.
  */
-/*ARGSUSED4*/
 static int
 devpts_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,
     int *eofp, caller_context_t *ct, int flags)
@@ -387,7 +381,6 @@ devpts_set_id(struct sdev_node *dv, struct vattr *vap, int protocol)
 
 }
 
-/*ARGSUSED4*/
 static int
 devpts_setattr(struct vnode *vp, struct vattr *vap, int flags,
     struct cred *cred, caller_context_t *ctp)
diff --git a/usr/src/uts/common/io/ptem.c b/usr/src/uts/common/io/ptem.c
index 6497465b61..3be1f9d777 100644
--- a/usr/src/uts/common/io/ptem.c
+++ b/usr/src/uts/common/io/ptem.c
@@ -401,7 +401,7 @@ ptemrput(queue_t *q, mblk_t *mp)
 	case M_IOCACK:
 	case M_IOCNAK:
 		/*
-		 * We only pass write-side ioctls through to the master that
+		 * We only pass write-side ioctls through to the manager that
 		 * we've already ACKed or NAKed to the stream head.  Thus, we
 		 * discard ones arriving from below, since they're redundant
 		 * from the point of view of modules above us.
@@ -626,7 +626,7 @@ ptemwmsg(queue_t *q, mblk_t *mp)
 		 * of the M_IOCTL message is made and passed
 		 * downstream.  Eventually the PCKT module, if
 		 * it has been pushed, should pick up this message.
-		 * If the PCKT module has not been pushed the master
+		 * If the PCKT module has not been pushed the manager
 		 * side stream head will free it.
 		 */
 		iocp = (struct iocblk *)mp->b_rptr;
@@ -843,8 +843,9 @@ out:
 
 		default:
 			/*
-			 * End of the line.  The slave driver doesn't see any
-			 * ioctls that we don't explicitly pass along to it.
+			 * End of the line.  The subsidiary driver doesn't see
+			 * any ioctls that we don't explicitly pass along to
+			 * it.
 			 */
 			miocnak(q, mp, 0, EINVAL);
 			break;
@@ -983,14 +984,14 @@ ptioc(queue_t *q, mblk_t *mp, int qside)
 				(void) putnextctl1(q, M_SIG, SIGWINCH);
 			/*
 			 * Message may have come in as an M_IOCDATA; pass it
-			 * to the master side as an M_IOCTL.
+			 * to the manager side as an M_IOCTL.
 			 */
 			mp->b_datap->db_type = M_IOCTL;
 			if (qside == WRSIDE) {
 				/*
 				 * Need a copy of this message to pass on to
 				 * the PCKT module, only if the M_IOCTL
-				 * orginated from the slave side.
+				 * orginated from the subsidiary side.
 				 */
 				if ((pckt_msgp = copymsg(mp)) == NULL) {
 					miocnak(q, mp, 0, EAGAIN);
@@ -1010,7 +1011,7 @@ ptioc(queue_t *q, mblk_t *mp, int qside)
 
 	case TIOCSIGNAL: {
 		/*
-		 * This ioctl can emanate from the master side in remote
+		 * This ioctl can emanate from the manager side in remote
 		 * mode only.
 		 */
 		int	sig;
@@ -1034,8 +1035,8 @@ ptioc(queue_t *q, mblk_t *mp, int qside)
 		}
 
 		/*
-		 * Send an M_PCSIG message up the slave's read side and
-		 * respond back to the master with an ACK or NAK as
+		 * Send an M_PCSIG message up the subsidiary's read side and
+		 * respond back to the manager with an ACK or NAK as
 		 * appropriate.
 		 */
 		if (putnextctl1(q, M_PCSIG, sig) == 0) {
diff --git a/usr/src/uts/common/io/ptm.c b/usr/src/uts/common/io/ptm.c
index 472cbf6936..8127d54594 100644
--- a/usr/src/uts/common/io/ptm.c
+++ b/usr/src/uts/common/io/ptm.c
@@ -26,97 +26,107 @@
 
 /*
  * Copyright 2020 OmniOS Community Edition (OmniOSce) Association.
+ * Copyright 2021 Oxide Computer Company
  */
 
 /*
- * Pseudo Terminal Master Driver.
+ * PSEUDO-TERMINAL MANAGER DRIVER (PTM)
  *
- * The pseudo-tty subsystem simulates a terminal connection, where the master
- * side represents the terminal and the slave represents the user process's
- * special device end point. The master device is set up as a cloned device
- * where its major device number is the major for the clone device and its minor
- * device number is the major for the ptm driver. There are no nodes in the file
- * system for master devices. The master pseudo driver is opened using the
- * open(2) system call with /dev/ptmx as the device parameter.  The clone open
- * finds the next available minor device for the ptm major device.
+ * The pseudo-terminal subsystem simulates a terminal connection, where the
+ * manager side represents the terminal and the subsidiary represents the user
+ * process's special device end point.  The manager device is set up as a
+ * cloned device where its major device number is the major for the clone
+ * device and its minor device number is the major for the ptm driver.  There
+ * are no nodes in the file system for manager devices.  The manager pseudo
+ * driver is opened using the open(2) system call with /dev/ptmx as the device
+ * parameter.  The clone open finds the next available minor device for the ptm
+ * major device.
  *
- * A master device is available only if it and its corresponding slave device
- * are not already open. When the master device is opened, the corresponding
- * slave device is automatically locked out. Only one open is allowed on a
- * master device.  Multiple opens are allowed on the slave device.  After both
- * the master and slave have been opened, the user has two file descriptors
- * which are the end points of a full duplex connection composed of two streams
- * which are automatically connected at the master and slave drivers. The user
- * may then push modules onto either side of the stream pair.
+ * A manager device is available only if it and its corresponding subsidiary
+ * device are not already open.  When the manager device is opened, the
+ * corresponding subsidiary device is automatically locked out.  Only one open
+ * is allowed on a manager device.  Multiple opens are allowed on the
+ * subsidiary device.  After both the manager and subsidiary have been opened,
+ * the user has two file descriptors which are the end points of a full duplex
+ * connection composed of two streams which are automatically connected at the
+ * manager and subsidiary drivers.  The user may then push modules onto either
+ * side of the stream pair.
  *
- * The master and slave drivers pass all messages to their adjacent queues.
- * Only the M_FLUSH needs some processing.  Because the read queue of one side
- * is connected to the write queue of the other, the FLUSHR flag is changed to
- * the FLUSHW flag and vice versa. When the master device is closed an M_HANGUP
- * message is sent to the slave device which will render the device
- * unusable. The process on the slave side gets the EIO when attempting to write
- * on that stream but it will be able to read any data remaining on the stream
- * head read queue.  When all the data has been read, read() returns 0
- * indicating that the stream can no longer be used.  On the last close of the
- * slave device, a 0-length message is sent to the master device. When the
- * application on the master side issues a read() or getmsg() and 0 is returned,
- * the user of the master device decides whether to issue a close() that
- * dismantles the pseudo-terminal subsystem. If the master device is not closed,
- * the pseudo-tty subsystem will be available to another user to open the slave
- * device.
+ * The manager and subsidiary drivers pass all messages to their adjacent
+ * queues.  Only the M_FLUSH needs some processing.  Because the read queue of
+ * one side is connected to the write queue of the other, the FLUSHR flag is
+ * changed to the FLUSHW flag and vice versa.  When the manager device is
+ * closed an M_HANGUP message is sent to the subsidiary device which will
+ * render the device unusable.  The process on the subsidiary side gets an EIO
+ * error when attempting to write on that stream but it will be able to read
+ * any data remaining on the stream head read queue.  When all the data has
+ * been read, read() returns 0 indicating that the stream can no longer be
+ * used.  On the last close of the subsidiary device, a 0-length message is
+ * sent to the manager device.  When the application on the manager side issues
+ * a read() or getmsg() and 0 is returned, the user of the manager device
+ * decides whether to issue a close() that dismantles the pseudo-terminal
+ * subsystem.  If the manager device is not closed, the pseudo-terminal
+ * subsystem will be available to another user to open the subsidiary device.
  *
- * If O_NONBLOCK or O_NDELAY is set, read on the master side returns -1 with
+ * If O_NONBLOCK or O_NDELAY is set, read on the manager side returns -1 with
  * errno set to EAGAIN if no data is available, and write returns -1 with errno
  * set to EAGAIN if there is internal flow control.
  *
- * IOCTLS:
  *
- *  ISPTM: determines whether the file descriptor is that of an open master
- *	   device. Return code of zero indicates that the file descriptor
- *	   represents master device.
+ * IOCTLS
  *
- *  UNLKPT: unlocks the master and slave devices.  It returns 0 on success. On
- *	    failure, the errno is set to EINVAL indicating that the master
- *	    device is not open.
+ *	ISPTM
+ *		Determines whether the file descriptor is that of an open
+ *		manager device.  Return code of zero indicates that the file
+ *		descriptor represents a manager device.
  *
- *  ZONEPT: sets the zone membership of the associated pts device.
+ *	UNLKPT
+ *		Unlocks the manager and subsidiary devices.  It returns 0 on
+ *		success. On failure, the errno is set to EINVAL indicating that
+ *		the manager device is not open.
  *
- *  GRPPT:  sets the group owner of the associated pts device.
+ *	ZONEPT
+ *		Sets the zone membership of the associated subsidiary device.
  *
- * Synchronization:
+ *	GRPPT
+ *		Sets the group owner of the associated subsidiary device.
  *
- *   All global data synchronization between ptm/pts is done via global
- *   ptms_lock mutex which is initialized at system boot time from
- *   ptms_initspace (called from space.c).
  *
- *   Individual fields of pt_ttys structure (except ptm_rdq, pts_rdq and
- *   pt_nullmsg) are protected by pt_ttys.pt_lock mutex.
+ * SYNCHRONIZATION
  *
- *   PT_ENTER_READ/PT_ENTER_WRITE are reference counter based read-write locks
- *   which allow reader locks to be reacquired by the same thread (usual
- *   reader/writer locks can't be used for that purpose since it is illegal for
- *   a thread to acquire a lock it already holds, even as a reader). The sole
- *   purpose of these macros is to guarantee that the peer queue will not
- *   disappear (due to closing peer) while it is used. It is safe to use
- *   PT_ENTER_READ/PT_EXIT_READ brackets across calls like putq/putnext (since
- *   they are not real locks but reference counts).
+ * All global data synchronization between ptm/pts is done via global ptms_lock
+ * mutex which is initialized at system boot time from ptms_initspace (called
+ * from space.c).
  *
- *   PT_ENTER_WRITE/PT_EXIT_WRITE brackets are used ONLY in master/slave
- *   open/close paths to modify ptm_rdq and pts_rdq fields. These fields should
- *   be set to appropriate queues *after* qprocson() is called during open (to
- *   prevent peer from accessing the queue with incomplete plumbing) and set to
- *   NULL before qprocsoff() is called during close.
+ * Individual fields of pt_ttys structure (except ptm_rdq, pts_rdq and
+ * pt_nullmsg) are protected by pt_ttys.pt_lock mutex.
  *
- *   The pt_nullmsg field is only used in open/close routines and it is also
- *   protected by PT_ENTER_WRITE/PT_EXIT_WRITE brackets to avoid extra mutex
- *   holds.
+ * PT_ENTER_READ/PT_ENTER_WRITE are reference counter based read-write locks
+ * which allow reader locks to be reacquired by the same thread (usual
+ * reader/writer locks can't be used for that purpose since it is illegal for a
+ * thread to acquire a lock it already holds, even as a reader). The sole
+ * purpose of these macros is to guarantee that the peer queue will not
+ * disappear (due to closing peer) while it is used. It is safe to use
+ * PT_ENTER_READ/PT_EXIT_READ brackets across calls like putq/putnext (since
+ * they are not real locks but reference counts).
  *
- * Lock Ordering:
+ * PT_ENTER_WRITE/PT_EXIT_WRITE brackets are used ONLY in manager/subsidiary
+ * open/close paths to modify ptm_rdq and pts_rdq fields. These fields should
+ * be set to appropriate queues *after* qprocson() is called during open (to
+ * prevent peer from accessing the queue with incomplete plumbing) and set to
+ * NULL before qprocsoff() is called during close.
  *
- *   If both ptms_lock and per-pty lock should be held, ptms_lock should always
- *   be entered first, followed by per-pty lock.
+ * The pt_nullmsg field is only used in open/close routines and it is also
+ * protected by PT_ENTER_WRITE/PT_EXIT_WRITE brackets to avoid extra mutex
+ * holds.
  *
- * See ptms.h, pts.c and ptms_conf.c for more information.
+ *
+ * LOCK ORDERING
+ *
+ * If both ptms_lock and per-pty lock should be held, ptms_lock should always
+ * be entered first, followed by per-pty lock.
+ *
+ * See ptms.h, pts.c, and ptms_conf.c for more information.
  */
 
 #include <sys/types.h>
@@ -152,10 +162,6 @@ static int ptmwput(queue_t *, mblk_t *);
 static int ptmrsrv(queue_t *);
 static int ptmwsrv(queue_t *);
 
-/*
- * Master Stream Pseudo Terminal Module: stream data structure definitions
- */
-
 static struct module_info ptm_info = {
 	0xdead,
 	"ptm",
@@ -209,9 +215,9 @@ DDI_DEFINE_STREAM_OPS(ptm_ops, nulldev, nulldev, ptm_attach, ptm_detach,
  */
 
 static struct modldrv modldrv = {
-	&mod_driverops, /* Type of module.  This one is a pseudo driver */
-	"Master streams driver 'ptm'",
-	&ptm_ops,	/* driver ops */
+	&mod_driverops,
+	"Pseudo-Terminal Manager Driver",
+	&ptm_ops,
 };
 
 static struct modlinkage modlinkage = {
@@ -273,7 +279,6 @@ ptm_detach(dev_info_t *devi, ddi_detach_cmd_t cmd)
 	return (DDI_SUCCESS);
 }
 
-/*ARGSUSED*/
 static int
 ptm_devinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg,
     void **result)
@@ -300,12 +305,11 @@ ptm_devinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg,
 }
 
 
-/* ARGSUSED */
 /*
- * Open a minor of the master device. Store the write queue pointer and set the
- * pt_state field to (PTMOPEN | PTLOCK).
+ * Open a minor of the manager device. Store the write queue pointer and set
+ * the pt_state field to (PTMOPEN | PTLOCK).
  * This code will work properly with both clone opens and direct opens of the
- * master device.
+ * manager device.
  */
 static int
 ptmopen(
@@ -329,19 +333,18 @@ ptmopen(
 
 	if (!(sflag & CLONEOPEN) && dminor != 0) {
 		/*
-		 * This is a direct open to specific master device through an
+		 * This is a direct open to specific manager device through an
 		 * artificially created entry with specific minor in
-		 * /dev/directory. Such behavior is not supported.
+		 * /dev/directory.  Such behavior is not supported.
 		 */
 		return (ENXIO);
 	}
 
 	/*
-	 * The master open requires that the slave be attached
-	 * before it returns so that attempts to open the slave will
-	 * succeeed
+	 * The manager open requires that the subsidiary be attached before it
+	 * returns so that attempts to open the subsidiary will succeeed
 	 */
-	if (ptms_attach_slave() != 0) {
+	if (ptms_attach_subsidiary() != 0) {
 		return (ENXIO);
 	}
 
@@ -366,7 +369,7 @@ ptmopen(
 
 	qprocson(rqp);
 
-	/* Allow slave to send messages to master */
+	/* Allow subsidiary to send messages to manager */
 	PT_ENTER_WRITE(ptmp);
 	ptmp->ptm_rdq = rqp;
 	PT_EXIT_WRITE(ptmp);
@@ -397,13 +400,12 @@ ptmopen(
 
 
 /*
- * Find the address to private data identifying the slave's write queue.
- * Send a hang-up message up the slave's read queue to designate the
- * master/slave pair is tearing down. Uattach the master and slave by
- * nulling out the write queue fields in the private data structure.
- * Finally, unlock the master/slave pair and mark the master as closed.
+ * Find the address to private data identifying the subsidiary's write queue.
+ * Send a hang-up message up the subsidiary's read queue to designate the
+ * manager/subsidiary pair is tearing down. Uattach the manager and subsidiary
+ * by nulling out the write queue fields in the private data structure.
+ * Finally, unlock the manager/subsidiary pair and mark the manager as closed.
  */
-/*ARGSUSED1*/
 static int
 ptmclose(queue_t *rqp, int flag, cred_t *credp)
 {
@@ -417,7 +419,7 @@ ptmclose(queue_t *rqp, int flag, cred_t *credp)
 	if (ptmp->pts_rdq) {
 		pts_rdq = ptmp->pts_rdq;
 		if (pts_rdq->q_next) {
-			DBG(("send hangup message to slave\n"));
+			DBG(("send hangup message to subsidiary\n"));
 			(void) putnextctl(pts_rdq, M_HANGUP);
 		}
 	}
@@ -431,8 +433,8 @@ ptmclose(queue_t *rqp, int flag, cred_t *credp)
 	freemsg(ptmp->pt_nullmsg);
 	ptmp->pt_nullmsg = NULL;
 	/*
-	 * qenable slave side write queue so that it can flush
-	 * its messages as master's read queue is going away
+	 * qenable subsidiary side write queue so that it can flush
+	 * its messages as manager's read queue is going away
 	 */
 	if (ptmp->pts_rdq)
 		qenable(WR(ptmp->pts_rdq));
@@ -466,9 +468,9 @@ ptmwput(queue_t *qp, mblk_t *mp)
 
 	switch (mp->b_datap->db_type) {
 	/*
-	 * if write queue request, flush master's write
-	 * queue and send FLUSHR up slave side. If read
-	 * queue request, convert to FLUSHW and putnext().
+	 * If this is a write queue request, flush manager's write queue and
+	 * send FLUSHR up subsidiary side.  If it is a read queue request,
+	 * convert to FLUSHW and putnext().
 	 */
 	case M_FLUSH:
 		{
@@ -477,14 +479,15 @@ ptmwput(queue_t *qp, mblk_t *mp)
 			DBG(("ptm got flush request\n"));
 			if (*mp->b_rptr & FLUSHW) {
 				DBG(("got FLUSHW, flush ptm write Q\n"));
-				if (*mp->b_rptr & FLUSHBAND)
+				if (*mp->b_rptr & FLUSHBAND) {
 					/*
 					 * if it is a FLUSHBAND, do flushband.
 					 */
 					flushband(qp, *(mp->b_rptr + 1),
 					    FLUSHDATA);
-				else
+				} else {
 					flushq(qp, FLUSHDATA);
+				}
 				flush_flg = (*mp->b_rptr & ~FLUSHW) | FLUSHR;
 			}
 			if (*mp->b_rptr & FLUSHR) {
@@ -496,8 +499,9 @@ ptmwput(queue_t *qp, mblk_t *mp)
 				DBG(("putnext to pts\n"));
 				*mp->b_rptr = flush_flg;
 				putnext(ptmp->pts_rdq, mp);
-			} else
+			} else {
 				freemsg(mp);
+			}
 			break;
 		}
 
@@ -507,7 +511,7 @@ ptmwput(queue_t *qp, mblk_t *mp)
 		default:
 			if ((ptmp->pt_state & PTLOCK) ||
 			    (ptmp->pts_rdq == NULL)) {
-				DBG(("got M_IOCTL but no slave\n"));
+				DBG(("got M_IOCTL but no subsidiary\n"));
 				miocnak(qp, mp, 0, EINVAL);
 				PT_EXIT_READ(ptmp);
 				return (0);
@@ -587,16 +591,16 @@ ptmwput(queue_t *qp, mblk_t *mp)
 		break;
 
 	case M_READ:
-		/* Caused by ldterm - can not pass to slave */
+		/* Caused by ldterm - can not pass to subsidiary */
 		freemsg(mp);
 		break;
 
 	/*
-	 * send other messages to slave
+	 * Send other messages to the subsidiary:
 	 */
 	default:
-		if ((ptmp->pt_state  & PTLOCK) || (ptmp->pts_rdq == NULL)) {
-			DBG(("got msg. but no slave\n"));
+		if ((ptmp->pt_state & PTLOCK) || (ptmp->pts_rdq == NULL)) {
+			DBG(("got msg. but no subsidiary\n"));
 			mp = mexchange(NULL, mp, 2, M_ERROR, -1);
 			if (mp != NULL) {
 				mp->b_rptr[0] = NOERROR;
@@ -606,7 +610,7 @@ ptmwput(queue_t *qp, mblk_t *mp)
 			PT_EXIT_READ(ptmp);
 			return (0);
 		}
-		DBG(("put msg on master's write queue\n"));
+		DBG(("put msg on manager's write queue\n"));
 		(void) putq(qp, mp);
 		break;
 	}
@@ -617,9 +621,8 @@ ptmwput(queue_t *qp, mblk_t *mp)
 
 
 /*
- * enable the write side of the slave. This triggers the
- * slave to send any messages queued on its write side to
- * the read side of this master.
+ * Enable the write side of the subsidiary.  This triggers the subsidiary to
+ * send any messages queued on its write side to the read side of this manager.
  */
 static int
 ptmrsrv(queue_t *qp)
@@ -641,10 +644,10 @@ ptmrsrv(queue_t *qp)
 
 
 /*
- * If there are messages on this queue that can be sent to
- * slave, send them via putnext(). Else, if queued messages
- * cannot be sent, leave them on this queue. If priority
- * messages on this queue, send them to slave no matter what.
+ * If there are messages on this queue that can be sent to subsidiary, send
+ * them via putnext().  Otherwise, if queued messages cannot be sent, leave
+ * them on this queue.  If priority messages on this queue, send them to the
+ * subsidiary no matter what.
  */
 static int
 ptmwsrv(queue_t *qp)
@@ -665,7 +668,7 @@ ptmwsrv(queue_t *qp)
 
 	PT_ENTER_READ(ptmp);
 	if ((ptmp->pt_state  & PTLOCK) || (ptmp->pts_rdq == NULL)) {
-		DBG(("in master write srv proc but no slave\n"));
+		DBG(("in manager write srv proc but no subsidiary\n"));
 		/*
 		 * Free messages on the write queue and send
 		 * NAK for any M_IOCTL type messages to wakeup
@@ -690,13 +693,12 @@ ptmwsrv(queue_t *qp)
 		return (0);
 	}
 	/*
-	 * while there are messages on this write queue...
+	 * While there are messages on this write queue...
 	 */
 	do {
 		/*
-		 * if don't have control message and cannot put
-		 * msg. on slave's read queue, put it back on
-		 * this queue.
+		 * If this is not a control message, and we cannot put messages
+		 * on the subsidiary's read queue, put it back on this queue.
 		 */
 		if (mp->b_datap->db_type <= QPCTL &&
 		    !bcanputnext(ptmp->pts_rdq, mp->b_band)) {
@@ -705,9 +707,9 @@ ptmwsrv(queue_t *qp)
 			break;
 		}
 		/*
-		 * else send the message up slave's stream
+		 * Otherwise send the message up subsidiary's stream
 		 */
-		DBG(("send message to slave\n"));
+		DBG(("send message to subsidiary\n"));
 		putnext(ptmp->pts_rdq, mp);
 	} while ((mp = getq(qp)) != NULL);
 	DBG(("leaving ptmwsrv\n"));
diff --git a/usr/src/uts/common/io/ptms_conf.c b/usr/src/uts/common/io/ptms_conf.c
index d5d4383d5c..b032b093ed 100644
--- a/usr/src/uts/common/io/ptms_conf.c
+++ b/usr/src/uts/common/io/ptms_conf.c
@@ -21,79 +21,86 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2021 Oxide Computer Company
  */
 
 /*
- * This file contains global data and code shared between master and slave parts
- * of the pseudo-terminal driver.
+ * PSEUDO-TERMINAL COMMON DATA AND ROUTINES (PTM, PTS)
  *
- * Pseudo terminals (or pt's for short) are allocated dynamically.
- * pt's are put in the global ptms_slots array indexed by minor numbers.
+ * This file contains global data and code shared between manager and
+ * subsidiary parts of the pseudo-terminal driver.
  *
- * The slots array is initially small (of the size NPTY_MIN). When more pt's are
+ * Pseudo-terminals (or ptys for short) are allocated dynamically.
+ * ptys are put in the global ptms_slots array indexed by minor numbers.
+ *
+ * The slots array is initially small (of the size NPTY_MIN). When more ptys are
  * needed than the slot array size, the larger slot array is allocated and all
- * opened pt's move to the new one.
+ * opened ptys move to the new one.
+ *
+ *
+ * RESOURCE ALLOCATION
+ *
+ * - pt_ttys structures are allocated via pt_ttys_alloc, which uses
+ *   kmem_cache_alloc().
+ * - Minor number space is allocated via vmem_alloc() interface.
+ * - ptms_slots arrays are allocated via kmem_alloc().
  *
- * Resource allocation:
+ * Minors start from 1 instead of 0, because vmem_alloc() returns 0 in case of
+ * failure.  Also, in anticipation of removing the clone device interface to
+ * pseudo-terminal subsystem, minor 0 should not be used. (Potential future
+ * development).
  *
- *	pt_ttys structures are allocated via pt_ttys_alloc, which uses
- *		kmem_cache_alloc().
- *	Minor number space is allocated via vmem_alloc() interface.
- *	ptms_slots arrays are allocated via kmem_alloc().
+ * After the table slot size reaches pt_maxdelta, we stop 2^N extension
+ * algorithm and start extending the slot table size by pt_maxdelta.
  *
- *   Minors are started from 1 instead of 0 because vmem_alloc returns 0 in case
- *   of failure. Also, in anticipation of removing clone device interface to
- *   pseudo-terminal subsystem, minor 0 should not be used. (Potential future
- *   development).
+ * Device entries /dev/pts directory are created dynamically by the /dev
+ * filesystem.  We no longer call ddi_create_minor_node() on behalf of the
+ * subsidiary driver.  The /dev filesystem creates /dev/pts nodes based on the
+ * pt_ttys array.
  *
- *   After the table slot size reaches pt_maxdelta, we stop 2^N extension
- *   algorithm and start extending the slot table size by pt_maxdelta.
  *
- *   Device entries /dev/pts directory are created dynamically by the
- *   /dev filesystem. We no longer call ddi_create_minor_node() on
- *   behalf of the slave driver. The /dev filesystem creates /dev/pts
- *   nodes based on the pt_ttys array.
+ * SYNCHRONIZATION
  *
- * Synchronization:
+ * All global data synchronization between ptm/pts is done via global ptms_lock
+ * mutex which is implicitly initialized by declaring it global.
  *
- *   All global data synchronization between ptm/pts is done via global
- *   ptms_lock mutex which is implicitly initialized by declaring it global.
+ * Individual fields of pt_ttys structure (except ptm_rdq, pts_rdq and
+ * pt_nullmsg) are protected by pt_ttys.pt_lock mutex.
  *
- *   Individual fields of pt_ttys structure (except ptm_rdq, pts_rdq and
- *   pt_nullmsg) are protected by pt_ttys.pt_lock mutex.
+ * PT_ENTER_READ/PT_ENTER_WRITE are reference counter based read-write locks
+ * which allow reader locks to be reacquired by the same thread (usual
+ * reader/writer locks can't be used for that purpose since it is illegal for a
+ * thread to acquire a lock it already holds, even as a reader). The sole
+ * purpose of these macros is to guarantee that the peer queue will not
+ * disappear (due to closing peer) while it is used. It is safe to use
+ * PT_ENTER_READ/PT_EXIT_READ brackets across calls like putq/putnext (since
+ * they are not real locks but reference counts).
  *
- *   PT_ENTER_READ/PT_ENTER_WRITE are reference counter based read-write locks
- *   which allow reader locks to be reacquired by the same thread (usual
- *   reader/writer locks can't be used for that purpose since it is illegal for
- *   a thread to acquire a lock it already holds, even as a reader). The sole
- *   purpose of these macros is to guarantee that the peer queue will not
- *   disappear (due to closing peer) while it is used. It is safe to use
- *   PT_ENTER_READ/PT_EXIT_READ brackets across calls like putq/putnext (since
- *   they are not real locks but reference counts).
+ * PT_ENTER_WRITE/PT_EXIT_WRITE brackets are used ONLY in manager/subsidiary
+ * open/close paths to modify ptm_rdq and pts_rdq fields. These fields should
+ * be set to appropriate queues *after* qprocson() is called during open (to
+ * prevent peer from accessing the queue with incomplete plumbing) and set to
+ * NULL before qprocsoff() is called during close. Put and service procedures
+ * use PT_ENTER_READ/PT_EXIT_READ to prevent peer closes.
  *
- *   PT_ENTER_WRITE/PT_EXIT_WRITE brackets are used ONLY in master/slave
- *   open/close paths to modify ptm_rdq and pts_rdq fields. These fields should
- *   be set to appropriate queues *after* qprocson() is called during open (to
- *   prevent peer from accessing the queue with incomplete plumbing) and set to
- *   NULL before qprocsoff() is called during close. Put and service procedures
- *   use PT_ENTER_READ/PT_EXIT_READ to prevent peer closes.
+ * The pt_nullmsg field is only used in open/close routines and is also
+ * protected by PT_ENTER_WRITE/PT_EXIT_WRITE brackets to avoid extra mutex
+ * holds.
  *
- *   The pt_nullmsg field is only used in open/close routines and is also
- *   protected by PT_ENTER_WRITE/PT_EXIT_WRITE brackets to avoid extra mutex
- *   holds.
  *
- * Lock Ordering:
+ * LOCK ORDERING
  *
- *   If both ptms_lock and per-pty lock should be held, ptms_lock should always
- *   be entered first, followed by per-pty lock.
+ * If both ptms_lock and per-pty lock should be held, ptms_lock should always
+ * be entered first, followed by per-pty lock.
  *
- * Global functions:
+ *
+ * GLOBAL FUNCTIONS
  *
  * void ptms_init(void);
  *
  *	Called by pts/ptm _init entry points. It performes one-time
- * 	initialization needed for both pts and ptm. This initialization is done
- * 	here and not in ptms_initspace because all these data structures are not
+ *	initialization needed for both pts and ptm. This initialization is done
+ *	here and not in ptms_initspace because all these data structures are not
  *	needed if pseudo-terminals are not used in the system.
  *
  * struct pt_ttys *pt_ttys_alloc(void);
@@ -117,6 +124,7 @@
  *	Also returns owner of pty.
  *
  * int ptms_minor_exists(minor_t minor)
+ *
  *	Check if minor refers to an allocated pty (in any zone)
  *	Returns
  *		0 if not an allocated pty
@@ -129,32 +137,33 @@
  * void ptms_close(struct pt_ttys *pt, uint_t flags_to_clear);
  *
  *	Clear flags_to_clear in pt and if no one owns it (PTMOPEN/PTSOPEN not
- * 	set) free pt entry and corresponding slot.
+ *	set) free pt entry and corresponding slot.
+ *
  *
- * Tuneables and configuration:
+ * TUNEABLES AND CONFIGURATION
  *
  *	pt_cnt: minimum number of pseudo-terminals in the system. The system
  *		should provide at least this number of ptys (provided sufficient
- * 		memory is available). It is different from the older semantics
+ *		memory is available). It is different from the older semantics
  *		of pt_cnt meaning maximum number of ptys.
  *		Set to 0 by default.
  *
  *	pt_max_pty: Maximum number of pseudo-terminals in the system. The system
  *		should not allocate more ptys than pt_max_pty (although, it may
- * 		impose stricter maximum). Zero value means no user-defined
- * 		maximum. This is intended to be used as "denial-of-service"
+ *		impose stricter maximum). Zero value means no user-defined
+ *		maximum. This is intended to be used as "denial-of-service"
  *		protection.
  *		Set to 0 by default.
  *
- *         Both pt_cnt and pt_max_pty may be modified during system lifetime
- *         with their semantics preserved.
+ *		Both pt_cnt and pt_max_pty may be modified during system
+ *		lifetime with their semantics preserved.
  *
  *	pt_init_cnt: Initial size of ptms_slots array. Set to NPTY_INITIAL.
  *
  *	pt_ptyofmem: Approximate percentage of system memory that may be
  *		occupied by pty data structures. Initially set to NPTY_PERCENT.
  *		This variable is used once during initialization to estimate
- * 		maximum number of ptys in the system. The actual maximum is
+ *		maximum number of ptys in the system. The actual maximum is
  *		determined as minimum of pt_max_pty and calculated value.
  *
  *	pt_maxdelta: Maximum extension chunk of the slot table.
@@ -193,7 +202,7 @@
  * Tuneable variables.
  */
 uint_t	pt_cnt = 0;			/* Minimum number of ptys */
-size_t 	pt_max_pty = 0;			/* Maximum number of ptys */
+size_t	pt_max_pty = 0;			/* Maximum number of ptys */
 uint_t	pt_init_cnt = NPTY_INITIAL;	/* Initial number of ptms slots */
 uint_t	pt_pctofmem = NPTY_PERCENT;	/* Percent of memory to use for ptys */
 uint_t	pt_maxdelta = PTY_MAXDELTA;	/* Max increment for slot table size */
@@ -210,7 +219,7 @@ static size_t ptms_nslots = 0;		/* Size of slot array */
 static size_t ptms_ptymax = 0;		/* Maximum number of ptys */
 static size_t ptms_inuse = 0;		/* # of ptys currently allocated */
 
-dev_info_t 	*pts_dip = NULL;	/* set if slave is attached */
+dev_info_t *pts_dip = NULL;		/* Set if subsidiary is attached */
 
 static struct kmem_cache *ptms_cache = NULL;	/* pty cache */
 
@@ -222,9 +231,9 @@ static void ptms_destructor(void *, void *);
 static minor_t ptms_grow(void);
 
 /*
- * Total size occupied by one pty. Each pty master/slave pair consumes one
- * pointer for ptms_slots array, one pt_ttys structure and one empty message
- * preallocated for pts close.
+ * Total size occupied by one pty. Each pty manager/subsidiary pair consumes
+ * one pointer for ptms_slots array, one pt_ttys structure, and one empty
+ * message preallocated for pts close.
  */
 
 #define	PTY_SIZE (sizeof (struct pt_ttys) + \
@@ -239,7 +248,7 @@ int ptms_debug = 0;
 /*
  * Clear all bits of x except the highest bit
  */
-#define	truncate(x) 	((x) <= 2 ? (x) : (1 << (highbit(x) - 1)))
+#define	truncate(x)	((x) <= 2 ? (x) : (1 << (highbit(x) - 1)))
 
 /*
  * Roundup the number to the nearest power of 2
@@ -295,7 +304,7 @@ ptms_init(void)
  * This routine attaches the pts dip.
  */
 int
-ptms_attach_slave(void)
+ptms_attach_subsidiary(void)
 {
 	if (pts_dip == NULL && i_ddi_attach_pseudo_node("pts") == NULL)
 		return (-1);
@@ -309,7 +318,7 @@ ptms_attach_slave(void)
  * and if it is, returns its major number.
  */
 major_t
-ptms_slave_attached(void)
+ptms_subsidiary_attached(void)
 {
 	major_t maj = DDI_MAJOR_T_NONE;
 
diff --git a/usr/src/uts/common/io/pts.c b/usr/src/uts/common/io/pts.c
index ff2d91f566..046a2bc76b 100644
--- a/usr/src/uts/common/io/pts.c
+++ b/usr/src/uts/common/io/pts.c
@@ -27,80 +27,84 @@
 
 /*
  * Copyright 2020 OmniOS Community Edition (OmniOSce) Association.
+ * Copyright 2021 Oxide Computer Company
  */
 
 /*
- * Pseudo Terminal Slave Driver.
+ * PSEUDO-TERMINAL SUBSIDIARY DRIVER (PTS)
  *
- * The pseudo-tty subsystem simulates a terminal connection, where the master
- * side represents the terminal and the slave represents the user process's
- * special device end point. The master device is set up as a cloned device
- * where its major device number is the major for the clone device and its minor
- * device number is the major for the ptm driver. There are no nodes in the file
- * system for master devices. The master pseudo driver is opened using the
- * open(2) system call with /dev/ptmx as the device parameter.  The clone open
- * finds the next available minor device for the ptm major device.
+ * The pseudo-terminal subsystem simulates a terminal connection, where the
+ * manager side represents the terminal and the subsidiary represents the user
+ * process's special device end point.  The manager device is set up as a
+ * cloned device where its major device number is the major for the clone
+ * device and its minor device number is the major for the ptm driver.  There
+ * are no nodes in the file system for manager devices.  The manager pseudo
+ * driver is opened using the open(2) system call with /dev/ptmx as the device
+ * parameter.  The clone open finds the next available minor device for the ptm
+ * major device.
  *
- * A master device is available only if it and its corresponding slave device
- * are not already open. When the master device is opened, the corresponding
- * slave device is automatically locked out. Only one open is allowed on a
- * master device.  Multiple opens are allowed on the slave device.  After both
- * the master and slave have been opened, the user has two file descriptors
- * which are the end points of a full duplex connection composed of two streams
- * which are automatically connected at the master and slave drivers. The user
- * may then push modules onto either side of the stream pair.
+ * A manager device is available only if it and its corresponding subsidiary
+ * device are not already open.  When the manager device is opened, the
+ * corresponding subsidiary device is automatically locked out.  Only one open
+ * is allowed on a manager device.  Multiple opens are allowed on the
+ * subsidiary device.  After both the manager and subsidiary have been opened,
+ * the user has two file descriptors which are the end points of a full duplex
+ * connection composed of two streams which are automatically connected at the
+ * manager and subsidiary drivers.  The user may then push modules onto either
+ * side of the stream pair.
  *
- * The master and slave drivers pass all messages to their adjacent queues.
- * Only the M_FLUSH needs some processing.  Because the read queue of one side
- * is connected to the write queue of the other, the FLUSHR flag is changed to
- * the FLUSHW flag and vice versa. When the master device is closed an M_HANGUP
- * message is sent to the slave device which will render the device
- * unusable. The process on the slave side gets the EIO when attempting to write
- * on that stream but it will be able to read any data remaining on the stream
- * head read queue.  When all the data has been read, read() returns 0
- * indicating that the stream can no longer be used.  On the last close of the
- * slave device, a 0-length message is sent to the master device. When the
- * application on the master side issues a read() or getmsg() and 0 is returned,
- * the user of the master device decides whether to issue a close() that
- * dismantles the pseudo-terminal subsystem. If the master device is not closed,
- * the pseudo-tty subsystem will be available to another user to open the slave
- * device.
+ * The manager and subsidiary drivers pass all messages to their adjacent
+ * queues.  Only the M_FLUSH needs some processing.  Because the read queue of
+ * one side is connected to the write queue of the other, the FLUSHR flag is
+ * changed to the FLUSHW flag and vice versa.  When the manager device is
+ * closed an M_HANGUP message is sent to the subsidiary device which will
+ * render the device unusable.  The process on the subsidiary side gets the EIO
+ * when attempting to write on that stream but it will be able to read any data
+ * remaining on the stream head read queue.  When all the data has been read,
+ * read() returns 0 indicating that the stream can no longer be used.  On the
+ * last close of the subsidiary device, a 0-length message is sent to the
+ * manager device.  When the application on the manager side issues a read() or
+ * getmsg() and 0 is returned, the user of the manager device decides whether
+ * to issue a close() that dismantles the pseudo-terminal subsystem.  If the
+ * manager device is not closed, the pseudo-tty subsystem will be available to
+ * another user to open the subsidiary device.
  *
- * Synchronization:
  *
- *   All global data synchronization between ptm/pts is done via global
- *   ptms_lock mutex which is initialized at system boot time from
- *   ptms_initspace (called from space.c).
+ * SYNCHRONIZATION
  *
- *   Individual fields of pt_ttys structure (except ptm_rdq, pts_rdq and
- *   pt_nullmsg) are protected by pt_ttys.pt_lock mutex.
+ * All global data synchronization between ptm/pts is done via global ptms_lock
+ * mutex which is initialized at system boot time from ptms_initspace (called
+ * from space.c).
  *
- *   PT_ENTER_READ/PT_ENTER_WRITE are reference counter based read-write locks
- *   which allow reader locks to be reacquired by the same thread (usual
- *   reader/writer locks can't be used for that purpose since it is illegal for
- *   a thread to acquire a lock it already holds, even as a reader). The sole
- *   purpose of these macros is to guarantee that the peer queue will not
- *   disappear (due to closing peer) while it is used. It is safe to use
- *   PT_ENTER_READ/PT_EXIT_READ brackets across calls like putq/putnext (since
- *   they are not real locks but reference counts).
+ * Individual fields of pt_ttys structure (except ptm_rdq, pts_rdq and
+ * pt_nullmsg) are protected by pt_ttys.pt_lock mutex.
  *
- *   PT_ENTER_WRITE/PT_EXIT_WRITE brackets are used ONLY in master/slave
- *   open/close paths to modify ptm_rdq and pts_rdq fields. These fields should
- *   be set to appropriate queues *after* qprocson() is called during open (to
- *   prevent peer from accessing the queue with incomplete plumbing) and set to
- *   NULL before qprocsoff() is called during close.
+ * PT_ENTER_READ/PT_ENTER_WRITE are reference counter based read-write locks
+ * which allow reader locks to be reacquired by the same thread (usual
+ * reader/writer locks can't be used for that purpose since it is illegal for a
+ * thread to acquire a lock it already holds, even as a reader).  The sole
+ * purpose of these macros is to guarantee that the peer queue will not
+ * disappear (due to closing peer) while it is used.  It is safe to use
+ * PT_ENTER_READ/PT_EXIT_READ brackets across calls like putq/putnext (since
+ * they are not real locks but reference counts).
  *
- *   The pt_nullmsg field is only used in open/close routines and it is also
- *   protected by PT_ENTER_WRITE/PT_EXIT_WRITE brackets to avoid extra mutex
- *   holds.
+ * PT_ENTER_WRITE/PT_EXIT_WRITE brackets are used ONLY in manager/subsidiary
+ * open/close paths to modify ptm_rdq and pts_rdq fields.  These fields should
+ * be set to appropriate queues *after* qprocson() is called during open (to
+ * prevent peer from accessing the queue with incomplete plumbing) and set to
+ * NULL before qprocsoff() is called during close.
  *
- * Lock Ordering:
+ * The pt_nullmsg field is only used in open/close routines and it is also
+ * protected by PT_ENTER_WRITE/PT_EXIT_WRITE brackets to avoid extra mutex
+ * holds.
  *
- *   If both ptms_lock and per-pty lock should be held, ptms_lock should always
- *   be entered first, followed by per-pty lock.
  *
- * See ptms.h, ptm.c and ptms_conf.c fore more information.
+ * LOCK ORDERING
+ *
+ * If both ptms_lock and per-pty lock should be held, ptms_lock should always
+ * be entered first, followed by per-pty lock.
  *
+ * See ptms.h, ptm.c and ptms_conf.c fore more information.
  */
 
 #include <sys/types.h>
@@ -135,9 +139,6 @@ static int ptswput(queue_t *, mblk_t *);
 static int ptsrsrv(queue_t *);
 static int ptswsrv(queue_t *);
 
-/*
- * Slave Stream Pseudo Terminal Module: stream data structure definitions
- */
 static struct module_info pts_info = {
 	0xface,
 	"pts",
@@ -192,9 +193,9 @@ DDI_DEFINE_STREAM_OPS(pts_ops, nulldev, nulldev,	\
  */
 
 static struct modldrv modldrv = {
-	&mod_driverops, /* Type of module.  This one is a pseudo driver */
-	"Slave Stream Pseudo Terminal driver 'pts'",
-	&pts_ops,	/* driver ops */
+	&mod_driverops,
+	"Pseudo-Terminal Subsidiary Driver",
+	&pts_ops,
 };
 
 static struct modlinkage modlinkage = {
@@ -239,7 +240,6 @@ pts_attach(dev_info_t *devi, ddi_attach_cmd_t cmd)
 	return (DDI_SUCCESS);
 }
 
-/*ARGSUSED*/
 static int
 pts_detach(dev_info_t *devi, ddi_detach_cmd_t cmd)
 {
@@ -252,7 +252,6 @@ pts_detach(dev_info_t *devi, ddi_detach_cmd_t cmd)
 	return (DDI_FAILURE);
 }
 
-/*ARGSUSED*/
 static int
 pts_devinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg,
     void **result)
@@ -280,9 +279,9 @@ pts_devinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg,
 
 /* ARGSUSED */
 /*
- * Open the slave device. Reject a clone open and do not allow the
- * driver to be pushed. If the slave/master pair is locked or if
- * the master is not open, return EACCESS.
+ * Open the subsidiary device. Reject a clone open and do not allow the
+ * driver to be pushed. If the subsidiary/manager pair is locked or if
+ * the manager is not open, return EACCESS.
  * Upon success, store the write queue pointer in private data and
  * set the PTSOPEN bit in the pt_state field.
  */
@@ -369,10 +368,10 @@ ptsopen(
 	}
 
 	/*
-	 * Slave should send zero-length message to a master when it is
-	 * closing. If memory is low at that time, master will not detect slave
-	 * closes, this pty will not be deallocated. So, preallocate this
-	 * zero-length message block early.
+	 * Subsidiary should send zero-length message to a manager when it is
+	 * closing.  If memory is low at that time, manager will not detect
+	 * subsidiary closes, this pty will not be deallocated.  So,
+	 * preallocate this zero-length message block early.
 	 */
 	if ((mp = allocb(0, BPRI_MED)) == NULL) {
 		mutex_exit(&ptsp->pt_lock);
@@ -395,9 +394,10 @@ ptsopen(
 
 	/*
 	 * After qprocson pts driver is fully plumbed into the stream and can
-	 * send/receive messages. Setting pts_rdq will allow master side to send
-	 * messages to the slave. This setting can't occur before qprocson() is
-	 * finished because slave is not ready to process them.
+	 * send/receive messages.  Setting pts_rdq will allow manager side to
+	 * send messages to the subsidiary.  This setting can't occur before
+	 * qprocson() is finished because subsidiary is not ready to process
+	 * them.
 	 */
 	PT_ENTER_WRITE(ptsp);
 	ptsp->pts_rdq = rqp;
@@ -422,12 +422,11 @@ ptsopen(
 }
 
 /*
- * Find the address to private data identifying the slave's write
- * queue. Send a 0-length msg up the slave's read queue to designate
- * the master is closing. Uattach the master from the slave by nulling
- * out master's write queue field in private data.
+ * Find the address to private data identifying the subsidiary's write queue.
+ * Send a 0-length msg up the subsidiary's read queue to designate the manager
+ * is closing.  Uattach the manager from the subsidiary by nulling out
+ * manager's write queue field in private data.
  */
-/*ARGSUSED1*/
 static int
 ptsclose(queue_t *rqp, int flag, cred_t *credp)
 {
@@ -450,10 +449,10 @@ ptsclose(queue_t *rqp, int flag, cred_t *credp)
 	ptsp = (struct pt_ttys *)rqp->q_ptr;
 
 	/*
-	 * Slave is going to close and doesn't want any new  messages coming
-	 * from the master side, so set pts_rdq to NULL. This should be done
-	 * before call to qprocsoff() since slave can't process additional
-	 * messages from the master after qprocsoff is called.
+	 * Subsidiary is going to close and doesn't want any new messages
+	 * coming from the manager side, so set pts_rdq to NULL.  This should
+	 * be done before call to qprocsoff() since subsidiary can't process
+	 * additional messages from the manager after qprocsoff is called.
 	 */
 	PT_ENTER_WRITE(ptsp);
 	mp = ptsp->pt_nullmsg;
@@ -479,8 +478,8 @@ ptsclose(queue_t *rqp, int flag, cred_t *credp)
 		}
 	}
 	/*
-	 * qenable master side write queue so that it can flush
-	 * its messages as slaves's read queue is going away
+	 * qenable manager side write queue so that it can flush its messages
+	 * as subsidiarys's read queue is going away:
 	 */
 	if (ptsp->ptm_rdq) {
 		if (mp)
@@ -503,9 +502,9 @@ ptsclose(queue_t *rqp, int flag, cred_t *credp)
 
 
 /*
- * The wput procedure will only handle flush messages.
- * All other messages are queued and the write side
- * service procedure sends them off to the master side.
+ * The wput procedure will only handle flush messages.  All other messages are
+ * queued and the write side service procedure sends them off to the manager
+ * side.
  */
 static int
 ptswput(queue_t *qp, mblk_t *mp)
@@ -520,9 +519,9 @@ ptswput(queue_t *qp, mblk_t *mp)
 	ptsp = (struct pt_ttys *)qp->q_ptr;
 	PT_ENTER_READ(ptsp);
 	if (ptsp->ptm_rdq == NULL) {
-		DBG(("in write put proc but no master\n"));
+		DBG(("in write put proc but no manager\n"));
 		/*
-		 * NAK ioctl as slave side read queue is gone.
+		 * NAK ioctl as subsidiary side read queue is gone.
 		 * Or else free the message.
 		 */
 		if (mp->b_datap->db_type == M_IOCTL) {
@@ -540,7 +539,7 @@ ptswput(queue_t *qp, mblk_t *mp)
 		switch (type) {
 
 		/*
-		 * if write queue request, flush slave's write
+		 * if write queue request, flush subsidiary's write
 		 * queue and send FLUSHR to ptm. If read queue
 		 * request, send FLUSHR to ptm.
 		 */
@@ -585,9 +584,9 @@ ptswput(queue_t *qp, mblk_t *mp)
 			}
 		}
 		/*
-		 * Since the packet module will toss any
-		 * M_FLUSHES sent to the master's stream head
-		 * read queue, we simply turn it around here.
+		 * Since the packet module will toss any M_FLUSHES sent to the
+		 * manager's stream head read queue, we simply turn it around
+		 * here.
 		 */
 		if (*mp->b_rptr & FLUSHR) {
 			ASSERT(RD(qp)->q_first == NULL);
@@ -599,7 +598,7 @@ ptswput(queue_t *qp, mblk_t *mp)
 		break;
 
 		case M_READ:
-		/* Caused by ldterm - can not pass to master */
+		/* Caused by ldterm - can not pass to manager */
 		freemsg(mp);
 		break;
 
@@ -645,9 +644,9 @@ ptswput(queue_t *qp, mblk_t *mp)
 		/* FALLTHROUGH */
 	default:
 		/*
-		 * send other messages to the master
+		 * send other messages to the manager
 		 */
-		DBG(("put msg on slave's write queue\n"));
+		DBG(("put msg on subsidiary's write queue\n"));
 		(void) putq(qp, mp);
 		break;
 	}
@@ -659,9 +658,8 @@ ptswput(queue_t *qp, mblk_t *mp)
 
 
 /*
- * enable the write side of the master. This triggers the
- * master to send any messages queued on its write side to
- * the read side of this slave.
+ * Enable the write side of the manager.  This triggers the manager to send any
+ * messages queued on its write side to the read side of this subsidiary.
  */
 static int
 ptsrsrv(queue_t *qp)
@@ -674,7 +672,7 @@ ptsrsrv(queue_t *qp)
 	ptsp = (struct pt_ttys *)qp->q_ptr;
 	PT_ENTER_READ(ptsp);
 	if (ptsp->ptm_rdq == NULL) {
-		DBG(("in read srv proc but no master\n"));
+		DBG(("in read srv proc but no manager\n"));
 		PT_EXIT_READ(ptsp);
 		return (0);
 	}
@@ -685,10 +683,10 @@ ptsrsrv(queue_t *qp)
 }
 
 /*
- * If there are messages on this queue that can be sent to
- * master, send them via putnext(). Else, if queued messages
- * cannot be sent, leave them on this queue. If priority
- * messages on this queue, send them to master no matter what.
+ * If there are messages on this queue that can be sent to manager, send them
+ * via putnext().  Otherwise, if queued messages cannot be sent, leave them on
+ * this queue.  If priority messages on this queue, send them to manager no
+ * matter what.
  */
 static int
 ptswsrv(queue_t *qp)
@@ -703,12 +701,11 @@ ptswsrv(queue_t *qp)
 	ptsp = (struct pt_ttys *)qp->q_ptr;
 	PT_ENTER_READ(ptsp);
 	if (ptsp->ptm_rdq == NULL) {
-		DBG(("in write srv proc but no master\n"));
+		DBG(("in write srv proc but no manager\n"));
 		/*
-		 * Free messages on the write queue and send
-		 * NAK for any M_IOCTL type messages to wakeup
-		 * the user process waiting for ACK/NAK from
-		 * the ioctl invocation
+		 * Free messages on the write queue and send NAK for any
+		 * M_IOCTL type messages to wakeup the user process waiting for
+		 * ACK/NAK from the ioctl invocation
 		 */
 		while ((mp = getq(qp)) != NULL) {
 			if (mp->b_datap->db_type == M_IOCTL) {
@@ -726,13 +723,12 @@ ptswsrv(queue_t *qp)
 	}
 
 	/*
-	 * while there are messages on this write queue...
+	 * While there are messages on this write queue...
 	 */
 	while ((mp = getq(qp)) != NULL) {
 		/*
-		 * if don't have control message and cannot put
-		 * msg. on master's read queue, put it back on
-		 * this queue.
+		 * If this is not a control message and we cannot put messages
+		 * on the manager's read queue, put it back on this queue.
 		 */
 		if (mp->b_datap->db_type <= QPCTL &&
 		    !bcanputnext(ptm_rdq, mp->b_band)) {
@@ -741,9 +737,9 @@ ptswsrv(queue_t *qp)
 			break;
 		}
 		/*
-		 * else send the message up master's stream
+		 * Otherwise, send the message up manager's stream:
 		 */
-		DBG(("send message to master\n"));
+		DBG(("send message to manager\n"));
 		putnext(ptm_rdq, mp);
 	}
 	DBG(("leaving ptswsrv\n"));
diff --git a/usr/src/uts/common/io/tty_pts.c b/usr/src/uts/common/io/tty_pts.c
index 2e69280908..65a4669259 100644
--- a/usr/src/uts/common/io/tty_pts.c
+++ b/usr/src/uts/common/io/tty_pts.c
@@ -12,7 +12,7 @@
 
 /*
  * PTY - Stream "pseudo-tty" device.
- * This is the "slave" side.
+ * This is the "subsidiary" side.
  */
 
 
@@ -30,7 +30,7 @@
 #include <sys/user.h>
 #include <sys/conf.h>
 #include <sys/file.h>
-#include <sys/vnode.h>	/* 1/0 on the vomit meter */
+#include <sys/vnode.h>
 #include <sys/proc.h>
 #include <sys/uio.h>
 #include <sys/errno.h>
@@ -65,7 +65,7 @@ extern struct pollhead	ptcph;	/* poll head for ptcpoll() use */
  */
 
 /*
- * Slave side.  This is a streams device.
+ * Subsidiary side.  This is a streams device.
  */
 static int ptslopen(queue_t *, dev_t *, int flag, int, cred_t *);
 static int ptslclose(queue_t *, int, cred_t *);
@@ -141,7 +141,7 @@ DDI_DEFINE_STREAM_OPS(ptsl_ops, nulldev, nulldev,
 
 static struct modldrv modldrv = {
 	&mod_driverops, /* Type of module.  This one is a pseudo driver */
-	"tty pseudo driver slave 'ptsl'",
+	"tty pseudo driver subsidiary 'ptsl'",
 	&ptsl_ops,	/* driver ops */
 };
 
@@ -226,7 +226,7 @@ ptsl_info(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg,
 
 
 /*
- * Open the slave side of a pty.
+ * Open the subsidiary side of a pty.
  */
 /*ARGSUSED*/
 static int
@@ -277,13 +277,13 @@ again:
 
 	pty->pt_sdev = dev;
 	q->q_ptr = WR(q)->q_ptr = pty;
-	pty->pt_flags &= ~PF_SLAVEGONE;
+	pty->pt_flags &= ~PF_SUBSIDGONE;
 	pty->pt_ttycommon.t_readq = pty->pt_ttycommon.t_writeq = NULL;
 
 	/*
-	 * Slave is ready to accept messages but master still can't send
-	 * messages to the slave queue since it is not plumbed
-	 * yet. So do qprocson() and finish slave initialization.
+	 * Subsidiary is ready to accept messages but manager still can't send
+	 * messages to the subsidiary queue since it is not plumbed
+	 * yet. So do qprocson() and finish subsidiary initialization.
 	 */
 
 	mutex_exit(&pty->ptc_lock);
@@ -291,8 +291,8 @@ again:
 	qprocson(q);
 
 	/*
-	 * Now it is safe to send messages to q, so wakeup master possibly
-	 * waiting for slave queue to finish open.
+	 * Now it is safe to send messages to q, so wakeup manager possibly
+	 * waiting for subsidiary queue to finish open.
 	 */
 	mutex_enter(&pty->ptc_lock);
 	/*
@@ -303,7 +303,7 @@ again:
 	VN_RELE(pty->pt_vnode);
 	pty->pt_ttycommon.t_readq = q;
 	pty->pt_ttycommon.t_writeq = WR(q);
-	/* tell master device that slave is ready for writing */
+	/* tell manager device that subsidiary is ready for writing */
 	if (pty->pt_flags & PF_CARR_ON)
 		cv_broadcast(&pty->pt_cv_readq);
 	mutex_exit(&pty->ptc_lock);
@@ -326,10 +326,10 @@ ptslclose(queue_t *q, int flag, cred_t *cred)
 		return (ENODEV);	/* already been closed once */
 
 	/*
-	 * Prevent the queues from being uses by master device.
-	 * This should be done before qprocsoff or writer may attempt
-	 * to use the slave queue after qprocsoff removed it from the stream and
-	 * before entering mutex_enter().
+	 * Prevent the queues from being uses by manager device.  This should
+	 * be done before qprocsoff or writer may attempt to use the subsidiary
+	 * queue after qprocsoff removed it from the stream and before entering
+	 * mutex_enter().
 	 */
 	mutex_enter(&pty->ptc_lock);
 	pty->pt_ttycommon.t_readq = NULL;
@@ -359,11 +359,11 @@ ptslclose(queue_t *q, int flag, cred_t *cred)
 	}
 
 	/*
-	 * Clear out all the slave-side state.
+	 * Clear out all the subsidiary-side state.
 	 */
 	pty->pt_flags &= ~(PF_WOPEN|PF_STOPPED|PF_NOSTOP);
 	if (pty->pt_flags & PF_CARR_ON) {
-		pty->pt_flags |= PF_SLAVEGONE;	/* let the controller know */
+		pty->pt_flags |= PF_SUBSIDGONE;	/* let the controller know */
 		ptcpollwakeup(pty, 0);	/* wake up readers/selectors */
 		ptcpollwakeup(pty, FWRITE);	/* wake up writers/selectors */
 		cv_broadcast(&pty->pt_cv_flags);
@@ -942,10 +942,10 @@ pt_sendstop(struct pty *pty)
 	if ((pty->pt_ttycommon.t_cflag&CBAUD) == 0) {
 		if (pty->pt_flags & PF_CARR_ON) {
 			/*
-			 * Let the controller know, then wake up
+			 * Let the manager know, then wake up
 			 * readers/selectors and writers/selectors.
 			 */
-			pty->pt_flags |= PF_SLAVEGONE;
+			pty->pt_flags |= PF_SUBSIDGONE;
 			ptcpollwakeup(pty, 0);
 			ptcpollwakeup(pty, FWRITE);
 		}
@@ -977,7 +977,7 @@ pt_sendstop(struct pty *pty)
  * user control mode message has been queued up (this data is readable,
  * so we also treat it as a regular data event; should we send SIGIO,
  * though?), FREAD if regular data has been queued up, or FWRITE if
- * the slave's read queue has drained sufficiently to allow writing.
+ * the subsidiary's read queue has drained sufficiently to allow writing.
  */
 static void
 ptcpollwakeup(struct pty *pty, int flag)
@@ -997,7 +997,7 @@ ptcpollwakeup(struct pty *pty, int flag)
 	if (flag & FREAD) {
 		/*
 		 * Wake up the parent process as there is regular
-		 * data to read from slave's write queue
+		 * data to read from subsidiary's write queue
 		 */
 		pollwakeup(&ptcph, POLLIN | POLLRDNORM);
 		cv_broadcast(&pty->pt_cv_writeq);
@@ -1007,7 +1007,7 @@ ptcpollwakeup(struct pty *pty, int flag)
 	if (flag & FWRITE) {
 		/*
 		 * Wake up the parent process to write
-		 * data into slave's read queue as the
+		 * data into subsidiary's read queue as the
 		 * read queue has drained enough
 		 */
 		pollwakeup(&ptcph, POLLOUT | POLLWRNORM);
diff --git a/usr/src/uts/common/io/tty_pty.c b/usr/src/uts/common/io/tty_pty.c
index c1e15de161..d6bbda6626 100644
--- a/usr/src/uts/common/io/tty_pty.c
+++ b/usr/src/uts/common/io/tty_pty.c
@@ -11,8 +11,8 @@
  */
 
 /*
- * PTY - Stream "pseudo-tty" device.  For each "controller" side
- * it connects to a "slave" side.
+ * PTY - Stream "pseudo-terminal" device.  For each "manager" side it connects
+ * to a "subsidiary" side.
  */
 
 
@@ -29,7 +29,7 @@
 #include <sys/user.h>
 #include <sys/conf.h>
 #include <sys/file.h>
-#include <sys/vnode.h>	/* 1/0 on the vomit meter */
+#include <sys/vnode.h>
 #include <sys/proc.h>
 #include <sys/uio.h>
 #include <sys/errno.h>
@@ -116,9 +116,9 @@ extern struct dev_ops ptc_ops;
  */
 
 static struct modldrv modldrv = {
-	&mod_driverops, /* Type of module.  This one is a pseudo driver */
+	&mod_driverops,
 	"tty pseudo driver control 'ptc'",
-	&ptc_ops,	/* driver ops */
+	&ptc_ops,
 };
 
 static struct modlinkage modlinkage = {
@@ -236,12 +236,11 @@ ptc_uninit(void)
 }
 
 /*
- * Controller side.  This is not, alas, a streams device; there are too
+ * Manager side.  This is not, alas, a streams device; there are too
  * many old features that we must support and that don't work well
  * with streams.
  */
 
-/*ARGSUSED*/
 int
 ptcopen(dev_t *devp, int flag, int otyp, struct cred *cred)
 {
@@ -256,7 +255,7 @@ ptcopen(dev_t *devp, int flag, int otyp, struct cred *cred)
 	mutex_enter(&pty->ptc_lock);
 	if (pty->pt_flags & PF_CARR_ON) {
 		mutex_exit(&pty->ptc_lock);
-		return (EIO);	/* controller is exclusive use */
+		return (EIO);	/* manager is exclusive use */
 				/* XXX - should be EBUSY! */
 	}
 	if (pty->pt_flags & PF_WOPEN) {
@@ -266,7 +265,7 @@ ptcopen(dev_t *devp, int flag, int otyp, struct cred *cred)
 
 	if ((q = pty->pt_ttycommon.t_readq) != NULL) {
 		/*
-		 * Send an un-hangup to the slave, since "carrier" is
+		 * Send an un-hangup to the subsidiary, since "carrier" is
 		 * coming back up.  Make sure we're doing canonicalization.
 		 */
 		(void) putctl(q, M_UNHANGUP);
@@ -280,7 +279,6 @@ ptcopen(dev_t *devp, int flag, int otyp, struct cred *cred)
 	return (0);
 }
 
-/*ARGSUSED1*/
 int
 ptcclose(dev_t dev, int flag, int otyp, struct cred *cred)
 {
@@ -293,15 +291,15 @@ ptcclose(dev_t dev, int flag, int otyp, struct cred *cred)
 	mutex_enter(&pty->ptc_lock);
 	if ((q = pty->pt_ttycommon.t_readq) != NULL) {
 		/*
-		 * Send a hangup to the slave, since "carrier" is dropping.
+		 * Send a hangup to the subsidiary, since "carrier" is dropping.
 		 */
 		(void) putctl(q, M_HANGUP);
 	}
 
 	/*
-	 * Clear out all the controller-side state.  This also
+	 * Clear out all the manager-side state.  This also
 	 * clears PF_CARR_ON, which is correct because the
-	 * "carrier" is dropping since the controller process
+	 * "carrier" is dropping since the manager process
 	 * is going away.
 	 */
 	pty->pt_flags &= (PF_WOPEN|PF_STOPPED|PF_NOSTOP);
@@ -329,10 +327,6 @@ ptcread(dev_t dev, struct uio *uio, struct cred *cred)
 	int error;
 	off_t off;
 
-#ifdef lint
-	cred = cred;
-#endif
-
 	off = uio->uio_offset;
 
 	mutex_enter(&pty->ptc_lock);
@@ -475,14 +469,14 @@ ptcread(dev_t dev, struct uio *uio, struct cred *cred)
 
 		/*
 		 * There's no data available.
-		 * We want to block until the slave is open, and there's
-		 * something to read; but if we lost the slave or we're NBIO,
-		 * then return the appropriate error instead.  POSIX-style
-		 * non-block has top billing and gives -1 with errno = EAGAIN,
-		 * BSD-style comes next and gives -1 with errno = EWOULDBLOCK,
-		 * SVID-style comes last and gives 0.
+		 * We want to block until the subsidiary is open, and there's
+		 * something to read; but if we lost the subsidiary or we're
+		 * NBIO, then return the appropriate error instead.
+		 * POSIX-style non-block has top billing and gives -1 with
+		 * errno = EAGAIN, BSD-style comes next and gives -1 with
+		 * errno = EWOULDBLOCK, SVID-style comes last and gives 0.
 		 */
-		if (pty->pt_flags & PF_SLAVEGONE) {
+		if (pty->pt_flags & PF_SUBSIDGONE) {
 			error = EIO;
 			goto out;
 		}
@@ -532,11 +526,6 @@ ptcwrite(dev_t dev, struct uio *uio, struct cred *cred)
 	off_t off;
 	off = uio->uio_offset;
 
-#ifdef lint
-	cred = cred;
-#endif
-
-
 	mutex_enter(&pty->ptc_lock);
 
 again:
@@ -550,9 +539,9 @@ again:
 	if ((q = pty->pt_ttycommon.t_readq) == NULL) {
 
 		/*
-		 * Wait for slave to open.
+		 * Wait for subsidiary to open.
 		 */
-		if (pty->pt_flags & PF_SLAVEGONE) {
+		if (pty->pt_flags & PF_SUBSIDGONE) {
 			error = EIO;
 			goto out;
 		}
@@ -588,9 +577,9 @@ again:
 		do {
 			while (!canput(q)) {
 				/*
-				 * Wait for slave's read queue to unclog.
+				 * Wait for subsidiary's read queue to unclog.
 				 */
-				if (pty->pt_flags & PF_SLAVEGONE) {
+				if (pty->pt_flags & PF_SUBSIDGONE) {
 					error = EIO;
 					goto out;
 				}
@@ -763,7 +752,7 @@ ptcioctl(dev_t dev, int cmd, intptr_t data, int flag, struct cred *cred,
 
 	case TIOCSIGNAL:
 		/*
-		 * Blast a M_PCSIG message up the slave stream; the
+		 * Blast a M_PCSIG message up the subsidiary stream; the
 		 * signal number is the argument to the "ioctl".
 		 */
 		copy_in(data, d_arg);
@@ -794,7 +783,7 @@ ptcioctl(dev_t dev, int cmd, intptr_t data, int flag, struct cred *cred,
 		break;
 
 	/*
-	 * These, at least, can work on the controller-side process
+	 * These, at least, can work on the manager-side process
 	 * group.
 	 */
 	case FIOGETOWN:
@@ -813,9 +802,9 @@ ptcioctl(dev_t dev, int cmd, intptr_t data, int flag, struct cred *cred,
 
 	case FIONREAD: {
 		/*
-		 * Return the total number of bytes of data in all messages
-		 * in slave write queue, which is master read queue, unless a
-		 * special message would be read.
+		 * Return the total number of bytes of data in all messages in
+		 * subsidiary write queue, which is manager read queue, unless
+		 * a special message would be read.
 		 */
 		mblk_t *mp;
 		size_t count = 0;
@@ -916,13 +905,13 @@ ptcioctl(dev_t dev, int cmd, intptr_t data, int flag, struct cred *cred,
 
 	/*
 	 * XXX These should not be here.  The only reason why an
-	 * "ioctl" on the controller side should get the
-	 * slave side's process group is so that the process on
-	 * the controller side can send a signal to the slave
+	 * "ioctl" on the manager side should get the
+	 * subsidiary side's process group is so that the process on
+	 * the manager side can send a signal to the subsidiary
 	 * side's process group; however, this is better done
 	 * with TIOCSIGNAL, both because it doesn't require us
-	 * to know about the slave side's process group and because
-	 * the controller side process may not have permission to
+	 * to know about the subsidiary side's process group and because
+	 * the manager side process may not have permission to
 	 * send that signal to the entire process group.
 	 *
 	 * However, since vanilla 4BSD doesn't provide TIOCSIGNAL,
@@ -933,9 +922,9 @@ ptcioctl(dev_t dev, int cmd, intptr_t data, int flag, struct cred *cred,
 	/*
 	 * This is amazingly disgusting, but the stupid semantics of
 	 * 4BSD pseudo-ttys makes us do it.  If we do one of these guys
-	 * on the controller side, it really applies to the slave-side
+	 * on the manager side, it really applies to the subsidiary-side
 	 * stream.  It should NEVER have been possible to do ANY sort
-	 * of tty operations on the controller side, but it's too late
+	 * of tty operations on the manager side, but it's too late
 	 * to fix that now.  However, we won't waste our time implementing
 	 * anything that the original pseudo-tty driver didn't handle.
 	 */
@@ -983,9 +972,6 @@ ptcpoll(dev_t dev, short events, int anyyet, short *reventsp,
 	queue_t *q;
 	int pos = 0;
 
-#ifdef lint
-	anyyet = anyyet;
-#endif
 	if (polllock(php, &pty->ptc_lock) != 0) {
 		*reventsp = POLLNVAL;
 		return (0);
@@ -994,7 +980,7 @@ ptcpoll(dev_t dev, short events, int anyyet, short *reventsp,
 	ASSERT(MUTEX_HELD(&pty->ptc_lock));
 
 	*reventsp = 0;
-	if (pty->pt_flags & PF_SLAVEGONE) {
+	if (pty->pt_flags & PF_SUBSIDGONE) {
 		if (events & (POLLIN|POLLRDNORM))
 			*reventsp |= (events & (POLLIN|POLLRDNORM));
 		if (events & (POLLOUT|POLLWRNORM))
diff --git a/usr/src/uts/common/io/zcons.c b/usr/src/uts/common/io/zcons.c
index 8430e3e8cb..eb74c3a039 100644
--- a/usr/src/uts/common/io/zcons.c
+++ b/usr/src/uts/common/io/zcons.c
@@ -30,18 +30,18 @@
  * This driver, derived from the pts/ptm drivers, is the pseudo console driver
  * for system zones.  Its implementation is straightforward.  Each instance
  * of the driver represents a global-zone/local-zone pair (this maps in a
- * straightforward way to the commonly used terminal notion of "master side"
- * and "slave side", and we use that terminology throughout).
+ * straightforward way to the commonly used terminal notion of "manager side"
+ * and "subsidiary side", and we use that terminology throughout).
  *
  * Instances of zcons are onlined as children of /pseudo/zconsnex@1/
  * by zoneadmd in userland, using the devctl framework; thus the driver
  * does not need to maintain any sort of "admin" node.
  *
- * The driver shuttles I/O from master side to slave side and back.  In a break
- * from the pts/ptm semantics, if one side is not open, I/O directed towards
- * it will simply be discarded.  This is so that if zoneadmd is not holding
- * the master side console open (i.e. it has died somehow), processes in
- * the zone do not experience any errors and I/O to the console does not
+ * The driver shuttles I/O from manager side to subsidiary side and back.  In a
+ * break from the pts/ptm semantics, if one side is not open, I/O directed
+ * towards it will simply be discarded.  This is so that if zoneadmd is not
+ * holding the manager side console open (i.e. it has died somehow), processes
+ * in the zone do not experience any errors and I/O to the console does not
  * hang.
  *
  * TODO: we may want to revisit the other direction; i.e. we may want
@@ -50,64 +50,67 @@
  *
  *
  *
- * MASTER SIDE IOCTLS
+ * MANAGER SIDE IOCTLS
  *
- * The ZC_HOLDSLAVE and ZC_RELEASESLAVE ioctls instruct the master side of the
- * console to hold and release a reference to the slave side's vnode.  They are
- * meant to be issued by zoneadmd after the console device node is created and
- * before it is destroyed so that the slave's STREAMS anchor, ptem, is
- * preserved when ttymon starts popping STREAMS modules from within the
- * associated zone.  This guarantees that the zone console will always have
+ * The ZC_HOLDSUBSID and ZC_RELEASESUBSID ioctls instruct the manager side of
+ * the console to hold and release a reference to the subsidiary side's vnode.
+ * They are meant to be issued by zoneadmd after the console device node is
+ * created and before it is destroyed so that the subsidiary's STREAMS anchor,
+ * ptem, is preserved when ttymon starts popping STREAMS modules from within
+ * the associated zone.  This guarantees that the zone console will always have
  * terminal semantics while the zone is running.
  *
  * Here is the issue: the ptem module is anchored in the zone console
- * (slave side) so that processes within the associated non-global zone will
- * fail to pop it off, thus ensuring that the slave will retain terminal
- * semantics.  When a process attempts to pop the anchor off of a stream, the
- * STREAMS subsystem checks whether the calling process' zone is the same as
- * that of the process that pushed the anchor onto the stream and cancels the
- * pop if they differ.  zoneadmd used to hold an open file descriptor for the
- * slave while the associated non-global zone ran, thus ensuring that the
- * slave's STREAMS anchor would never be popped from within the non-global zone
- * (because zoneadmd runs in the global zone).  However, this file descriptor
- * was removed to make zone console management more robust.  sad(7D) is now
- * used to automatically set up the slave's STREAMS modules when the zone
- * console is freshly opened within the associated non-global zone.  However,
- * when a process within the non-global zone freshly opens the zone console, the
- * anchor is pushed from within the non-global zone, making it possible for
- * processes within the non-global zone (e.g., ttymon) to pop the anchor and
- * destroy the zone console's terminal semantics.
+ * (subsidiary side) so that processes within the associated non-global zone
+ * will fail to pop it off, thus ensuring that the subsidiary will retain
+ * terminal semantics.  When a process attempts to pop the anchor off of a
+ * stream, the STREAMS subsystem checks whether the calling process' zone is
+ * the same as that of the process that pushed the anchor onto the stream and
+ * cancels the pop if they differ.  zoneadmd used to hold an open file
+ * descriptor for the subsidiary while the associated non-global zone ran, thus
+ * ensuring that the subsidiary's STREAMS anchor would never be popped from
+ * within the non-global zone (because zoneadmd runs in the global zone).
+ * However, this file descriptor was removed to make zone console management
+ * more robust.  sad(7D) is now used to automatically set up the subsidiary's
+ * STREAMS modules when the zone console is freshly opened within the
+ * associated non-global zone.  However, when a process within the non-global
+ * zone freshly opens the zone console, the anchor is pushed from within the
+ * non-global zone, making it possible for processes within the non-global zone
+ * (e.g., ttymon) to pop the anchor and destroy the zone console's terminal
+ * semantics.
  *
- * One solution is to make the zcons device hold the slave open while the
+ * One solution is to make the zcons device hold the subsidiary open while the
  * associated non-global zone runs so that the STREAMS anchor will always be
- * associated with the global zone.  Unfortunately, the slave cannot be opened
- * from within the zcons driver because the driver is not reentrant: it has
- * an outer STREAMS perimeter.  Therefore, the next best option is for zcons to
- * provide an ioctl interface to zoneadmd to manage holding and releasing
- * the slave side of the console.  It is sufficient to hold the slave side's
- * vnode and bump the associated snode's reference count to preserve the slave's
- * STREAMS configuration while the associated zone runs, so that's what the
- * ioctls do.
+ * associated with the global zone.  Unfortunately, the subsidiary cannot be
+ * opened from within the zcons driver because the driver is not reentrant: it
+ * has an outer STREAMS perimeter.  Therefore, the next best option is for
+ * zcons to provide an ioctl interface to zoneadmd to manage holding and
+ * releasing the subsidiary side of the console.  It is sufficient to hold the
+ * subsidiary side's vnode and bump the associated snode's reference count to
+ * preserve the subsidiary's STREAMS configuration while the associated zone
+ * runs, so that's what the ioctls do.
  *
  *
- * ZC_HOLDSLAVE
+ * ZC_HOLDSUBSID
  *
  * This ioctl takes a file descriptor as an argument.  It effectively gets a
- * reference to the slave side's minor node's vnode and bumps the associated
- * snode's reference count.  The vnode reference is stored in the zcons device
- * node's soft state.  This ioctl succeeds if the given file descriptor refers
- * to the slave side's minor node or if there is already a reference to the
- * slave side's minor node's vnode in the device's soft state.
+ * reference to the subsidiary side's minor node's vnode and bumps the
+ * associated snode's reference count.  The vnode reference is stored in the
+ * zcons device node's soft state.  This ioctl succeeds if the given file
+ * descriptor refers to the subsidiary side's minor node or if there is already
+ * a reference to the subsidiary side's minor node's vnode in the device's soft
+ * state.
  *
  *
- * ZC_RELEASESLAVE
+ * ZC_RELEASESUBSID
  *
  * This ioctl takes a file descriptor as an argument.  It effectively releases
  * the vnode reference stored in the zcons device node's soft state (which was
- * previously acquired via ZC_HOLDSLAVE) and decrements the reference count of
+ * previously acquired via ZC_HOLDSUBSID) and decrements the reference count of
  * the snode associated with the vnode.  This ioctl succeeds if the given file
- * descriptor refers to the slave side's minor node or if no reference to the
- * slave side's minor node's vnode is stored in the device's soft state.
+ * descriptor refers to the subsidiary side's minor node or if no reference to
+ * the subsidiary side's minor node's vnode is stored in the device's soft
+ * state.
  *
  *
  * Note that the file descriptor arguments for both ioctls must be cast to
@@ -117,35 +120,36 @@
  *
  *     Zone boot:
  *     1.  While booting the zone, zoneadmd creates an instance of zcons.
- *     2.  zoneadmd opens the master and slave sides of the new zone console
- *         and issues the ZC_HOLDSLAVE ioctl on the master side, passing its
- *         file descriptor for the slave side as the ioctl argument.
- *     3.  zcons holds the slave side's vnode, bumps the snode's reference
+ *     2.  zoneadmd opens the manager and subsidiary sides of the new zone
+ *         console and issues the ZC_HOLDSUBSID ioctl on the manager side,
+ *         passing its file descriptor for the subsidiary side as the ioctl
+ *         argument.
+ *     3.  zcons holds the subsidiary side's vnode, bumps the snode's reference
  *         count, and stores a pointer to the vnode in the device's soft
  *         state.
- *     4.  zoneadmd closes the master and slave sides and continues to boot
- *         the zone.
+ *     4.  zoneadmd closes the manager and subsidiary sides and continues to
+ *         boot the zone.
  *
  *     Zone halt:
- *     1.  While halting the zone, zoneadmd opens the master and slave sides
- *         of the zone's console and issues the ZC_RELEASESLAVE ioctl on the
- *         master side, passing its file descriptor for the slave side as the
- *         ioctl argument.
- *     2.  zcons decrements the slave side's snode's reference count, releases
- *         the slave's vnode, and eliminates its reference to the vnode in the
- *         device's soft state.
- *     3.  zoneadmd closes the master and slave sides.
+ *     1.  While halting the zone, zoneadmd opens the manager and subsidiary
+ *         sides of the zone's console and issues the ZC_RELEASESUBSID ioctl on
+ *         the manager side, passing its file descriptor for the subsidiary
+ *         side as the ioctl argument.
+ *     2.  zcons decrements the subsidiary side's snode's reference count,
+ *         releases the subsidiary's vnode, and eliminates its reference to the
+ *         vnode in the device's soft state.
+ *     3.  zoneadmd closes the manager and subsidiary sides.
  *     4.  zoneadmd destroys the zcons device and continues to halt the zone.
  *
- * It is necessary for zoneadmd to hold the slave open while issuing
- * ZC_RELEASESLAVE because zcons might otherwise release the last reference to
- * the slave's vnode.  If it does, then specfs will panic because it will expect
- * that the STREAMS configuration for the vnode was destroyed, which VN_RELE
- * doesn't do.  Forcing zoneadmd to hold the slave open guarantees that zcons
- * won't release the vnode's last reference.  zoneadmd will properly destroy the
- * vnode and the snode when it closes the file descriptor.
+ * It is necessary for zoneadmd to hold the subsidiary open while issuing
+ * ZC_RELEASESUBSID because zcons might otherwise release the last reference to
+ * the subsidiary's vnode.  If it does, then specfs will panic because it will
+ * expect that the STREAMS configuration for the vnode was destroyed, which
+ * VN_RELE doesn't do.  Forcing zoneadmd to hold the subsidiary open guarantees
+ * that zcons won't release the vnode's last reference.  zoneadmd will properly
+ * destroy the vnode and the snode when it closes the file descriptor.
  *
- * Technically, any process that can access the master side can issue these
+ * Technically, any process that can access the manager side can issue these
  * ioctls, but they should be treated as private interfaces for zoneadmd.
  */
 
@@ -186,21 +190,22 @@ static int zc_wsrv(queue_t *);
 
 /*
  * The instance number is encoded in the dev_t in the minor number; the lowest
- * bit of the minor number is used to track the master vs. slave side of the
- * virtual console.  The rest of the bits in the minor number are the instance.
+ * bit of the minor number is used to track the manager vs. subsidiary side of
+ * the virtual console.  The rest of the bits in the minor number are the
+ * instance.
  */
-#define	ZC_MASTER_MINOR		0
-#define	ZC_SLAVE_MINOR		1
+#define	ZC_MANAGER_MINOR	0
+#define	ZC_SUBSID_MINOR		1
 
 #define	ZC_INSTANCE(x)		(getminor((x)) >> 1)
 #define	ZC_NODE(x)		(getminor((x)) & 0x01)
 
 /*
- * This macro converts a zc_state_t pointer to the associated slave minor node's
- * dev_t.
+ * This macro converts a zc_state_t pointer to the associated subsidiary minor
+ * node's dev_t.
  */
-#define	ZC_STATE_TO_SLAVEDEV(x)	(makedevice(ddi_driver_major((x)->zc_devinfo), \
-	(minor_t)(ddi_get_instance((x)->zc_devinfo) << 1 | ZC_SLAVE_MINOR)))
+#define	ZC_STATE_TO_SUBDEV(x)	(makedevice(ddi_driver_major((x)->zc_devinfo), \
+	(minor_t)(ddi_get_instance((x)->zc_devinfo) << 1 | ZC_SUBSID_MINOR)))
 
 int zcons_debug = 0;
 #define	DBG(a)   if (zcons_debug) cmn_err(CE_NOTE, a)
@@ -272,9 +277,9 @@ static struct modlinkage modlinkage = {
 
 typedef struct zc_state {
 	dev_info_t *zc_devinfo;
-	queue_t *zc_master_rdq;
-	queue_t *zc_slave_rdq;
-	vnode_t *zc_slave_vnode;
+	queue_t *zc_manager_rdq;
+	queue_t *zc_subsid_rdq;
+	vnode_t *zc_subsid_vnode;
 	int zc_state;
 } zc_state_t;
 
@@ -284,7 +289,7 @@ typedef struct zc_state {
 static void *zc_soft_state;
 
 /*
- * List of STREAMS modules that should be pushed onto every slave instance.
+ * List of STREAMS modules that should be pushed onto every subsidiary instance.
  */
 static char *zcons_mods[] = {
 	"ptem",
@@ -343,12 +348,12 @@ zc_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		return (DDI_FAILURE);
 
 	/*
-	 * Create the master and slave minor nodes.
+	 * Create the manager and subsidiary minor nodes.
 	 */
-	if ((ddi_create_minor_node(dip, ZCONS_SLAVE_NAME, S_IFCHR,
-	    instance << 1 | ZC_SLAVE_MINOR, DDI_PSEUDO, 0) == DDI_FAILURE) ||
-	    (ddi_create_minor_node(dip, ZCONS_MASTER_NAME, S_IFCHR,
-	    instance << 1 | ZC_MASTER_MINOR, DDI_PSEUDO, 0) == DDI_FAILURE)) {
+	if ((ddi_create_minor_node(dip, ZCONS_SUBSIDIARY_NAME, S_IFCHR,
+	    instance << 1 | ZC_SUBSID_MINOR, DDI_PSEUDO, 0) == DDI_FAILURE) ||
+	    (ddi_create_minor_node(dip, ZCONS_MANAGER_NAME, S_IFCHR,
+	    instance << 1 | ZC_MANAGER_MINOR, DDI_PSEUDO, 0) == DDI_FAILURE)) {
 		ddi_remove_minor_node(dip, NULL);
 		ddi_soft_state_free(zc_soft_state, instance);
 		return (DDI_FAILURE);
@@ -388,7 +393,6 @@ zc_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
  * zc_getinfo()
  *	getinfo(9e) entrypoint.
  */
-/*ARGSUSED*/
 static int
 zc_getinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
 {
@@ -410,7 +414,7 @@ zc_getinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
 
 /*
  * Return the equivalent queue from the other side of the relationship.
- * e.g.: given the slave's write queue, return the master's write queue.
+ * e.g.: given the subsidiary's write queue, return the manager's write queue.
  */
 static queue_t *
 zc_switch(queue_t *qp)
@@ -418,16 +422,19 @@ zc_switch(queue_t *qp)
 	zc_state_t *zcs = qp->q_ptr;
 	ASSERT(zcs != NULL);
 
-	if (qp == zcs->zc_master_rdq)
-		return (zcs->zc_slave_rdq);
-	else if (OTHERQ(qp) == zcs->zc_master_rdq && zcs->zc_slave_rdq != NULL)
-		return (OTHERQ(zcs->zc_slave_rdq));
-	else if (qp == zcs->zc_slave_rdq)
-		return (zcs->zc_master_rdq);
-	else if (OTHERQ(qp) == zcs->zc_slave_rdq && zcs->zc_master_rdq != NULL)
-		return (OTHERQ(zcs->zc_master_rdq));
-	else
+	if (qp == zcs->zc_manager_rdq) {
+		return (zcs->zc_subsid_rdq);
+	} else if (OTHERQ(qp) == zcs->zc_manager_rdq &&
+	    zcs->zc_subsid_rdq != NULL) {
+		return (OTHERQ(zcs->zc_subsid_rdq));
+	} else if (qp == zcs->zc_subsid_rdq) {
+		return (zcs->zc_manager_rdq);
+	} else if (OTHERQ(qp) == zcs->zc_subsid_rdq &&
+	    zcs->zc_manager_rdq != NULL) {
+		return (OTHERQ(zcs->zc_manager_rdq));
+	} else {
 		return (NULL);
+	}
 }
 
 /*
@@ -440,17 +447,16 @@ zc_side(queue_t *qp)
 	zc_state_t *zcs = qp->q_ptr;
 	ASSERT(zcs != NULL);
 
-	if (qp == zcs->zc_master_rdq ||
-	    OTHERQ(qp) == zcs->zc_master_rdq) {
-		return ("master");
+	if (qp == zcs->zc_manager_rdq ||
+	    OTHERQ(qp) == zcs->zc_manager_rdq) {
+		return ("manager");
 	}
-	ASSERT(qp == zcs->zc_slave_rdq || OTHERQ(qp) == zcs->zc_slave_rdq);
-	return ("slave");
+	ASSERT(qp == zcs->zc_subsid_rdq || OTHERQ(qp) == zcs->zc_subsid_rdq);
+	return ("subsidiary");
 }
 
-/*ARGSUSED*/
 static int
-zc_master_open(zc_state_t *zcs,
+zc_manager_open(zc_state_t *zcs,
     queue_t	*rqp,	/* pointer to the read side queue */
     dev_t	*devp,	/* pointer to stream tail's dev */
     int		oflag,	/* the user open(2) supplied flags */
@@ -461,14 +467,14 @@ zc_master_open(zc_state_t *zcs,
 	struct stroptions *sop;
 
 	/*
-	 * Enforce exclusivity on the master side; the only consumer should
+	 * Enforce exclusivity on the manager side; the only consumer should
 	 * be the zoneadmd for the zone.
 	 */
 	if ((zcs->zc_state & ZC_STATE_MOPEN) != 0)
 		return (EBUSY);
 
 	if ((mop = allocb(sizeof (struct stroptions), BPRI_MED)) == NULL) {
-		DBG("zc_master_open(): mop allocation failed\n");
+		DBG("zc_manager_open(): mop allocation failed\n");
 		return (ENOMEM);
 	}
 
@@ -482,13 +488,13 @@ zc_master_open(zc_state_t *zcs,
 	qprocson(rqp);
 
 	/*
-	 * Following qprocson(), the master side is fully plumbed into the
-	 * STREAM and may send/receive messages.  Setting zcs->zc_master_rdq
-	 * will allow the slave to send messages to us (the master).
-	 * This cannot occur before qprocson() because the master is not
+	 * Following qprocson(), the manager side is fully plumbed into the
+	 * STREAM and may send/receive messages.  Setting zcs->zc_manager_rdq
+	 * will allow the subsidiary to send messages to us (the manager).
+	 * This cannot occur before qprocson() because the manager is not
 	 * ready to process them until that point.
 	 */
-	zcs->zc_master_rdq = rqp;
+	zcs->zc_manager_rdq = rqp;
 
 	/*
 	 * set up hi/lo water marks on stream head read queue and add
@@ -508,9 +514,8 @@ zc_master_open(zc_state_t *zcs,
 	return (0);
 }
 
-/*ARGSUSED*/
 static int
-zc_slave_open(zc_state_t *zcs,
+zc_subsidiary_open(zc_state_t *zcs,
     queue_t	*rqp,	/* pointer to the read side queue */
     dev_t	*devp,	/* pointer to stream tail's dev */
     int		oflag,	/* the user open(2) supplied flags */
@@ -525,7 +530,7 @@ zc_slave_open(zc_state_t *zcs,
 	uint_t anchorindex;
 
 	/*
-	 * The slave side can be opened as many times as needed.
+	 * The subsidiary side can be opened as many times as needed.
 	 */
 	if ((zcs->zc_state & ZC_STATE_SOPEN) != 0) {
 		ASSERT((rqp != NULL) && (WR(rqp)->q_ptr == zcs));
@@ -538,18 +543,18 @@ zc_slave_open(zc_state_t *zcs,
 	 * in place (see streamio(7i)) because we always want the console to
 	 * have terminal semantics.
 	 */
-	minor = ddi_get_instance(zcs->zc_devinfo) << 1 | ZC_SLAVE_MINOR;
+	minor = ddi_get_instance(zcs->zc_devinfo) << 1 | ZC_SUBSID_MINOR;
 	major = ddi_driver_major(zcs->zc_devinfo);
 	lastminor = 0;
 	anchorindex = 1;
 	if (kstr_autopush(SET_AUTOPUSH, &major, &minor, &lastminor,
 	    &anchorindex, zcons_mods) != 0) {
-		DBG("zc_slave_open(): kstr_autopush() failed\n");
+		DBG("zc_subsidiary_open(): kstr_autopush() failed\n");
 		return (EIO);
 	}
 
 	if ((mop = allocb(sizeof (struct stroptions), BPRI_MED)) == NULL) {
-		DBG("zc_slave_open(): mop allocation failed\n");
+		DBG("zc_subsidiary_open(): mop allocation failed\n");
 		return (ENOMEM);
 	}
 
@@ -566,7 +571,7 @@ zc_slave_open(zc_state_t *zcs,
 	/*
 	 * Must follow qprocson(), since we aren't ready to process until then.
 	 */
-	zcs->zc_slave_rdq = rqp;
+	zcs->zc_subsid_rdq = rqp;
 
 	/*
 	 * set up hi/lo water marks on stream head read queue and add
@@ -604,11 +609,11 @@ zc_open(queue_t *rqp,	/* pointer to the read side queue */
 		return (ENXIO);
 
 	switch (ZC_NODE(*devp)) {
-	case ZC_MASTER_MINOR:
-		ret = zc_master_open(zcs, rqp, devp, oflag, sflag, credp);
+	case ZC_MANAGER_MINOR:
+		ret = zc_manager_open(zcs, rqp, devp, oflag, sflag, credp);
 		break;
-	case ZC_SLAVE_MINOR:
-		ret = zc_slave_open(zcs, rqp, devp, oflag, sflag, credp);
+	case ZC_SUBSID_MINOR:
+		ret = zc_subsidiary_open(zcs, rqp, devp, oflag, sflag, credp);
 		break;
 	default:
 		ret = ENXIO;
@@ -621,7 +626,6 @@ zc_open(queue_t *rqp,	/* pointer to the read side queue */
 /*
  * close(9e) entrypoint.
  */
-/*ARGSUSED1*/
 static int
 zc_close(queue_t *rqp, int flag, cred_t *credp)
 {
@@ -633,33 +637,33 @@ zc_close(queue_t *rqp, int flag, cred_t *credp)
 
 	zcs = (zc_state_t *)rqp->q_ptr;
 
-	if (rqp == zcs->zc_master_rdq) {
-		DBG("Closing master side");
+	if (rqp == zcs->zc_manager_rdq) {
+		DBG("Closing manager side");
 
-		zcs->zc_master_rdq = NULL;
+		zcs->zc_manager_rdq = NULL;
 		zcs->zc_state &= ~ZC_STATE_MOPEN;
 
 		/*
-		 * qenable slave side write queue so that it can flush
-		 * its messages as master's read queue is going away
+		 * qenable subsidiary side write queue so that it can flush
+		 * its messages as manager's read queue is going away
 		 */
-		if (zcs->zc_slave_rdq != NULL) {
-			qenable(WR(zcs->zc_slave_rdq));
+		if (zcs->zc_subsid_rdq != NULL) {
+			qenable(WR(zcs->zc_subsid_rdq));
 		}
 
 		qprocsoff(rqp);
 		WR(rqp)->q_ptr = rqp->q_ptr = NULL;
 
-	} else if (rqp == zcs->zc_slave_rdq) {
+	} else if (rqp == zcs->zc_subsid_rdq) {
 
-		DBG("Closing slave side");
+		DBG("Closing subsidiary side");
 		zcs->zc_state &= ~ZC_STATE_SOPEN;
-		zcs->zc_slave_rdq = NULL;
+		zcs->zc_subsid_rdq = NULL;
 
 		wqp = WR(rqp);
 		while ((bp = getq(wqp)) != NULL) {
-			if (zcs->zc_master_rdq != NULL)
-				putnext(zcs->zc_master_rdq, bp);
+			if (zcs->zc_manager_rdq != NULL)
+				putnext(zcs->zc_manager_rdq, bp);
 			else if (bp->b_datap->db_type == M_IOCTL)
 				miocnak(wqp, bp, 0, 0);
 			else
@@ -667,11 +671,11 @@ zc_close(queue_t *rqp, int flag, cred_t *credp)
 		}
 
 		/*
-		 * Qenable master side write queue so that it can flush its
-		 * messages as slaves's read queue is going away.
+		 * Qenable manager side write queue so that it can flush its
+		 * messages as subsidiarys's read queue is going away.
 		 */
-		if (zcs->zc_master_rdq != NULL)
-			qenable(WR(zcs->zc_master_rdq));
+		if (zcs->zc_manager_rdq != NULL)
+			qenable(WR(zcs->zc_manager_rdq));
 
 		qprocsoff(rqp);
 		WR(rqp)->q_ptr = rqp->q_ptr = NULL;
@@ -681,7 +685,8 @@ zc_close(queue_t *rqp, int flag, cred_t *credp)
 		 * to set up sad configuration.
 		 */
 		major = ddi_driver_major(zcs->zc_devinfo);
-		minor = ddi_get_instance(zcs->zc_devinfo) << 1 | ZC_SLAVE_MINOR;
+		minor = ddi_get_instance(zcs->zc_devinfo) << 1 |
+		    ZC_SUBSID_MINOR;
 		(void) kstr_autopush(CLR_AUTOPUSH, &major, &minor, NULL, NULL,
 		    NULL);
 	}
@@ -729,9 +734,9 @@ handle_mflush(queue_t *qp, mblk_t *mp)
 }
 
 /*
- * wput(9E) is symmetric for master and slave sides, so this handles both
+ * wput(9E) is symmetric for manager and subsidiary sides, so this handles both
  * without splitting the codepath.  (The only exception to this is the
- * processing of zcons ioctls, which is restricted to the master side.)
+ * processing of zcons ioctls, which is restricted to the manager side.)
  *
  * zc_wput() looks at the other side; if there is no process holding that
  * side open, it frees the message.  This prevents processes from hanging
@@ -746,34 +751,34 @@ zc_wput(queue_t *qp, mblk_t *mp)
 	unsigned char type = mp->b_datap->db_type;
 	zc_state_t *zcs;
 	struct iocblk *iocbp;
-	file_t *slave_filep;
-	struct snode *slave_snodep;
-	int slave_fd;
+	file_t *subsidiary_filep;
+	struct snode *subsidiary_snodep;
+	int subsidiary_fd;
 
 	ASSERT(qp->q_ptr);
 
 	DBG1("entering zc_wput, %s side", zc_side(qp));
 
 	/*
-	 * Process zcons ioctl messages if qp is the master console's write
+	 * Process zcons ioctl messages if qp is the manager console's write
 	 * queue.
 	 */
 	zcs = (zc_state_t *)qp->q_ptr;
-	if (zcs->zc_master_rdq != NULL && qp == WR(zcs->zc_master_rdq) &&
+	if (zcs->zc_manager_rdq != NULL && qp == WR(zcs->zc_manager_rdq) &&
 	    type == M_IOCTL) {
 		iocbp = (struct iocblk *)(void *)mp->b_rptr;
 		switch (iocbp->ioc_cmd) {
-		case ZC_HOLDSLAVE:
+		case ZC_HOLDSUBSID:
 			/*
-			 * Hold the slave's vnode and increment the refcount
-			 * of the snode.  If the vnode is already held, then
-			 * indicate success.
+			 * Hold the subsidiary's vnode and increment the
+			 * refcount of the snode.  If the vnode is already
+			 * held, then indicate success.
 			 */
 			if (iocbp->ioc_count != TRANSPARENT) {
 				miocack(qp, mp, 0, EINVAL);
 				return (0);
 			}
-			if (zcs->zc_slave_vnode != NULL) {
+			if (zcs->zc_subsid_vnode != NULL) {
 				miocack(qp, mp, 0, 0);
 				return (0);
 			}
@@ -789,49 +794,49 @@ zc_wput(queue_t *qp, mblk_t *mp)
 
 			/*
 			 * The calling process must pass a file descriptor for
-			 * the slave device.
+			 * the subsidiary device.
 			 */
-			slave_fd =
+			subsidiary_fd =
 			    (int)(intptr_t)*(caddr_t *)(void *)mp->b_cont->
 			    b_rptr;
-			slave_filep = getf(slave_fd);
-			if (slave_filep == NULL) {
+			subsidiary_filep = getf(subsidiary_fd);
+			if (subsidiary_filep == NULL) {
 				miocack(qp, mp, 0, EINVAL);
 				return (0);
 			}
-			if (ZC_STATE_TO_SLAVEDEV(zcs) !=
-			    slave_filep->f_vnode->v_rdev) {
-				releasef(slave_fd);
+			if (ZC_STATE_TO_SUBDEV(zcs) !=
+			    subsidiary_filep->f_vnode->v_rdev) {
+				releasef(subsidiary_fd);
 				miocack(qp, mp, 0, EINVAL);
 				return (0);
 			}
 
 			/*
-			 * Get a reference to the slave's vnode.  Also bump the
-			 * reference count on the associated snode.
+			 * Get a reference to the subsidiary's vnode.  Also
+			 * bump the reference count on the associated snode.
 			 */
-			ASSERT(vn_matchops(slave_filep->f_vnode,
+			ASSERT(vn_matchops(subsidiary_filep->f_vnode,
 			    spec_getvnodeops()));
-			zcs->zc_slave_vnode = slave_filep->f_vnode;
-			VN_HOLD(zcs->zc_slave_vnode);
-			slave_snodep = VTOCS(zcs->zc_slave_vnode);
-			mutex_enter(&slave_snodep->s_lock);
-			++slave_snodep->s_count;
-			mutex_exit(&slave_snodep->s_lock);
-			releasef(slave_fd);
+			zcs->zc_subsid_vnode = subsidiary_filep->f_vnode;
+			VN_HOLD(zcs->zc_subsid_vnode);
+			subsidiary_snodep = VTOCS(zcs->zc_subsid_vnode);
+			mutex_enter(&subsidiary_snodep->s_lock);
+			++subsidiary_snodep->s_count;
+			mutex_exit(&subsidiary_snodep->s_lock);
+			releasef(subsidiary_fd);
 			miocack(qp, mp, 0, 0);
 			return (0);
-		case ZC_RELEASESLAVE:
+		case ZC_RELEASESUBSID:
 			/*
-			 * Release the master's handle on the slave's vnode.
-			 * If there isn't a handle for the vnode, then indicate
-			 * success.
+			 * Release the manager's handle on the subsidiary's
+			 * vnode.  If there isn't a handle for the vnode, then
+			 * indicate success.
 			 */
 			if (iocbp->ioc_count != TRANSPARENT) {
 				miocack(qp, mp, 0, EINVAL);
 				return (0);
 			}
-			if (zcs->zc_slave_vnode == NULL) {
+			if (zcs->zc_subsid_vnode == NULL) {
 				miocack(qp, mp, 0, 0);
 				return (0);
 			}
@@ -847,20 +852,20 @@ zc_wput(queue_t *qp, mblk_t *mp)
 
 			/*
 			 * The process that passed the ioctl must have provided
-			 * a file descriptor for the slave device.  Make sure
-			 * this is correct.
+			 * a file descriptor for the subsidiary device.  Make
+			 * sure this is correct.
 			 */
-			slave_fd =
+			subsidiary_fd =
 			    (int)(intptr_t)*(caddr_t *)(void *)mp->b_cont->
 			    b_rptr;
-			slave_filep = getf(slave_fd);
-			if (slave_filep == NULL) {
+			subsidiary_filep = getf(subsidiary_fd);
+			if (subsidiary_filep == NULL) {
 				miocack(qp, mp, 0, EINVAL);
 				return (0);
 			}
-			if (zcs->zc_slave_vnode->v_rdev !=
-			    slave_filep->f_vnode->v_rdev) {
-				releasef(slave_fd);
+			if (zcs->zc_subsid_vnode->v_rdev !=
+			    subsidiary_filep->f_vnode->v_rdev) {
+				releasef(subsidiary_fd);
 				miocack(qp, mp, 0, EINVAL);
 				return (0);
 			}
@@ -869,15 +874,15 @@ zc_wput(queue_t *qp, mblk_t *mp)
 			 * Decrement the snode's reference count and release the
 			 * vnode.
 			 */
-			ASSERT(vn_matchops(slave_filep->f_vnode,
+			ASSERT(vn_matchops(subsidiary_filep->f_vnode,
 			    spec_getvnodeops()));
-			slave_snodep = VTOCS(zcs->zc_slave_vnode);
-			mutex_enter(&slave_snodep->s_lock);
-			--slave_snodep->s_count;
-			mutex_exit(&slave_snodep->s_lock);
-			VN_RELE(zcs->zc_slave_vnode);
-			zcs->zc_slave_vnode = NULL;
-			releasef(slave_fd);
+			subsidiary_snodep = VTOCS(zcs->zc_subsid_vnode);
+			mutex_enter(&subsidiary_snodep->s_lock);
+			--subsidiary_snodep->s_count;
+			mutex_exit(&subsidiary_snodep->s_lock);
+			VN_RELE(zcs->zc_subsid_vnode);
+			zcs->zc_subsid_vnode = NULL;
+			releasef(subsidiary_fd);
 			miocack(qp, mp, 0, 0);
 			return (0);
 		default:
@@ -939,7 +944,7 @@ zc_wput(queue_t *qp, mblk_t *mp)
 }
 
 /*
- * rsrv(9E) is symmetric for master and slave, so zc_rsrv() handles both
+ * rsrv(9E) is symmetric for manager and subsidiary, so zc_rsrv() handles both
  * without splitting up the codepath.
  *
  * Enable the write side of the partner.  This triggers the partner to send
@@ -952,10 +957,10 @@ zc_rsrv(queue_t *qp)
 	zcs = (zc_state_t *)qp->q_ptr;
 
 	/*
-	 * Care must be taken here, as either of the master or slave side
+	 * Care must be taken here, as either of the manager or subsidiary side
 	 * qptr could be NULL.
 	 */
-	ASSERT(qp == zcs->zc_master_rdq || qp == zcs->zc_slave_rdq);
+	ASSERT(qp == zcs->zc_manager_rdq || qp == zcs->zc_subsid_rdq);
 	if (zc_switch(qp) == NULL) {
 		DBG("zc_rsrv: other side isn't listening\n");
 		return (0);
@@ -965,8 +970,8 @@ zc_rsrv(queue_t *qp)
 }
 
 /*
- * This routine is symmetric for master and slave, so it handles both without
- * splitting up the codepath.
+ * This routine is symmetric for manager and subsidiary, so it handles both
+ * without splitting up the codepath.
  *
  * If there are messages on this queue that can be sent to the other, send
  * them via putnext(). Else, if queued messages cannot be sent, leave them
@@ -977,7 +982,7 @@ zc_wsrv(queue_t *qp)
 {
 	mblk_t *mp;
 
-	DBG1("zc_wsrv master (%s) side", zc_side(qp));
+	DBG1("zc_wsrv manager (%s) side", zc_side(qp));
 
 	/*
 	 * Partner has no read queue, so take the data, and throw it away.
diff --git a/usr/src/uts/common/sys/ptms.h b/usr/src/uts/common/sys/ptms.h
index 55987fe6d7..23594fdc13 100644
--- a/usr/src/uts/common/sys/ptms.h
+++ b/usr/src/uts/common/sys/ptms.h
@@ -35,18 +35,17 @@ extern "C" {
 #ifdef _KERNEL
 
 /*
- * Structures and definitions supporting the pseudo terminal
- * drivers. This structure is private and should not be used by any
- * applications.
+ * Structures and definitions supporting the pseudo-terminal drivers. This
+ * structure is private and should not be used by any applications.
  */
 struct pt_ttys {
-	queue_t *ptm_rdq; 	/* master's read queue pointer */
-	queue_t *pts_rdq; 	/* slave's read queue pointer */
+	queue_t *ptm_rdq;	/* manager's read queue pointer */
+	queue_t *pts_rdq;	/* subsidiary's read queue pointer */
 	mblk_t	*pt_nullmsg;	/* 0-bytes message block for pts close */
 	pid_t	 pt_pid;	/* process id (for debugging) */
 	minor_t	 pt_minor;	/* Minor number of this pty */
 	int	 pt_refcnt;	/* reference count for ptm_rdq/pts_rdq uses */
-	ushort_t pt_state;	/* state of master/slave pair */
+	ushort_t pt_state;	/* state of manager/subsidiary pair */
 	kcondvar_t pt_cv;	/* condition variable for exclusive access */
 	kmutex_t pt_lock;	/* Per-element lock */
 	zoneid_t pt_zoneid;	/* Zone membership for this pty */
@@ -57,10 +56,10 @@ struct pt_ttys {
 /*
  * pt_state values
  */
-#define	PTLOCK		0x01	/* master/slave pair is locked */
-#define	PTMOPEN 	0x02  	/* master side is open */
-#define	PTSOPEN 	0x04	/* slave side is open */
-#define	PTSTTY		0x08	/* slave side is tty */
+#define	PTLOCK		0x01	/* manager/subsidiary pair is locked */
+#define	PTMOPEN		0x02	/* manager side is open */
+#define	PTSOPEN		0x04	/* subsidiary side is open */
+#define	PTSTTY		0x08	/* subsidiary side is tty */
 
 /*
  * Multi-threading primitives.
@@ -104,17 +103,17 @@ struct pt_ttys {
  * ptms_lock and pt_cnt are defined in ptms_conf.c
  */
 extern kmutex_t		ptms_lock;
-extern dev_info_t 	*pts_dip;	/* private copy of devinfo ptr */
+extern dev_info_t	*pts_dip;	/* private copy of devinfo ptr */
 
 extern void ptms_init(void);
 extern struct pt_ttys *pt_ttys_alloc(void);
 extern void ptms_close(struct pt_ttys *, uint_t);
 extern struct pt_ttys *ptms_minor2ptty(minor_t);
-extern int ptms_attach_slave(void);
+extern int ptms_attach_subsidiary(void);
 extern int ptms_minor_valid(minor_t ptmin, uid_t *uid, gid_t *gid);
 extern int ptms_minor_exists(minor_t ptmin);
 extern void ptms_set_owner(minor_t ptmin, uid_t uid, gid_t gid);
-extern major_t ptms_slave_attached(void);
+extern major_t ptms_subsidiary_attached(void);
 
 #ifdef DEBUG
 extern void ptms_log(char *, uint_t);
@@ -134,28 +133,32 @@ typedef struct pt_own {
 } pt_own_t;
 
 /*
- * ioctl commands
+ * IOCTL COMMANDS
  *
- *  ISPTM: Determines whether the file descriptor is that of an open master
- *	   device. Return code of zero indicates that the file descriptor
- *	   represents master device.
+ *	ISPTM
+ *		Determines whether the file descriptor is that of an open
+ *		manager device.  Return code of zero indicates that the file
+ *		descriptor represents a manager device.
  *
- * UNLKPT: Unlocks the master and slave devices.  It returns 0 on success. On
- *	   failure, the errno is set to EINVAL indicating that the master
- *	   device is not open.
+ *	UNLKPT
+ *		Unlocks the manager and subsidiary devices.  It returns 0 on
+ *		success.  On failure, the errno is set to EINVAL indicating
+ *		that the manager device is not open.
  *
- *  ZONEPT: Sets the zoneid of the pair of master and slave devices.  It
- *	    returns 0 upon success.  Used to force a pty 'into' a zone upon
- *	    zone entry.
- *
- * PT_OWNER: Sets uid and gid for slave device.  It returns 0 on success.
+ *	ZONEPT
+ *		Sets the zoneid of the pair of manager and subsidiary devices.
+ *		It returns 0 upon success.  Used to force a pty 'into' a zone
+ *		upon zone entry.
  *
+ *	PT_OWNER
+ *		Sets uid and gid for subsidiary device.  It returns 0 on
+ *		success.
  */
-#define	ISPTM		(('P'<<8)|1)	/* query for master */
-#define	UNLKPT		(('P'<<8)|2)	/* unlock master/slave pair */
-#define	PTSSTTY		(('P'<<8)|3)	/* set tty flag */
-#define	ZONEPT		(('P'<<8)|4)	/* set zone of master/slave pair */
-#define	OWNERPT		(('P'<<8)|5)	/* set owner/group for slave device */
+#define	ISPTM		(('P'<<8)|1)  /* query for manager */
+#define	UNLKPT		(('P'<<8)|2)  /* unlock manager/subsidiary pair */
+#define	PTSSTTY		(('P'<<8)|3)  /* set tty flag */
+#define	ZONEPT		(('P'<<8)|4)  /* set zone of manager/subsidiary pair */
+#define	OWNERPT		(('P'<<8)|5)  /* set owner/group for subsidiary */
 
 #ifdef	__cplusplus
 }
diff --git a/usr/src/uts/common/sys/ptyvar.h b/usr/src/uts/common/sys/ptyvar.h
index 76bc74c36a..ee00379fd8 100644
--- a/usr/src/uts/common/sys/ptyvar.h
+++ b/usr/src/uts/common/sys/ptyvar.h
@@ -25,14 +25,12 @@
  */
 
 /*
- * Pseudo-tty driver data structures.
+ * Pseudo-terminal driver data structures.
  */
 
 #ifndef	_SYS_PTYVAR_H
 #define	_SYS_PTYVAR_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/tty.h>
 
 #ifdef	__cplusplus
@@ -49,8 +47,8 @@ struct pty {
 	struct proc *pt_selr;		/* proc selecting on controller read */
 	struct proc *pt_selw;		/* proc selecting on controller write */
 	struct proc *pt_sele;		/* proc selecting on exception */
-	dev_t	pt_sdev;		/* XXX dev no for the slave */
-	struct vnode *pt_vnode;		/* XXX vnode for the slave */
+	dev_t	pt_sdev;		/* XXX dev no for the subsidiary */
+	struct vnode *pt_vnode;		/* XXX vnode for the subsidiary */
 	short	pt_pgrp;		/* controller side process group */
 	uchar_t	pt_send;		/* pending message to controller */
 	uchar_t	pt_ucntl;		/* pending iocontrol for controller */
@@ -67,11 +65,11 @@ struct pty {
 #define	PF_ASYNC	0x00000010	/* asynchronous I/O on controller */
 #define	PF_WOPEN	0x00000020	/* waiting for open to complete */
 #define	PF_CARR_ON	0x00000040	/* "carrier" is on (cntlr. is open) */
-#define	PF_SLAVEGONE	0x00000080	/* slave was open, but is now closed */
+#define	PF_SUBSIDGONE	0x00000080	/* subsidiary was open, now closed */
 #define	PF_PKT		0x00000100	/* packet mode */
 #define	PF_STOPPED	0x00000200	/* user told stopped */
 #define	PF_REMOTE	0x00000400	/* remote and flow controlled input */
-#define	PF_NOSTOP	0x00000800	/* slave is doing XON/XOFF */
+#define	PF_NOSTOP	0x00000800	/* subsidiary is doing XON/XOFF */
 #define	PF_UCNTL	0x00001000	/* user control mode */
 #define	PF_43UCNTL	0x00002000	/* real 4.3 user control mode */
 #define	PF_IOCTL	0x00004000	/* ioctl call in progress */
diff --git a/usr/src/uts/common/sys/termios.h b/usr/src/uts/common/sys/termios.h
index 86ee3980c4..39106a14fc 100644
--- a/usr/src/uts/common/sys/termios.h
+++ b/usr/src/uts/common/sys/termios.h
@@ -478,7 +478,7 @@ struct ppsclockev32 {
 /* pseudo-tty */
 
 #define	TIOCREMOTE	(tIOC|30)	/* remote input editing */
-#define	TIOCSIGNAL	(tIOC|31)	/* pty: send signal to slave */
+#define	TIOCSIGNAL	(tIOC|31)	/* pty: send signal to subsidiary */
 
 
 /* Some more 386 xenix stuff */
diff --git a/usr/src/uts/common/sys/zcons.h b/usr/src/uts/common/sys/zcons.h
index 218d1a67ad..84abdc12fb 100644
--- a/usr/src/uts/common/sys/zcons.h
+++ b/usr/src/uts/common/sys/zcons.h
@@ -33,19 +33,19 @@ extern "C" {
 #endif
 
 /*
- * Minor node name of the global zone side (often called the "master" side)
+ * Minor node name of the global zone side (often called the "manager" side)
  * of the zcons driver.
  */
-#define	ZCONS_MASTER_NAME	"masterconsole"
+#define	ZCONS_MANAGER_NAME	"globalconsole"
 
 /*
- * Minor node name of the non-global zone side (often called the "slave"
- * side) of the zcons driver.  We name it "zoneconsole" since that nameo
+ * Minor node name of the non-global zone side (often called the "subsidiary"
+ * side) of the zcons driver.  We name it "zoneconsole" since that name
  * will show up in 'ps' output, and will make some sense to the global zone
  * user.  Inside the zone, it will simply show up as "console" due to the
  * links we create.
  */
-#define	ZCONS_SLAVE_NAME	"zoneconsole"
+#define	ZCONS_SUBSIDIARY_NAME	"zoneconsole"
 
 /*
  * ZC_IOC forms the base for all zcons ioctls.
@@ -53,18 +53,18 @@ extern "C" {
 #define	ZC_IOC		(('Z' << 24) | ('o' << 16) | ('n' << 8))
 
 /*
- * These ioctls instruct the master side of the console to hold or release
- * a reference to the slave side's vnode.  They are meant to be issued by
+ * These ioctls instruct the manager side of the console to hold or release
+ * a reference to the subsidiary side's vnode.  They are meant to be issued by
  * zoneadmd after the console device node is created and before it is destroyed
- * so that the slave's STREAMS anchor, ptem, is preserved when ttymon starts
- * popping STREAMS modules from within the associated zone.  This guarantees
- * that the zone slave console will always have terminal semantics while the
- * zone is running.
+ * so that the subsidiary's STREAMS anchor, ptem, is preserved when ttymon
+ * starts popping STREAMS modules from within the associated zone.  This
+ * guarantees that the zone subsidiary console will always have terminal
+ * semantics while the zone is running.
  *
  * A more detailed description can be found in uts/common/io/zcons.c.
  */
-#define	ZC_HOLDSLAVE	(ZC_IOC | 0)	/* get and save slave side reference */
-#define	ZC_RELEASESLAVE	(ZC_IOC | 1)	/* release slave side reference */
+#define	ZC_HOLDSUBSID		(ZC_IOC | 0)
+#define	ZC_RELEASESUBSID	(ZC_IOC | 1)
 
 #ifdef	__cplusplus
 }
-- 
2.40.1

