diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 02fc9f8467..405b3d6527 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -205,6 +205,7 @@ GENUNIX_OBJS +=	\
 		gid.o		\
 		groups.o	\
 		grow.o		\
+		hat.o		\
 		hat_refmod.o	\
 		id32.o		\
 		id_space.o	\
diff --git a/usr/src/uts/common/vm/hat.h b/usr/src/uts/common/vm/hat.h
index a2509e7bb6..45c4198836 100644
--- a/usr/src/uts/common/vm/hat.h
+++ b/usr/src/uts/common/vm/hat.h
@@ -181,6 +181,10 @@ void	hat_thread_exit(kthread_t *);
  * pfn_t hat_getpfnum(hat, addr)
  *	returns pfn for <hat, addr> or PFN_INVALID if mapping is invalid.
  *
+ * pfn_t hat_getkpfnum(addr)
+ *	returns pfn for non-memory mapped addr in kernel address space
+ *	or PFN_INVALID if mapping is invalid or is kernel memory.
+ *
  * int hat_probe(hat, addr)
  *	return 0 if no valid mapping is present.  Faster version
  *	of hat_getattr in certain architectures.
@@ -234,6 +238,14 @@ void	hat_reserve(struct as *, caddr_t, size_t);
 pfn_t	va_to_pfn(void *);
 uint64_t va_to_pa(void *);
 
+/*
+ * hat_getkpfnum() is only supported on sparc
+ */
+#ifdef __sparc
+pfn_t	hat_getkpfnum(caddr_t);
+#endif
+
+
 /*
  * Kernel Physical Mapping (segkpm) hat interface routines.
  */
@@ -505,6 +517,13 @@ void	hat_getstat(struct as *, caddr_t, size_t, uint_t, char *, int);
 void	hat_freestat(struct as *, int);
 void	hat_resvstat(size_t, struct as *, caddr_t);
 
+/*
+ * Transitionary routine while we still allow hat_getkpfnum(caddr_t)
+ * to return a pfn for kernel memory, but want to warn the user that
+ * it isn't supported.
+ */
+void	hat_getkpfnum_badcall(void *caller);
+
 /*
  * Relocation callback routines. Currently only sfmmu HAT supports
  * these.
diff --git a/usr/src/uts/sfmmu/vm/hat_sfmmu.c b/usr/src/uts/sfmmu/vm/hat_sfmmu.c
index 76617cb130..a3b48387fa 100644
--- a/usr/src/uts/sfmmu/vm/hat_sfmmu.c
+++ b/usr/src/uts/sfmmu/vm/hat_sfmmu.c
@@ -376,6 +376,14 @@ static id_t sfmmu_cb_nextid = 0;
 static id_t sfmmu_tsb_cb_id;
 struct sfmmu_callback *sfmmu_cb_table;
 
+/*
+ * Kernel page relocation is enabled by default for non-caged
+ * kernel pages.  This has little effect unless segkmem_reloc is
+ * set, since by default kernel memory comes from inside the
+ * kernel cage.
+ */
+int hat_kpr_enabled = 1;
+
 kmutex_t	kpr_mutex;
 kmutex_t	kpr_suspendlock;
 kthread_t	*kreloc_thread;
@@ -6759,7 +6767,7 @@ hat_page_relocate(page_t **target, page_t **replacement, spgcnt_t *nrelocp)
 	int		cflags = 0;
 #endif
 
-	if (!kcage_on || PP_ISNORELOC(*target)) {
+	if (hat_kpr_enabled == 0 || !kcage_on || PP_ISNORELOC(*target)) {
 		PAGE_RELOCATE_LOG(target, replacement, EAGAIN, -1);
 		return (EAGAIN);
 	}
@@ -7773,7 +7781,7 @@ sfmmu_check_kpfn(pfn_t pfn)
 	if (hat_check_vtop == 0)
 		return;
 
-	if (kvseg.s_base == NULL || panicstr)
+	if (hat_kpr_enabled == 0 || kvseg.s_base == NULL || panicstr)
 		return;
 
 	pp = page_numtopp_nolock(pfn);
@@ -7862,6 +7870,57 @@ hat_getpfnum(struct hat *hat, caddr_t addr)
 	}
 }
 
+/*
+ * hat_getkpfnum() is an obsolete DDI routine, and its use is discouraged.
+ * Use hat_getpfnum(kas.a_hat, ...) instead.
+ *
+ * We'd like to return PFN_INVALID if the mappings have underlying page_t's
+ * but can't right now due to the fact that some software has grown to use
+ * this interface incorrectly. So for now when the interface is misused,
+ * return a warning to the user that in the future it won't work in the
+ * way they're abusing it, and carry on (after disabling page relocation).
+ */
+pfn_t
+hat_getkpfnum(caddr_t addr)
+{
+	pfn_t pfn;
+	tte_t tte;
+	int badcaller = 0;
+	extern int segkmem_reloc;
+
+	if (segkpm && IS_KPM_ADDR(addr)) {
+		badcaller = 1;
+		pfn = sfmmu_kpm_vatopfn(addr);
+	} else {
+		while ((pfn = sfmmu_vatopfn(addr, ksfmmup, &tte))
+		    == PFN_SUSPENDED) {
+			sfmmu_vatopfn_suspended(addr, ksfmmup, &tte);
+		}
+		badcaller = pf_is_memory(pfn);
+	}
+
+	if (badcaller) {
+		/*
+		 * We can't return PFN_INVALID or the caller may panic
+		 * or corrupt the system.  The only alternative is to
+		 * disable page relocation at this point for all kernel
+		 * memory.  This will impact any callers of page_relocate()
+		 * such as FMA or DR.
+		 *
+		 * RFE: Add junk here to spit out an ereport so the sysadmin
+		 * can be advised that he should upgrade his device driver
+		 * so that this doesn't happen.
+		 */
+		hat_getkpfnum_badcall(caller());
+		if (hat_kpr_enabled && segkmem_reloc) {
+			hat_kpr_enabled = 0;
+			segkmem_reloc = 0;
+			cmn_err(CE_WARN, "Kernel Page Relocation is DISABLED");
+		}
+	}
+	return (pfn);
+}
+
 /*
  * This routine will return both pfn and tte for the vaddr.
  */
diff --git a/usr/src/uts/sfmmu/vm/hat_sfmmu.h b/usr/src/uts/sfmmu/vm/hat_sfmmu.h
index 86f2bb538e..d1631e58ac 100644
--- a/usr/src/uts/sfmmu/vm/hat_sfmmu.h
+++ b/usr/src/uts/sfmmu/vm/hat_sfmmu.h
@@ -1080,6 +1080,8 @@ struct sfmmu_callback {
 extern int sfmmu_max_cb_id;
 extern struct sfmmu_callback *sfmmu_cb_table;
 
+extern int hat_kpr_enabled;
+
 struct pa_hment;
 
 /*
